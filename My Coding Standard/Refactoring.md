# Refactoring

**리펙토링의 필수 요소(테컴커)**

- [테스트](https://jsfootprint.tistory.com/88)
    - 유닛 단위 → 위젯 단위(컴포넌트) → 통합 단위  순
    - TDD기법으로 진행
    - 리펙터링은 유닛단위로 작게 작게 풀어 나가는 것이 가장 좋다.
    - 테스트 - 코딩 - 리펙토링 순으로 항상 진행해야한다.
    - 테스트 패턴
        - setup - exercise - verify
        - given - when - then(흔히 사용됨)
        - arrange - act - assert
        - + tearDown
- 컴파일
- 커밋

**리펙터링을 진행하면서 기존의 코드가 깨지면 절때 안된다**

**코드가 깨진다면 그 순간부터 리펙터링은 의미가 없어진다.**

**그렇기 때문에 단위 유닛 테스트가 가장 중요하다.**

- **리펙터링 악취 24**
    - 기이한 이름

        <aside>
        😂 *"...이름 짓기는 프로그래밍에서 가장 어렵기로 손꼽히는 두 가지...만약 **마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제**가 숨어 있을 가능성이 높다. ..."*

        </aside>

        [[함수 선언 바꾸기]], [[변수 이름 바꾸기]], [[필드 이름 바꾸기]]

    - 중복 코드
        - 한 클래스에 똑같은 표현식을 사용하는 경우 발견 시

            [[함수 추출]] → 양쪽 모두 추출된 메서드를 호출하게 변경

            if. 코드가 비슷하긴 한데 완전히 똑같지 않다면

            - [[문장 슬라이드]]
        - 같은 부모로부터 파생된 서브클래스들에 코드 중복 발견 시

            [[메서드 올리기]]

    - 긴 함수

        <aside>
        ⚠️ *"...훨씬 **적극적으로 함수를 쪼개야** 한다. ... 우리는 **주석을 달아야 할 만한 부분은 무조건 함수로 만들어야** 한다. 그 **함수 본문에는 주석으로 설명하려던 코드**를 넣고 **함수 이름은 동작 방식이 아닌 '의도'**가 들어나게 지어야 한다. ... 즉, **'무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리**하다. ..."*

        </aside>

        <aside>
        ⚠️ "...주석은 코드만으로 목적을 이해하기 어려운 부분에 달려 있는 경우가 많다. ..."

        </aside>

        **주석이 주렁주렁 달려있는 코드 발견시 바로 추출 → 함수 이름 짓기를 적용해야한다.**

        - 긴 함수 해결 작업의 99%, switch일땐 case마다 적용

            [[함수 추출]]

        - 매개변수, 임시변수 많을시

             [[임시 변수를 질의 함수로 변경]]

             [[매개변수 객체 만들기]]

             [[객체 통째로 넘기기]]

            [[함수를 명령으로 바꾸기]](여전히 임시변수와 매개변수 많을 시)

        - 조건문 많을시

            [[조건문 분해하기]]

        - switch문이 여러개일시

            [[조건문 다형성으로 변경]]

        - 반복문 많을시

            [[반복문 쪼개기]]

    - 긴 매개변수 목록
        - 다른 매개변수에서 값을 얻어오는 매개변수가 있을시

            [[매개변수를 질의 함수로 변경]]

        - 사용중인 data 구조에서 값들을 뽑아 각각 다른 별개의 매개변수로 전달시

            [[객체 통째로 넘기기]],

        - 항상 함께 전달되는 매개변수들 정리시

            [[매개변수 객체 만들기]],

        - 함수의 동작방식을 정하는 플래그 매개 변수 발견시

            [[플래그 인수 제거]]

        - 여러 함수가 특정 매개변수들의 값을 공통으로 사용시

            [[여러 함수 클래스로 묶기]](함수형 프로그래밍일시 [[Partially Applied Function]]을 적용)

    - 전역 데이터

        <aside>
        😈 *"전역 데이터는 이를 함부로 사용한 프로그래머들에게 벌을 주는 지옥 4층에 사는 악마들이 만들었다..."*

        </aside>

        spooky action at a distance를 주의 할 것

        static을 주의 할 것(singleton 포함)

        ### 방지 방법

        [[변수 캡슐화]]

        - **다른 코드에서 오염시킬 가능성이 있는 데이터 발견시 바로 적용 할 것**
        - **get, set 같은 접근자 함수들을 클래스나 모듈에 삽입, 그 안에서만 사용토록 수정 필요 → 접근 범위 최소화**
        - **static 같은 전역 데이터는 항상 접근 범위를 생각+조사해야한다.**
    - 가변 데이터
        - 가변 데이터 발견 시

            [[변수 캡슐화]]

        - 하나의 변수에 용도가 다른 값을 저장해 값이 갱신 될 시

            [[문장 슬라이드]]

        - 갱신 로직과 특정 코드를 분리 하고 싶을 시

            [[문장 슬라이드]] + [[함수 추출]]

        - API 제작시

            [[질의 함수와 변경 함수 분리]]

        - 변수의 유효범위를 줄이고 싶을 시

            세터 제거

        - **값을 다른 곳에서 설정 할수 있는 가변데이터 발견 시**

            <aside>
            ⚠️ *"이런 데이터는 혼동과 버그와 야근을 부를 뿐만 아니라 쓸때없는 코드이다."*

            </aside>

            [[파생 변수를 질의 함수로 바꾸기]]

        - 변수를 갱신 하는 코드들 발견시

            [[여러 함수를 클래스로 묶기]] + [[여러 함수를 변환 함수로 묶기]] (클래스로 추상화를 의미)

        - 위의 경우에 해당하는 변수가 구조체 처럼 필드에 데이터를 담고 있을 시

            [[참조를 값으로 바꾸기]]

    - 뒤엉킨 변경

        <aside>
        ⚠️ **단일 책임 원칙(Single Responsibility Principle, SRP) 위반시 발생**

        </aside>

        - Fetch logic → Calculate logic 이 흐름이 자연스러운 로직일 시

            [[단계 쪼개기]]를 저 사이에 추가(Data Modeling을 의미)

        - 전체 프로세스 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높을시

            각 맥락에 해당하는 적당한 모듈들을 만들고 함수들을 각각에 이동([[함수 이동]]),

            이때 일에 관여하는 함수가 존재시 [[함수 추출]] 먼저 선행 처리

            모듈이 클래스일시 [[클래스 추출]] 보기

    - 산탄총 부상수술

        <aside>
        ⚠️ **자잘하게 수정해야하는 클래스가 많을 시 발생**

        </aside>

        뒤엉킨 변경의 원인과 발생 과정이 비슷

        원인 : 맥락 구분을 못함

        해법(원리) : 맥락을 명확히 구분

        발생과정(현상) : 한코드에 섞임(뒤-변), 여러 코드에 흩어져있음(산-부)

        해법(실제 행동) : 맥락별로 구분(뒤-변), 맥락별로 모음(산-부)

        - 함께 변경해야될 대상들 발견시

            [[함수 이동]] + [[필드 이동]](한 모듈에 묶기)

        - 비슷한 데이터를 다루는 함수가 다량 발견 시

            [[여러 함수를 클래스로 묶기]]

        - 데이터 구조를 변환 하거나 보강하는 함수들 발견 시

            [[여러 함수를 변환 함수로 묶기]]

            위의 결과를 묶어 다음 단계의 로직으로 전달 시

            [[단계 분리]]

        - 어설프게 분리된 로직을 발견시

            함수 인라인하기 + 클래스 인라인하기

            나중에 너무 커지면 추출 필요

    - 기능 편애

        <aside>
        ⚠️ **어떤 함수**가 **자기가 속한 모듈의 함수나 데이터** 보다 **다른 모듈의 함수나 데이터**와 **상호작용 할일이 더 많을 때** 발생

        </aside>

        <aside>
        ⚠️ **디자인 패턴**중 **전략 패턴(Strategy Pattern)**과 **방문자 패턴(Visitor Pattern)** , 켄트 벡의 **자기 위임 (Self-Delegate)**같은 경우는 **이 규칙을 거스르는 패턴**이다

        </aside>

        <aside>
        ⚠️ **데이터와 이를 활용하는 동작은 함께 변경 해야 할 때가 많지만 예외의 경우에는 같은 데이터를 다루는 코드를 한 곳에서 변경 할 수 있도록 옮긴다**

        </aside>

        <aside>
        ⚠️ **전략 패턴**과 **방문자 패턴** 같은 경우는 **간접 호출이 늘어나**는 대신 **오버라이드할 소량의 동작 코드**를 **각각의 클래스로 격리**함으로써 **수정하기가 쉬워진다.**

        </aside>

        - 함수가 데이터와 가까이 있고 싶어 하는 의도를 발견 시

            [[함수 이동]]

        - 함수의 일부에서만 데이터와 가까이 있고 싶어 하는 의도를 발견 시

            [[함수 추출]]후 해당 데이터가 있는 모듈로 [[함수 이동]]

        - 함수가 사용하는 모듈이 많이 다양하게 발견 될 시

            가장 많은 데이터를 포함한 모듈로 [[함수 이동]]

            [[함수 추출]]로 함수를 여러조각으로 나눠 각각 적합한 모듈로 옮긴다.


    - 데이터 뭉치

        <aside>
        💡 *"데이터 항목들은 어린 아이 같은 면이 있다. 서로 어울려 노는 것을 좋아한다 ... 몰려 다니는 데이터 뭉치들은 보금자리를 따로 마련해줘야 마땅하다."*

        </aside>

        <aside>
        💡 *"만약 **기능 편애를 없애는 과정**에서 **새로운 클래스**를 만들었다면 이어서 그 **클래스를 옮기면 좋을 동작**은 없는지 살펴보자..."*

        </aside>

        - 필드 형태의 데이터 뭉치를 발견 시

            [[클래스 추출]]로 하나의 객체로 묶기

        - 메서드 시그니처에 있는 데이터 뭉치 발견 시

            [[매개변수 객체 만들기]] OR [[객체 통째로 넘기기]]를 적용해 매개 변수의 수를 줄여본다.

    - 기본형 집착

        <aside>
        💡 "***전화 번호**, **날짜**, **화폐**, **자표**, **특정 범위 값**처럼 단순히  집합으로만 표현하기에 아쉬운 것들이 많다. ...**기본형만이 거주하는 구석기 동굴**을 **의미 있는 자료형들이 사는 최신 온돌식 코드**로 **탈바꿈** 시켜 주어야 마땅하다. ...이들을 이용하여 반드시 문명사회로 이끌어 주자"*

        </aside>

        - 대표적인 방법은 [[기본형을 객체로 변경]]이다.
        - 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰인 것을 발견 시

            [[타입 코드를 서브클래스로 바꾸기]] → [[조건부 로직을 다형성으로 바꾸기]] 적용

        - 자주 몰려 다니는 기본형 발견 시

            [[클래스 추출]]하기 + [[매개변수 객체 만들기]]

    - 반복되는 switch

        <aside>
        ⚠️ *지금은 다형성이 널리 자리 잡아서 단순히 switch문을 썼다고 해서 자동으로 검토 대상은 되지 않는 세상이 되었다. ...이제는 **똑같은 조건부 로직(switch/case문이나 길게 나열된 if/else문)**이 **여러 곳에서 반복해 등장하는 코드에 집중**해보자. ... **중복된 switch문은 조건절을 추가할 때마다 모두 다같이 수정해야하기 때문**이다.... 이럴때 [[다형성]]을 사용해 반복된 switch문이 내뿜는 사악한 기운을 제압해야 한다.*

        </aside>

    - 반복문

        <aside>
        ⚠️ *"...지금은 **일급 함수(First - Class Function)**을 지원하는 언어가 많아 졌기 때문에 **[[반복문을 파이프라인화]]**를 적용해 시대에 걸맞지 않은 반복문을 제거 할 수 있다. ..."*

        </aside>

    - 성의 없는 요소
        - 본문 코드를 그대로 쓰는 것과 진배 없는 함수
        - 실질적으로 메서드가 하나 뿐인 클래스

            (상대적으로 있으나 마나한 함수, 클래스 등을 만난 경우)

            위의 두 가지 경우등을 만나게 되면 [[함수 인라인]]  OR [[클래스 인라인]]으로 처리

        - 상속을 사용했을 경우

            [[계층 합체]]를 적용

    - 추측성 일반화

        <aside>
        ⚠️ "... **'나중에 필요할거야'라는 생각**으로 **당장은 필요 없는 모든 종류의 후킹 포인트**와 **특이 케이스 처리 로직**을 작성해둔 코드... ...당장 필요 없는 코드는 눈앞에서 치워버리자 "

        </aside>

        <aside>
        ⚠️ *"추측성 일반화는 **테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스**에서 흔히 볼 수 있다. 이런 코드를 발견하면 **테스트 케이스부터 삭제**한 뒤 죽은 코드 제거로 날려버리자"*

        </aside>

        - 하는 일이 거의 없는 추상 클래스를 발견 시

            [[계층 합치기]]

        - 쓸데없이 위임하는 코드 발견 시

            [[함수 인라인]]하기 OR [[클래스 인라인]] 하기

        - 본문에서 사용되지 않는 매개변수 발견 시

            [[함수 선언 변경]]

    - 임시 필드
        - 특정 상황에서만 값이 설정되는 필드 발견 시

            [[클래스 추출]]

            이후 함수 이동으로 임시 필드와 관련된 코드를 모조리 새 클래스에 넣기

        - 임시 필드들이 유효한지 확인 한후 동작하는 조건부 로직 발견 시

            [[특이케이스 추가]]

            필드들이 유효하지 않을때를 의한 대안 클래스를 만들어서 제거

    - 메시지 체인

        getter가 꼬리와 꼬리를 물고 이어진 경우 발생

        (ex: const res = aPerson.department.manager.name;)

        위임 숨기기

        <aside>
        ⚠️ "...중간 객체들이 모두 중개자가 돼버리기 쉽다. 그러니 최종 결과 객체가어떻게 쓰이는지부터 살펴 보는 것이 좋다. ..."

        </aside>

        해결법

        1. [[함수 추출]]로 결과 객체를 사용하는 코드 일부를 따로 빼낸다.
        2. [[함수 이동]]으로 체인을 숨길 수 있는지 살펴보기
    - 중개자 (Middle Man)
        - 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임을 할 경우

            [[중개자 제거]]

            위임 메서드 제거후 남는 일이 거의 없다면 호출하는 쪽으로 [[함수 인라인]]

    - 내부자 거래
        - 모듈 사이에서 은밀히 데이터를 주고 받는 것을 발견 시

            함수 이동 + 필드 이동 → 사적으로 처리하는 부분 최소화

        - 여러 모듈이 관심사를 공유한다는 것을 발견시
            - 공통 부분을 정식으로 처리하는 제 3의 모듈을 새로 만들기
            - [[위임 숨기기]] → 다른 모듈이 중간자 역할을 하게끔 만들기
        - 상속 구조에서 자식 클래스가 부모클래스가 공개하고 싶은 것 이상으로 알고 싶어 할시

            [[서브클래스를 위임으로 변경]]OR [[슈퍼클래스를 위임으로 변경]]

    - 거대한 클래스

        <aside>
        ⚠️ *"**한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어난다. 그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다*."**

        </aside>

        - 필드가 너무 많은 클래스를 만날 시
            - [[클래스 추출]]

                필드들 일부를 따로 묶는다.

                - 종류
                    - 한 컴포넌트에 같이 둬야 할 것 같은 필드들
                    - 한 클래스 안에서 접두어나 접미어가 같은 필드들
            - 원래 클래스와 상속관계를 만드는게 좋다고 고려될 시

                [[슈퍼클래스 추출]] OR [[타입 코드를 서브클래스로 변경]](서브클래스 만들기)

        - 코드량이 너무 많은 클래스 만날 시
            - 코드 중복을 찾아 하나의 코드로 만들어주기 (함수 추출)

        <aside>
        ⚠️ *"**클라이언트들이 거대 클래스를 이용하는지 패턴을 파악**하여 그 클래스를 어떻게 쪼갤지 단서를 얻을 수 있다. ..."*

        </aside>

        파악 방법

        - 클라이언트들이 거대 클래스의 특정 기능 그룹만 주로 사용하는지 파악
        - 기능 그룹을 각각 파악했을시

            [[클래스 추출]], [[슈퍼클래스 추출]],  [[타입 코드를 서브클래스로 변경]]

            → 여러 클래스로 분리한다.

    - 서로 다른 인터페이스의 대안 클래스들
        - 클래스 사용시 다른 클래스로 교체하고 싶을때

            교체시에는 인터페이스를 일치 시켜야 한다.

            [[함수 선언 변경]] → 메서드 시그니처 일치

            - 이것만으로 부족할 시

                [[함수 이동]] → 일치 할때까지 필요한 동작들을 클래스 안으로 삽입

    - 데이터 클래스

        <aside>
        ⚠️ *"데이터 클래스가 public 필드에 있다면 누가 보기전에 얼른 숨겨야한다."*

        </aside>

        해결 방법

        [레코드 캡슐화](Refactoring%20c8e454eeee0546baae47cbfc3c9ecd73/%E1%84%85%E1%85%A6%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3(%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20result)%20%E1%84%8F%E1%85%A2%E1%86%B8%E1%84%89%E1%85%B2%E1%86%AF%E1%84%92%E1%85%AA%20e5b849dee36c4ee8a61d7670a72c95fb.md)

        - 변경하면 안되는 필드 발견시

            [[세터 제거]] → 접근 원천 봉쇄

        - 타 클래스에서 데이터 클래스의 get, set 사용하는 메서드를 발견 시

            [[함수 이동]] → 해당 메서드를 데이터 클래스로 이동

            if 통째로 옮기기 힘들다면 [[함수 추출]]로 가능한 영역만 뽑아 낸다.

        - 데이터 클래스에게 필요한 동작이 다른 곳에 정의된 것을 발견 시

            클라이언트 코드 → 데이터 클래스 내부 로 이동

            - 예외의 경우
                - 다른 함수를 호출해 얻은 결과 레코드(데이터 객체)에 동작 코드를 넣는 경우

                (ex: [[단계 분리]]의 결과로 나온 중간 데이터 구조, 보통 불변 데이터)

                (즉, 중간 데이터는 게터를 통하지 않고 그냥 public에 둬도 무방)

    - 상속 포기

        부모의 유산을 원치 않는 서브 클래스를 만난 경우 발생

        - 해결방법

            (일부 동작을 재활용하기 위해 상속을 활용한다면 굳이 할 필요 없음)

            1. 같은 계층에 서브 클래스 만들기
            2. 메서드 내리기+필드 내리기 → 물려받기 싫은 유산들을 전부 서브 클래스로 이동
            3. 부모클래스와 통일화 완료

        <aside>
        ⚠️ *"**상속 포기의 냄새**는 **서브 클래스가 부모의 동작은 필요**하지만 **인터페이스는 따르고 싶지 않을때** 특히 심하게 난다. ... **인터페이스를 따르지 않는 것은 상당히 무례**한 태도 이다. ... "*

        </aside>

        - 해결 방법

            [[서브클래스를 위임으로 변경]] OR [[슈퍼클래스를 위임으로 변경]]

            → 아예 상속 메커니즘에서 탈피

    - 주석

        <aside>
        ⚠️ *"... **주석은** 악취가 아닌 **향기**를 입힌다. **문제는** 주석을 **탈취제처럼 사용**하는 데에 있다. ...**주석이 많으면 온갖 악취를 풍기는 코드**가 나오기 쉽다. ... "*

        </aside>

        - 해결방법
            - 특정 코드 블록이 하는 일에 주석을 넣고 싶을 때

                [[함수 추출]]

            - 이미 추출된 함수임에도 설명이 필요할 때

                [[함수 선언 변경]] (함수의 이름을 의도를 명확하게 변경)

            - 시스템이 동작하기 위한 선행조건을 명시하고 싶을 때

                [[어서션 추가]](를 미리 대기시킴)

    - 프로그램 모듈화 하는 법
        - 코드를 여러 영역으로 나누기
        - 영역 안에서 이뤄지는 상호작용은 최대로 늘리기
        - 영역 사이에서 이뤄지는 상호작용은 최소로 줄이기
    - 위임 Delegate

        ```java
        public class MyStack{
            pivate ArrayList list = new ArrayList(); // 이것이 위임이다.
        		// 이 위임 자체를 보지 말고 현재 이 클래스를 어느 위치에서 사용할지 염두해야한다
        		// 만약 특정 메소드가 지나치게 여러 모듈에서 사용이 된다면
            // 중개자제거를 고려 해야한다.

            public void push(String element){
               list.add(element);
            }
            public String pop(){
               return list.remove(list.size()-1);
            }
            public boolean isEmpty(){
               return list.isEmpty();
            }
            public int size(){
               return list.size();
            }
        ```

    - 프록시 Proxy

        프록시란 다른 객체의 접근을 제어하기 위한 객체

        [https://getchan.github.io/cs/node_proxy/](https://getchan.github.io/cs/node_proxy/)

    - 타입 인스턴스 동형이의어 Type-Instance Homonym

        [https://martinfowler.com/bliki/TypeInstanceHomonym.html](https://martinfowler.com/bliki/TypeInstanceHomonym.html)

        <aside>
        ⚠️ "...'책(book)'이라는 단어는 여러 개념을 나타낼 수있는 용어입니다. 위의 두 문장은 '책'이 의미하는 두 가지 개념인 문학 작품과 실제 사본을 보여줍니다. 대부분의 독자는 프로그래머이기 때문에 프로그래밍 비유를 사용하여 '책'이라고하는 두 개의 별개 클래스가 있다고 말할 것입니다. LiteraryWork 및 PhysicalCopy 클래스로 참조하여 명확하게 할 수 있습니다. 첫 번째 문장에서 '전쟁과 평화'가 책이라고 말할 때 '전쟁과 평화'는 LiteraryWork 클래스의 예라고 말하는 것입니다. 두 번째 문장은 PhysicalCopy 인스턴스의 속성을 나타냅니다. ..."

        </aside>

        <aside>
        💬 근본적으로는 같지만 다른 존재인 예를 든 경우이다.

        </aside>

        <aside>
        ⚠️ **전쟁과 평화라는 '책'**과 **'책'의 커버**는 근본적으론 같은 의미이지만 존재 자체가 다르다 *"...책 (PhysicalCopy)에는 책 (LiteraryWork)의 렌더링이 포함되어 있습니다"*

        </aside>

        > "'War and Peace' is a wonderful book.
        "Let me see... pity this book has such a tattered cover"
        >

        > "Mary had a little lamb" means quite different things to a veterinarian than to a restaurateur.
        >

        <aside>
        💬 진짜 물리적인 자동차와 자동차의 이름, 배기량을 적은 타입

        </aside>

        <aside>
        💬 실제 감기 치료법을 적은 스크롤 사본들은 여러 개인데 막상 카탈로그 아이템은 한 개일때

        </aside>

        <aside>
        💬 클래스가 진짜(인스턴스)를 대변해주지 못할때

        </aside>

    - 기법 링크들

        [[함수 선언 변경]]

        [[변수 이름 변경]]

        [[필드 이름 변경]]

        [[함수 추출]]

        [[문장 슬라이드]]

        [[메서드 올리기]]

        [[임시 변수를 질의 함수로 변경]]

        [[매개 변수 객체 만들기]]

        [[객체 통째로 넘기기]]

        [[함수를 명령으로 변경]]

        [[조건문 분해하기]]

        [[조건문을 다형성으로 변경]]

        [[반복문 쪼개기]]

        [[매개 변수를 질의 함수로 바꾸기]]

        [[플래그 인수 제거하기]]

        [[여러 함수를 클래스로 묶기]]

        [[변수 캡슐화]]

        [[변수 쪼개기]]

        [[질의 함수와 변경 함수 분리하기]]

        [[세터 제거]]

        [[파생 변수를 질의 함수로 바꾸기]]

        [[여러 함수를 변환 함수로 묶기]]

        [[참조를 값으로 바꾸기]]

        [[단계 분리]]

        [[함수 이동]]

        [[클래스 추출]]

        [[필드 이동]]

        [[함수 인라인화]]

        [[클래스 인라인화]]

        [[기본형을 객체로 변경]]

        [[반복문 파이프라인화]]

        [[계층 합체]]

        [[죽은 코드 제거]]

        [[특이 케이스 추가]]

        [[위임 숨기기]]

        [[중개자 제거]]

        [[필드 올리기]]

        [[메서드 내리기]]

        [[조건문 통합하기]]

        [[중첩 조건문을 보호 구문으로 변경]]

        [[생성자를 팩터리 함수로 변경]]

        [[타입 코드를 서브 클래스로 변경]]

        [[서브클래스를 위임으로 변경]]

        [[슈퍼클래스를 위임으로 변경]]

        [[슈퍼클래스 추출]]

        [레코드(함수 result) 캡슐화](Refactoring%20c8e454eeee0546baae47cbfc3c9ecd73/%E1%84%85%E1%85%A6%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3(%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20result)%20%E1%84%8F%E1%85%A2%E1%86%B8%E1%84%89%E1%85%B2%E1%86%AF%E1%84%92%E1%85%AA%20e5b849dee36c4ee8a61d7670a72c95fb.md)

        [[어셔션 추가]]

        [[인라인 코드를 함수 호출로 변경]]

        [[함수 매개변수화]]

        [[변수 인라인화]]

        [[알고리즘 교체]]

        [[문장을 호출부로 이동]]

        [[매직 리터럴 변경]]

        [[변수 추출]]

        [[문장을 함수로 이동]]

        [[컬렉션 캡슐화]]

        [[값을 참조로 변경]]

        [[제어 플래그를 탈출문으로 변경]]

        [[질의 함수를 매개 변수로 바꾸기]]

        [[명령을 함수로 변경]]

        [[수정된 값 반환]]

        [[오류 코드를 예외로 변경]]

        [[예외를 사전확인으로 변경]]

        [[생성자 본문 올리기]]

        [[서브클래스 제거]]

- 참고사항
    - 마틴 파울러의 리펙터링 전체 내용을 옮긴 페이지 입니다.
    - 일부 기법에는 상세 설명이 없는 경우도 많습니다.
    - 오탈자나 수정사항 발견시 알려주시면 감사하겠습니다.
