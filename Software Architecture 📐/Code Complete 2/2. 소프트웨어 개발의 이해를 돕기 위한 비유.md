
> 컴퓨터공학에는 그 어떤 공학보다 비유를 자주 사용한다.

+ 설명
	+ 트로이 목마, 웜, 버그, bomb, crash, flame,  twisted sex changers, fatal error등 다양하다
	+ 여러 현상과 매일 사용하는 용어들 까지도 비유를 들어 사용한다.
	+ 뛰어난 비유 표현은 구현에 꼭 필요하진 않지만 개발에 대해 명확히 알기 위해서는 필요한 과정이다.

<br>

## 비유의 중요성

> 일반적으로 어설프게 아는 분야를 알기 위해 더 잘아는 비슷한 분야와 비교해 이해함으로써 덜 친숙한 도메인에대해 이해하곤 한다.
> 
> 우리는 이것을 모델링이라고 부른다.

+ 설명
	+ 모델
		+ 장점
			+ 생생하고 전체 개념의 윤곽을 잡을 수 있다.
			+ 특성, 관계, 연구할 영역까지 제시해준다.
		+ 단점
			+ 지나치게 확대해석하여 연구하는 경우가 종종 존재한다.
		+ 핵심 사항
			+ 좋은 비유는 좋은 모델을 이끌어내지만 잘못된 관점으로 접근한 비유는 잘못된 해석을 낳는다.
	+ 예시
		+ 아리스토텔레스 학설의 신봉자들의 관점과 갈릴레오의 진자 모델 관점
		+ 바크만은 1973년에 컴퓨터 중심적인 관점에서 변화된 사람들의 데이터 중심적인 관점을 비교함
			+ 옛날에는 사람들이 모든 데이터를 연속적으로 컴퓨터를 통과하는 카드로 보려고 했었다.(패턴(도메인) 특성에 따라 분류가 가능하고 저장이 가능함에도 불구하고 데이터를 제대로 바라보지 않음)
		
		즉, 현재도 오래된 잘못된 모델링을 믿고 있을 수도 있으며 한번 이 모델링을 버리면 이것을 믿고 있었다는 사실조차 믿기 어렵다.
		
		**결론적으로 모델링의 힘은 대단하다.**
		
		다만 과학의 역사에서 역대 모델링들은 가장 정확하다고 유추만 할 뿐, 확정지어진것은 없다.
		
		거기에 소프트웨어 개발의 역사는 어느 과학분야들보다 매우 짧다. 
		
		따라서 제대로 된 비유나 모델이 생각보다 많지 않으며 소프트웨어 공학 역사에서도 끊임 없는 학파들간의 논쟁이 끊이질 않고 있다.
		
		따라서 좋은 비유, 좋은 모델을 잘 이해하는 것이 곧 소프트웨어 개발을 얼마나 잘 이해하는지 결정한다.

<br>

## 소프트웨어 비유 사용법

> 소프트웨어의 비유는 지도가 아닌 탐조등이다.

+ 설명
	+ 대부분의 알고리즘은 결정적이며 예상가능하다. A에서 B를 가는 방법을 곧바로 알려준다.
	+ 발견적 학습은 이와 약간 다른데 답을 찾는데 도움만 주는 기법이다. 무엇을 찾는지가 아닌 어떻게 찾는지를 말해준다. 따라서 결과가 쉽게 뒤바뀐다.
		+ 예를 들면 A에서 B를 가기위해서 A에서 주변에 물어보니 C를 가보라 하여 C를 들릴 수도 있는 것이다.
	+ 알고리즘은 직접 방법을 알려주며 발견적 학습은 그 방법을 스스로 찾는 방법을 알려주든지 적어도 어디서 찾을 수 있는지 말해준다.
	+ 프로그래밍 문제는 단순 알고리즘과 같지 않다. **문제를 개념화 하는 것이 가장 어려운 분야이며 가장 많은 오류가 개념적인 오류이다.**
	+ 프로그램은 저마다 개념적으로 고유하기 때문에 모든 경우에 대한 해결책을 얻을 수 있는 일반적인 방법을 만들기는 어렵거나 아예 불가능하다.
	+ 따라서 **일반적으로 문제에 다가가는 방법을 아는 것이 특정 문제에 대한 구체적 해결책을 아는 것 만큼이나 유용하다**.(난 이것이 요즘 코테 신드롬의 핵심 신념이 아닐까 한다.)

+ 결론
	+ 소프트웨어 비유는 프로그래밍 문제와 프로세스를 이해하는데 사용해야한다.

<br>

## 일반적인 소프트웨어 비유                                                                                                                                      
> 소프트웨어 개발에 대한 비유는 굉장히 다양하다.

+ 설명
	+ 데이비드 그리스는 과학, 도널드 커누스는 예술, 와츠 험프리는 프로세스, P. J 플로거와 켄트 벡은 운전, 알리스터에 콕번은 게임, 에릭 레이먼드는 시장, 앤디 헌트와 데이브 토마스는 원예, 폴 헤켈은 백설공주 영화를 찍기, 프레드 브룩스는 농사 또는 늑대인간 사냥 또는 타르 구덩이에 공룡과 함께 빠진것과 같다고 말했다.

&emsp;&emsp;
### 소프트웨어 글 쓰기: 코드 작성

> 소프트웨어 개발에 대한 가장 기초적인 비유는 코드 작성하기로부터 시작한다.

+ 설명
	+ 마치 편지 쓰기와 같다.
	+ 개발자들은 종종 프로그램 가독성에 대해 이야기한다.
	+ 개인작업, 소규모 프로젝트인 경우 편지 쓰기 비유가 적절하다 하지만 좀 더 큰 규모에서는 설명이 어려운 비유이다.
	+ 편지는 다쓰면 변경도 안되고 그냥 끝이다. 허나 소프트웨어는 전혀 그렇지 않다.
	+ 글쓰기는 독창성이 중요하지만 소프트웨어 구현은 이전 프로젝트의 경험, 테스트 케이스를 사용하는데 초점을 맞춰야 효과적이다.
	+ 그러나 어마어마한 비용을 들인 소프트웨어 작성에서는 글쓰기 처럼 한번 쓰고 아니면 버리는 식의 개발은 어렵다.
	+ 거기에 요즘은 작은 코드조각이라도 깃허브에 이쁘게 포장해서 패키징하는것을 좀 더 중요하게 보는 시대이다.


<br>

### 소프트웨어 농사: 시스템 키우기

> 어떤 소프트웨어 개발자들은 소프트웨어 구축을 씨를 심고 곡물을 기르는 것에 비유해야 한다고 말한다.

+ 설명
	+ 이는 조금씩 설계하고 코드를 작성하고 테스트를 해 문제가 발생할 여지를 최소화한다는 개념이다.
	+ 그러나 이는 소프트웨어 개발 방법을 직접 통제하지 못한다는 사실을 암시한다. 봄에 코드를 심고 가을에 풍작을 거둘 것인가? 이는 모르는 일이다.
	+ C++로 돌려짓기를 하고 하드디스크에 질소 비료를 늘리기 위해 땅을 놀려야한다는 식의 표현으로 대체한다면 이는 그닥 괜찮은 비유가 아닌 것을 금방 알 수 있다.


<br>

### 소프트웨어 조개 양식: 시스템 증대

> 소프트웨어 증대는 점진적으로 천천히 외부에서 첨가하거나 포함해 규모가 증가하거나 자라는 것이다.

+ 설명
	+ 특히 물에 침전물이 쌓여 땅에 천천히 더해지는 것을 의미한다.
	+ '점진적'으로 설계, 구축, 테스트하는 것이 활용 가능한 소프트웨어 개발 개념중 가장 강력한 표현이다.
	
	+ 점진적 개발 방법
		1. 실행할 시스템을 가장 간단한 버전으로 만든다.
		2. 실제 입력을 받을 필요도 없고 데이터 처리도 필요 없고 실체 출력을 할 필요도 없다. 단지, 식별된 기본 함수마다 더미클래스를 호출한다. 이것이 골격이다.
		3. 근육과 피부에 해당하는 실제 로직을 조금씩 집어넣어 실질적인 클래스로 바꿔야한다.
		   입력을 받는 척하는 대신 실제 입력을 받아들이는 코드를 넣는다. 프로그램이 출력하는 척하는 대신 실제 출력을 내는 코드를 넣는다. 
		4. 완전히 작동하는 시스템이 될때까지 한번에 조금씩 코드를 덧붙인다.
	
	+ **위의 점진적 개발 방법은 현재 존재하는 모든 소프트웨어 개발 방법론의 근간이다.**
	+ 농사보다 굴이 진주를 만드는 그림이 시각화하기 좋다.


<br>

### 소프트웨어 건설: 소프트웨어 구축

> 소프트웨어를 빌드(건설)하는 이미지는 소프트웨어 쓰기나 기르기 이미지 보다 더 유용하다.

+ 설명
	+ 소프트웨어 구축에는 무엇인지에 따라 종류와 정도가 다른 여러 단계의 계획 수립과 준비, 실행이 수반된다.
	+ 1.2미터 탑쌓기와 120미터 탑쌓기는 아예 다른 계획과 구현이 필요한 것이 당연하다.
	+ 개집을 짓는 것과 사람이 사는 집짓기도 마찬가지다. 좀 더 복잡한 설계도도 필요하고 애초에 어떻게 살 집인지 용도 먼저 구분해야한다.
	
	+ 예시
		1. 어떤 종류의 집을 짓고 싶은지 결정해야한다. (소프트웨어 개발에서의 문제 정의)
		2. 건축가든 개발자든 일반적인 설계를 하고 승인을 받아야한다. (소프트웨어 아키텍처 설계)
		3. 청사진을 가지고 건설업체를 고용한다. (상세 소프트웨어 설계)
		4. 건물의 부지를 준비하고 기초 공사를 하고 집의 골격을 세우고 벽과 지붕을 올리고 배관과 전기 공사 를 한다. (소프트웨어 구현)
		5. 거의 완성이 되면 정원사, 도장공, 도배업자를 부른다. (소프트웨어 최적화)
		6. 작업이 진행되는 동안 감독관이 부지와 기초 공사, 골조, 배선을 비롯해 여러 점검 사항을 확인한다.(소프트웨어 검토 및 정밀 검사)
	
	+ **일반적으로 인건비가 가장 큰 지출이다. **
	  벽을 옮기는 데 돈이 많이 드는 이유는 벽을 옮기는 데 걸리는 추가 시간에 대한 임금을 지급해야하기 때문이다.
		+ 즉, 애초에 피할 수 있는 실수는 최대한 피하도록 잘 설계해야한다.
		+ 소프트웨어 구축은 재료는 싸지만 인건비는 더욱 비싸다.
	+ **인테리어는 기성품을 사는게 정상적이다. 일반적으로 이미 만들어져 있어 살 수 있는 것을 코드로 작성하는 것은 무의미하기 때문이다.** 이는 미리 만들어진 클래스들과 패키지, 라이브러리들에 해당한다.
		+ 물론 최고급의 요구사항이 들어오면 모든 것을 주문제작 해야하긴 할 것이다.
			+ 더 나은 속도와 정확성을 위해 과학함수도 직접 만들고 시스템의 모양과 기능을 완벽하게 일관성 있게 보이게 하려고 컨테이너 클래스와 사용자 인터페이스, 데이터베이스 클래스를 직접 작성해야할 것이다.
	+ **적당한 수준으로 계획을 수립하면 건물을 지을 때나 소프트웨어를 구현할 때 모두에게 이득을 준다.**
		+ 다만 잘못된 순서로 구축을 한다면 코드 작성 후 테스트를 하고 디버깅하기 어렵다.
		+ 즉 좋은 순서로 구축하지 않는다면 프로젝트 전체가 엉망이 된다.
	+ **신중한 계획은 철저하거나 과도한 계획을 의미하지 않는다.**
		+ 상세한 내부 설계 계획은 나중에 하는게 맞다.
			+ 인테리어는 무엇이 이쁠지는 어느정도 구축을 하고 나서 직접 가서 하나씩 대봐야 아는 것이기 때문에 이건 최대한 나중으로 미루는게 최선인 것이다.
		+ 잘 계획된 프로젝트일 수록 나중에 변경이 가능하게 만들고, 경험이 많을수록 상세 사항에 대해서는 우선 소홀하게 대하는 것이 당연하다.
			+ 처음부터 까다롭게 만들면 시간과 예산이 부족해 나중에는 큰문제가 된다.
	+ 건설 비유는 서로 다른 개발 접근 방법이 서로 다른 소프트웨어 프로젝트에 왜 이득을 주는지 설명하는 데도 도움을 준다.
		+ 건물의 경우 창고를 지을 때, 의료 센터를 지을 때, 금융 건물을 지을 때, 원자로를 지을 때 서로 다른 수준의 계획, 설계, 품질 보증을 하용한다.
			+ 건물을 짓는 방식도 다 다를 것이다.
		+ 일반적으로는 유연하고 가벼운 소프트웨어 접근 방법을 사용하겠지만 때때로 안정성 목표와 다른 목표를 달성하기 위해 엄격하고 무거운 접근 방법도 필요하다.
	+ 소프트웨어의 변경은 건축 공사과 공통점이 존재한다.
		+ 벽을 옮기는 작업또한 얇은 벽을 옮기는 일보다 내력벽을 부수고 새로 옮기는 작업이 매우 힘들다.
			+ 따라서 프로그램 또한 몇 몇 상세 기능을 수정하는 것보다 큰 토대를 수정하는 일이 매우 힘들다.
	+ 건설 유추는 큰 소프트웨어를 이해하는데 도움을 준다.
		+ 매우 큰 건물을 짓는데 실패하면 이에 투자된 시간과 돈이 어마어마한 손해로 돌아오는 것과 동일하게 소프트웨어 프로젝트 또한 마찬가지이다.
		+ 큰 프로젝트 일수록 건축업자는 계획을 신중히 세우고 검사해야하며 안정성을 중요하게 생각해야한다.
		+ 고층 건물이 무너지는 것보다 튼튼한 자제를 10프로 가격을 더 지불하고 사오는 것이 더 낫다.
		+ **그리고 시간이 가장 중요하다.**
	+ 매우큰 소프트웨어 프로젝트에서는 큰 프로젝트보다 더 신중하고 세밀한 계획이 필요하다.
		+ 100만줄 짜리 프로젝트에는 평균적으로 69가지 종류의 문서가 필요하다고 보고 했다.
		+ 이런 시스템의 요구사항 명세는 4,5천 페이지 정도이며 설계문서는 이에 2배로 봐야한다.
		+ 이런 프로젝트에 대한 완전한 설계는 개인이 이해하는 것은 물론 읽는 것도 불가능해 보인다.

<br>

### 소프트웨어 기법의 적용: 지적 도구 상자

+ 설명
	+ 고급 소프트웨어를 효과적으로 개발하는 사람들이 수많은 기법과 트릭, 노하우를 축적하는 데에 수년은 걸린다.
		+ **기법은 법칙이 아닌 분석 도구이다.**
		+ 훌륭한 장인은 일에 맞는 도구를 꺼내서 제대로 사용하는 방법을 아는 사람들이다.
			+ 이는 개발자도 똑같다.
		+ 프로그래밍에 대해 많은 것을 배울 수록 머릿속의 도구 상자는 더 많은 분석 도구로 가득 차고 언제 그것들을 사용할지, 어떻게 사용하는지에 대한 지식들로 채워진다.
	+ 소프트웨어에서 컨설턴트는 다른 방법은 배제하고 특정 소프트웨어 방법만을 받아들이라고 하는데 이는 매우 위험하고 안타까운 일이다.
		+ 어느 방법론을 한가지만을 받아들인다면 다른 관점은 보이지가 않을 것이기 때문이다.
		+ 어던 경우에는 현재 문제에 더 적합한 방법이 있음에도 불구하고 그 방법을 사용할 기회를 날리는 것이다.
		+ 도구 상자 비유는 모든 방법과 기법, 팁을 언제든 사용가능 하도록 균형 잡힌 시각을 유지하는 데 도움을 준다.


<br>


### 비유 결합

+ 설명
	+ 비유는 알고리즘적이기보다 발견적이기 때문에 상호 베타적이지 않다.
		+ 예시로 증대 비유와 건축 비유는 동시에 사용가능하니 말이다.
		+ 원한다면 쓰기 비유를 사용할 수 있고 쓰기 비유를 다른 비유와 함께 써도 좋다.
		+ 생각을 자극하거나 팀원들과의 원할한 의사소통을 위해서 하나의 비유를 사용해도 좋고 조합해서 써도 좋다.
	+ 비유를 사용하는 것은 모호한 일이다.
		+ 비유를 통해 발견적 학습에 근간을 둔 통찰력을 얻기 위해서는 개념을 확장해야 한다.
		+ 비유를 지나치게 확장하거나 잘못된 방향으로 확장하면 큰일날 수도 있지만 그래도 알아둘 충분한 가치가 있다.


<br>


## 요점 정리

+ 비유는 알고리즘이 아닌 발견적 학습이라 다소 엉성한 경향이 있다.
+ 비유는 소프트웨어 개발 프로세스를 이미 알고 있는 다른 활동과 관련 지음으로써 그것을 이애하는데 도움을 준다.
+ 어떤 비유는 다른 비유보다 더 낫다.
+ 소프트웨어 구현을 건축 공사와 비슷하게 취급하면 신중한 준비 과정이 필요하다는 것을 알려주고 크고 작은 프로젝트 사이의 차이점을 보여준다.
+ 소프트웨어 개발 실천법을 지적 도구 상제에 있는 도구로 생각하면 모든 개발자가 많은 도구를 가지고 있으며 하나의 도구로 모든 일을 처리할 수 없다는 것을 알려준다. 문제마다 그에 맞는 도구를 선택해서 사용하는 것이 장인 개발자가 되는 비결이다.
+ 비유는 상호 베타적이지 않아 상황에 맞게 비유를 조합해서 사용해야한다.