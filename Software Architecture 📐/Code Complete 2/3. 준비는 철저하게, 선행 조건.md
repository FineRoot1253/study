
> 공사를 시작하는 전, 건축가는 설계도를 검토하고 모든 허가를 받았는지 확인하고 집의 지반을 조사한다.
> 
> 건축가는 고층 빌딩을 지을 때와 주택을 지을 때, 강아지 집을 지을 때 각각 다른 방법을 준비한다.
> 
> 프로젝트가 무엇이든지 준비 작업은 프로젝트 구체적인 요구사항에 맞춰 구현을 시작하기 전에 자세히 진행된다.

+ 설명
	+ 이 작업은 필수 작업은 아니다.
		+ 프로젝트의 성공은 구현을 시작하기 전에 결정되는 경우가 대다수이다.
		+ **기초공사가 그지같거나 계획을 잘못 새운 경우 구현과정에서 할 수 있는 최선의 행동은 손해를 최소화하는 것이다.**
	+ 최악의 소프트웨어 프로젝트는 구현작업을 두 번, 세 번 계속 반복을 하는 것이다.
		+ 프로젝트에서 가장 돈이 많이 드는 작업을 두 번이상 하면 안된다.
	+ 구현에 대한 실질적인 도움은 5장부터 시작한다.


<br>


# 선행 조건의 중요성

> 품질이 좋은 소프트웨어를 개발하는 개발자는 보통 자신만의 고급 실천법(컨벤션)이 존재한다.
> 
> 이런 실천법은 프로젝트 시작과 중간, 끝 단계에서 품질을 중요시 한다.


+ 설명
	+ 프로젝트 시기별 테스트 특징
		+ 프로젝트 마무리 단계
			+ 시스템 테스트(통합 테스트)에 중점을 둔다.
				+ 테스트는 품질 보증 전략의 일부일 뿐 영향력이 있는 부분이 아니다.
				+ **테스트는 엉뚱한 제품을 개발하거나 원하는 제품을 잘못된 방법으로 구현한 경우를 발견해내지 못한다.**
				+ 그러므로 구현 전에 수행을 해야한다.
		+ 프로젝트 중간 단계
			+ 구현 방법에 역점을 둔다.
				+ 이 책의 대부분의 내용이다.
			+ 구현 작업은 이 단계에서 이뤄지며 이미 소프트웨어 성패를 가르는 기초 작업이 어느정도 진행된 상태이다.
				+ **구현하는 동안 적어도 현재 상황이 어떤지 판단이 가능해야하며 실패의 먹구름이 보이면 작업을 되돌려야한다.**
		+ 프로젝트 시작 단계
			+ 고급 제품을 계획하고 요구사항을 수집해 설계한다.
			+ 설계가 쓰래기 같은 상태에서 아무리 많은 테스트를 투자해도 이쁜 쓰래기밖에 되지 않는다.
				+ 이쁜 소프트웨어를 개발하고 싶다면 시작부터 설계를 이쁘게 가져가야 한다.
					+ **소프트웨어 개발에서도 문제를 정의할 때, 해결책을 명시할 때, 그리고 해결책을 설계할 때 이쁜 계획을 세워야한다.**


<br>

## 선행 조건이 최신 소프트웨어 프로젝트에 적용 가능한지?

+ 설명
	+ 아키텍처, 설계, 프로젝트 계획 수립과 같은 선행 작업이 최신 소프트웨어 프로젝트에 전혀 도움이 안된다고 주장하는 사람들도 있다.
		+ 대부분 요즘 수행되는 연구에서도 타당성을 갖지는 못한다.
		+ 선행 작업은 잘 수행할 수 있고 구현 전에 준비하는 경우 가장 프로젝트를 훌륭하게 진행할 수 있다는 점이 중요하다.
	+ 준비 작업의 핵심 목표는 위험 축소이다.
		+ 훌륭한 기획자는 프로젝트 기획시 초기에 위험요소를 제거한다.
		+ **소프트웨어 개발에서 가장 흔히 발생하는 위험요소는 단연코 불충분한 요구사항과 잘못된 프로젝트 계획이다.**
		+ 그러므로 선행 조건도 요구사항과 프로젝트 계획을 향상시키는 데 중점을 두는 경향이 있다.
	+ 구현을 위한 준비 과학은 엄밀히 말하면 과학은 아니며 위험 절감을 위한 구체적인 접근 방법은 프로젝트에 따라서 결정해야 한다.


<br>


## 불완전한 준비의 원인

> 모든 전문적인 개발자는 준비 작업의 중요성을 알고 있고 구현 단계를 진행하기 전에 선행 조건들이 만족하였는지 확인한다고 생각하겠지만 안타깝게도 그렇지 않다.

+ 설명
	+ **불완전한 준비의 일반적인 원인은 선행 작업에 투입되는 개발자가 자신의 작업을 수행할 수 있을 정도의 전문가적인 지식을 갖고 있지 않다는 점이다.**
		+ 프로젝트를 계획하고 강력한 경영 사례를 만들고 포괄적이고 정확한 요구사항을 개발하고 훌륭한 아키텍처를 만드는 데 필요한 기술은 매우 중요하지만, **대부분의 개발자는 그러한 활동이 어떻게 수행할 것인지에 대한 교육을 받은 적이 없다.**
			+ 선행작업을 어떻게 수행하는지도 모르는데 선행 작업을 더 많이 수행하라고 권할 수도 없다.
	+ 선행 작업 수행 방법은 알지만 코드 작성에 급급하여 넘어가는 개발자도 많다.
		+ 이런 개발자에게 제안을 한다면 두가지가 존재한다.
			+ 다음 절에 소개하는 이야기를 들어본다.
			+ 자신이 겪었던 문제를 떠올려본다.
		+ 결국 커다란 프로그램 몇 개면 미리 계획하는 것만으로 많은 스트레스를 덜어낼 수 있다는 교훈을 얻을 것이다.
		+ 경험으로부터 교훈을 얻어야 한다.
	+ 관리자들이 선행조건을 수행하는 것에 시간을 투자하는 것을 아니꼽게 보기 때문이다.
	+ 예전에 이 저자는 국방성에서 일할 당시 장군이 사무실로 찾아와 코딩을 하는 사람을 찾으려 노력하다 화를 낸적이 있다고 한다. (왜 이 사무실에는 시킨 일을 시작한 사람이 아무도 없는건가!)
		+ 그래서 사무실 내 한 엔지니어는 본격적인 프로젝트 작업물과는 상관없이 준비작업으로 문서 형식화 유틸리티 툴을 만들고 있었지만 그것을 보여주고 이것이 코드라고 둘러댄 경험이 있다고 한다.
		+ 이런 상황 대면시 해결 방법
			+ 효과적이지 않은 순서로 작업은 불가능하다고 단호하게 거절하기
				+ 이 방법은 어지간히 상사와 관계가 좋거나 직장에 잘려도 다시 직장을 구할 때까지 통장 잔고가 넉넉해야 할 것이다.
			+ 코드를 작성하는 '척' 하기
				+ 이전에 만든 한 프로그램의 코드를 책상 한 켠에 둔 다음 상사의 허락 여부와 상관없이 요구사항과 아키텍쳐를 개발하면 된다.
				+ 이런 방법이 도덕적으로 옳지는 않다고 할지언정 프로젝트를 더 빨리 수행하고 더 우수한 제품이 나올 가능성이 높다.
			+ 상사에게 기술 프로젝트의 미묘한 차이에 대해 가르쳐주기
				+ 세상에 깨우친 관리자 수를 늘리는 좋은 접근 방법이다.
				+ 꼭 구현 전에 선행 작업을 진행해야하는 이유의 가장 중요한 이유이기도 하다.
			+ 다른 직장 구하기
				+ 경제 상황이 오르락내리락 하긴 하지만 좋은 개발자들은 항상 부족하고 좋은 대안들이 많이 있지만 좋지 않은 환경에서 작업하기에는 인생이 너무 짧지 않은가?


<br>

## 구현 전에 선행 조건을 수행하기 위한 필수적인 논의

> 묹제 정의라는 산에 오르고 난 뒤 요구사항이라는 사람과 1마일을 걷고 아키텍처라는 분수에서 때묻은 옷을 벗고 준비라는 깨끗한 물에서 목욕을 했다고 생각해보자.
> 
> 그러면 시스테을 구현하기 전에 시스템이 수행해야 하는 일이 무엇이며 어떻게 수행할 것인지 이해해야 한다는 것을 알게 될 것이다.

+ 설명
	+ 기술자가 해야하는 일
		+ 직장 내 비기술자에게 개발 프로세스에 대해서 교육하는 것
			+ 특히 아직 눈을 뜨지 못한 관리자와 상사를 상대하는 것
		+ 코드 작성과 테스트, 디버깅을 시작하기 전에 요구사항 분석 및 아키텍처 설계(매우 중요한 권리)에 대해서 상사와 논쟁하는 것
			+ 이후 상사와 함께 앉아 프로그래밍 프로세스에 대해서 허심탄회하게 얘기를 나눠보자

&emsp;&emsp;

### 논리적 설득

+ 설명
	+ 효과적인 프로그래밍 핵심 개념 중 하나로 준비 작업의 중요성을 들 수 있다.
		+ 관리 측면에서 볼 때 계획 수립은 프로젝트에 필요한 시간, 인력, 장비의 수를 결정하는 작업이다.
		+ 기술적인 측면에서 보면 계획 수립은 돈낭비 없이 자신이 만들고자 하는 것의 목표를 정확히 이해하는 것이다.
		+ 특히 사용자는 처음에 본인이 원하는 것이 무엇인지 알지 못하는 경우가 있어 진정 원하는 것이 무엇인지 알아내기 위해 생각보다 많은 노력을 부어야한다.
		+ 그래도 잘못된 프로그램을 만들어 폐기하고 처음부터 다시 만드는 것보다 비용이 적다.
	+ 시스템도 실제로 구축하기 전에 어떻게 구축할 것인지 생각해보는 것이 중요하다.
		+ 돈을 낭비하고 싶지 않다는 포인트는 관리자에게 꼭 필요한 필수 요소이다.

&emsp;&emsp;

### 비유적 설득

+ 설명
	+ 소프트웨어 시스템을 구축하는 것은 인력과 돈이 필요한 다른 프로젝트와 동일하게 계획 수립은 중요하다.
	+ 대표적인 비유
		+ 나무를 심지도 않고 크리스마스 트리를 꾸밀수는 없다.
		+ 연통을 열기도 전에 불을 지필 수는 없다.
		+ 휘발유 없이 긴 여행을 갈수도 없다.
		+ 목욕을 끝내기 전에 옷을 입을 수 없다.
	+ 개발자는 소프으웨어 먹이 사슬의 최종 소비자이다.
		+ 아키텍트는 요구사항을 먹고 설계자는 아키텍처를 먹고 코더는 설계를 먹는다.
		+ 먹이 사슬을 자연의 먹이사슬로 비유해보자
			+ 생태학적으로 좋은 먹이를 먹은 먹이를 먹어야 건강하게 개발 할수 있는 것이다.
			+ 오염된 먹이를 먹은 먹이를 먹으면 결과적으로 구현도 오염된다.
			+ 흔히 비유하는 윗물이 맑아야 아랫물도 맑다는 이야기이다.
	+ 반복적인 프로젝트를 계획하고 있다면(애자일) 구현 시작전 구현해야하는 각 부분에 핵심 요구사항과 아키텍쳐 요소를 규명해야한다.
		+ 집을 짓기전 모든 인테리어 사항을 알 필요는 없지만 적어도 기본적인 청사진 정도는 존재해야한다는 뜻이다.

&emsp;&emsp;

### 데이터에 근거한 설득

+ 설명
	+ 지난 25년간 연구결과에서 확실하게 증명된 사실은 처음부터 작업을 제대로 수행해야한다는 것이다.
		+ 이것이 최대한 적은 비용으로 성공적으로 개발하는 비법이다.
	+ 휴렛팩커드와 휴즈 항공, TRW를 비롯한 여러 기관의 연구원들은 구현 초기 단계에서 결함을 제거하면 제품 배포 후나 시스템 테스트 단계에서 제거하는 것보다 1/10 ~ 1/100정도 비용을 줄일 수 있다는 사실을 깨달았다.
	+ 일반적인 원칙은 결함을 최대한 빠르게 찾아내는 것이다.
		+ 결함은 똥과 같아서 소프트웨어 먹이 사슬에 오래 머물 수록, 사슬 아래로 내려갈 수록 피해는 점점 커진다.
	+ 대부분의 프로젝트는 여전히 시스템 테스트 단계에서 대부분의 결함을 수정하려 애쓰는데 이 작업에 무려 기능 구현 기간의 50프로를 투자한다.

&emsp;&emsp;

### 상사의 준비성 테스트

+ 설명
	+ 상사가 눈을 떳다고 생각될 때쯤 해볼 질문 리스트 (이중 자기만족을 위해 하는 말은?)
		+ 디버깅할 것이 많기 때문에 당장 코드를 작성하는 것이 낫다.
		+ 결함이 많이 발견되지 않을 것이므로 테스트에 많은 시간을 할애하지 않았다.
		+ 요구사항과 설계에 충분히 신중을 기했으니 코딩과 디버깅을 수행할 때 중요한 문제점이 발견되지 않을 것이다.
	+ 위의 모든 문장은 자기 만족을 위한 것이지만 마지막 문장을 목표로 삼아야한다.


<br>


# 작업 중인 소프트웨어의 종류 결정

> 소프트웨어 프로젝트 종류가 다르면 선행 작업과 구현 사이의 비율도 달라져야한다.
> 
> 프로젝트는 저마다 고유하지만 모든 프로젝트는 일반적인 개발 형태로 나뉘는 경향이 있다.


+ 소프트웨어의 종류

![[소프트웨어의_종류_(3).loom]]

&emsp;&emsp;

+ 설명
	+ 이 표는 일반적인 사항에 대해서만 설명하고 있다.


&emsp;&emsp;

## 선행 조건에서 반복적인 접근 방법이 갖는 효과

+ 설명
	+ 점진적 방법론을 사용하는 프로젝트는 선행조건을 중점적으로 다룰 필요가 없다고 주장하는 사람도 있지만 그 관점은 잘못된 것이다.
		+ 처음부터 잘못된 선행작업의 영향을 줄여줄 수는 있지만 완전히 제거해주지는 못한다.
		+ 어떤 선행 작업을 하지 않고 방법론만이 다른 두 프로젝트를 진행하는 경우
			+ 차이점
				1. 결함 발생 후 상대적으로 결함이 빨리 발견되어 평균 결함 수정비용이 더 적음
				2. 반복적인 접근 방법론에서의 비용은 전체 프로젝트 과정에 조금씩 흡수된다.
		+ 어떤 선행조건을 다루며 방법론만이 다른 두 프로젝트를 진행하는 경우
			+ 차이점
				1. 위의 경우와 동일하다. 그러나 전체적으로 더 많은 비용을 감소시켜준다.
		+ 필수 요구사항과 설계상 요소를 초기에 정의하는 것은 대부분 프로젝트에서 도움이 된다.
		+ 경험상 추천하는 방법
			+ 요구사항 중 80프로 정도를 미리 명시하고 추가적으로 기술할 시간을 할당한 다음, 프로젝트를 진행하면서 가장 중요하다고 생가고디는 새로운 요구사항들만 수용할 수 있도록 실제 구조 변화를 꾀하는 것
			+ 요구사항의 20프로 정도를 미리 명시하고 다름 프로젝트를 진행해 나가면서 추가석인 요구사항과 설계를 기술하는 것

&emsp;&emsp;

## 반복적인 접근 방법과 순차적인 접근 방법의 선택

+ 설명
	+ 어떤 선행 조건들을 충족하는지의 범위는 프로젝트의 종류, 프로젝트의 형식, 기술적인 환경, 구성원의 능력, 프로젝트의 사업적 목표에 따라 달라진다.
	+ 순차적인 방법 선호의 경우
		+ 요구사항이 상당히 안정적인 경우
		+ 설계가 직관적이며 이해하기 쉬운 경우
		+ 개발 팀이 해당 응용 분야에 익숙한 경우
		+ 프로젝트의 위험 부담이 적은 경우
		+ 장기적인 계획이 중요한 경우
		+ 요구사항, 설계, 코드 변경 비용이 높은 경우
	+ 반복적인 방법 선호의 경우
		+ 요구사항이 제대로 이해하기 힘들거나 다른 여러가지 이유로 인해 변경될 가능성이 농후한 경우
		+ 설계가 복잡하거나 어려운 경우
		+ 개발 팀이 해당 응용 분야에 대해 잘 모르는 경우
		+ 프로젝트의 위험 부담이 높을 때
		+ 장기적인 계획이 중요하지 않을 때
		+ 요구사항, 설계, 코드 변경 비용이 높지 않을 것 같을 때
	+ 소프트웨어 특성상 반복적인 접근 방법이 훨씬 유용한 경우가 대다수이다.
	+ 구현시 가장 먼저 할 일은 프로젝트에 가장 적합한 선행 조건이 무엇인가를 결정하는 것이다.
		+ 선행 조건을 진행하지 않으면 구현시 변경사항이 매우 많아 문제가 생기고 선행조건이 너무 지나치면 쓸때 없는 구현에 목메여서 구현속도에 문제가 생긴다.


<br>


# 문제: 정의 선행 조건

+ 설명
	+ 선행조건의 첫번째 할일은 시스템이 해결해야하는 문제를 명확히 기술하는 것이 첫번째이다.
		+ 이를 제품 비전, 비전 설명서, 미션 설명서, 제품 정의서등 이라고 적는데 기획쪽에서는 주로 전략보고서를 바탕으로 정리하는 경우가 많다. (따라서 전체적인 프로젝트의 성패는 사실상 기획팀의 리서치가 매우 중요하다.)
	+ 문제 정의는 해결책에 대해서는 언급하지 않고 문제가 무엇인지를 정의한다.
		+ 한 두장 분량의 간단한 문서여야하며 반드시 문제점에 대해 언급해야한다.
		+ 알맞은 예시
			+ 생산량을 기가드론의 주문 수량에 맞출 수 없다.
		+ 잘못된 예시
			+ 기가트론의 주문 수량에 맞추기 위해서 자동화된 데이터 입력 시스템을 최적화해야한다.
				+ 이는 해결책에 가깝기 때문에 옳지 않은 작성예시이다.
	+ 문제 정의는 반드시 사용자 언어로 작성해야 하며 사용자 관점에서 기술해야한다.
		+ 예외적으로 컴파일 시간이 오래 걸린다거나 툴에 버그가 많은 문제들을 제외하고서는 모두 사용자 관점에서 적어야한다.
	+ **문제정의를 실패하면 엉뚱한 문제를 해결하느라 시간을 버리게 된다.**
<br>


# 요구사항 선행 조건

+ 설명
	+ 요구사항은 소프트웨어 시스템이 무엇을 수행하는지 상세히 기술하고 해결책을 구현하기 위한 첫 과정이다.
		+ 이를 요구사항 분석, 요구사항 정의, 요구사항 명세서 작성등 이라고 부른다.

&emsp;&emsp;

## 명시적인 요구사항이 필요한 이유

+ 명시적 요구사항은 개발자 대신 사용자가 시스템의 기능을 주도하는데 도움을 준다.
	+ 명시적인 요구사항은 사용자가 요구사항을 보고 동의할 수 있다.
		+ 이렇지 않으면 개발자가 요구사항을 결정해버리는 바보같은 경우가 많다.

+ 명시적 요구사항은 논쟁을 피하게 해준다.
	+ 구현전 시스템의 기능을 결정하므로 프로그램 기능에 대해서 다른 개발자가 동의하지 않는다면 작성된 요구사항을 살펴보면서 문제를 해결할 수 있다.

+ 요구사항에 집중하면 개발 시작 후 변경 사항을 최소화시켜준다.
	+ 요구사항이 변경되면 보통 단순한 코드 변경이 아닌 설계를 뒤엎어야하는 경우가 많다. 그래서 시간이 더 많이 걸린다.
	+ 거기에 새로운 테스트 케이스도 작성해야 하고 다른 코드에 영향을 줘서 새로운 오류를 만들지 않는지 테스트를 더 해야하므로 더욱 시간이 더 걸린다.

+ 요구사항 명시화는 프로젝트 성공에 있어 효과적인 구현 기술보다 더 중요하다.

&emsp;&emsp;

## 견고한 요구사항에 대한 미신

+ 설명
	+ 견고한 요구사항 = 소프트웨어 개발의 성배
		+ 아키텍처 설계, 코드 작성, 테스트까지 순서에 따라 예상한대로 차분하게 프로젝트 진행이 가능하다.
		+ 비용 예측도 가능하며 디버깅까지 사용자가 새로운 기능에 대해 생각하지 않기 때문에 구현하는 데 100배 이상의 비용이 들 수 있는 새로운 기능에 대해서 생각할 필요가 없다.
	+ 일단 고객이 요구사항 문서를 받아들이고 나면 더 이상 변경할 필요가 없다고 기대해도 좋다.
		+ 다만 대부분의 고객은 코드 작성 전까지 본인에게 필요한 사항을 확실히 설명하지 못하는 고객들이 대부분이다.
		+ 보통 고객도 프로젝트가 진척될 수록 더 잘 이해하는 경우가 대다수이다.
		+ 따라서 개발과정에서 고객은 본인에게 필요한 요구사항을 더 잘 이해하게 되며 이 과정이 요구사항 변경의 주요 원인이다.
		+ **엄격한 요구사항을 따른다는 것은 사실 고객의 요구를 대응하지 않는다는 계획에 가깝다.**
	+ 일반적으로 개발시 25프로정도의 요구사항 변경을 경험하게 된다.
		+ 이것이 프로젝트에서 재작업을 하는 이유의 70~85프로이다.
		+ 고객이 감나무에서 떨어져 어디가 부족한 사람이 아니면 요구사항 변경으로 받는 영향을 최소화하기 위해 여러가지 조치를 취하는 것이 좋다.

&emsp;&emsp;

## 구현 중에 요구사항 변경 다루기

+ 요구사항 체크리스트로 요구사항의 품질을 평가하기
	+ 요구사항이 충분하지 않으면 작업을 멈추고 백업한 뒤 다음 요구사항을 제대로 수정한 후 일을 진행한다.

+ 모든 사람이 요구사항 변경 비용에 대해서 알게하기
	+ 고객은 새로운 기능을 생각해내면 매우 흥분하기 마련이며 이전에 요구사항과 계약서 서명, 완성된 요구사항 문서에 대해 이야기를 나눴던 회의를 전부 까먹는다.
		+ 이때, 기능에 심취한 고객을 다루기 쉬운 방법은 일단 공감한 뒤 요구사항 문서에 해당 피쳐는 없기 때문에 일정을 변경하고 다시 비용 추정을 해보아야한다고 말하면 아이스버켓 첼린지를 하는 것 마냥 정신을 번쩍 차리게 된다.
		+ 보통 고객들은 비용산정 얘기를 꺼내면 정신을 차리기 마련이며 반드시 이건 좀 구현해 달라던 새 기능은 이내 구현했으면 좋겠는데...로 바뀌게 된다.
	+ 현재 속한 조직에서 가장 먼저 다뤄야하는 요구사항의 중요성을 인식하지 못하고 있다면 요구사항 단계에서 변경하는 것이 나중에 변경하는 것보다 훨씬 비용이 적게 든다는 점을 강조해야한다.

+ 요구사항 변경 절차를 구축하기
	+ 고객이 새 기능을 계속 넣고 싶어한다면 변경사항을 검토할 수 있는 형식적인 변경 관리 위원회를 구축하는 것이 좋다.
		+ 진정한 문제는 고객이 마음을 바꿔 더 많은 기능이 필요하다는 것을 깨닫는 것이 아니라, 그러한 요구를 받아들일 수 없을 정도로 너무 자주 변경 사항을 제안한다는 점이다.
		+ 이런 위원회를 구축하면 개발자는 언제 변경 사항을 처리해내야하는지 알수 있어서 좋고, 고객은 언제 변경 사항이 적용되는지 알 수 있어서 좋다.

+ 변경 사항들을 수용할 수 있는 개발 접근 방법을 기용하기
	+ 진화적 프로토타이핑 접근 방법을 사용하면 기능 구현전, 인력을 투입하기 전에 시스템 요구사항의 전반을 훑어볼 수 있다.
	+ 진화적 출시는 시스템을 단계별로 출시하는 접근 방법이다.
		+ 작게 구축하여 고객에게 약간의 피드백을 받고 설계를 약간 수정한 뒤 약간의 변경을 거쳐 조금 더 만들어 나가는 방법이다.
	+ 핵심은 사용자에게 빠르게 응답가능하게 개발주기를 짧게 가져야한다.
		+ 애자일하게 가져가자

+ 프로젝트를 취소하기
	+ 요구사항이 매우 형편 없고 변하기 쉽고 앞에서 제안한 어떤 사항도 사용불가능하다면 그 프로젝트는 취소해야한다.
	+ 실제 프로젝트 자체를 취소하는 것이 불가능하다 할지라도 프로젝트 취소를 고려해보고 얼마나 더 나빠져야할지 고려해보자
	+ 자신이 처한 상황과 최악의 상황정도는 따져볼 수 있어야 한다.

+ 프로젝트의 사업성을 주시하기
	+ 요구사항 문제의 상당수는 프로젝트를 수행하는 사업상 목적을 고려하면 무의미해진다.
		+ 좋아보이던 요구사항도 기능으로서 점진적인 사업 가치를 평가해보면 터우미없는 아이디어로 보일 수 있다.
		+ 자신이 내린 결정이 사업에 미치는 영향을 고민하는 개발자라면 전문가에게 자문을 구할 것이다.

&emsp;&emsp;

### 요구사항 체크리스트

> 이는 프로젝트의 요구사항을 확인하기 위한 질문 목록이다.
> 이 목록을 이용해 구현 시 얼마나 확실한 요구사항을 가지고 있는지 판단하라.
> 요구사항의 리히터 척도로 자신이 어디에 있는지 알게 될 것이다.

+ 설명
	+ 체크리스트의 질문을 프로젝트 모두에 적용하기는 불가능하다.
		+ 비형식적인 프로젝트 진행시 생각할 필요도 없는 질문도 존재한다.
		+ 생각할 필요는 있지만 대답할 필요는 없는 질문도 존재한다.
		+ 하지만 형식을 중시하는 대형 프로젝트에는 모든 사항을 고려해야한다.

&emsp;&emsp;

#### 구체적인 기능 요구사항

+ 출처와 정확도, 값의 범위, 빈도를 포함해 시스템에 들어가는 모든 입력을 명시했는가?
+ 목적과 정확도, 값의 범위, 빈도, 형식을 포함해 시스템에서 나오는 모든 출력을 명시했는가?
+ 웹 페이지와 보고서 등을 위한 모든 출력 형식을 명시했는가?
+ 모든 외장 하드웨어와 소프트웨어 인터페이스를 명시했는가?
+ 데이터 교환(hand shaking)과 오류 검사, 통신 프로토콜을 포함한 모든 외부 통신 인터페이스를 명시했는가?
+ 사용자가 수행하고자 하는 모든 작업을 명시했는가?
+ 각 작업에 사용되는 데이터와 작업의 결과로 얻은 데이터를 명시했는가?

&emsp;&emsp;


#### 비기능적 (품질) 요구사항

+ 모든 필수 연산에 대해서 예상 응답 시간을 사용자 관점에서 명시했는가?
+ 처리 시간이나 데이터 전송률, 시스템 처리량과 같이 시간을 고려해야 하는 사항을 명시했는가?
+ 보안 수준을 명시했는가?
+ 소프트웨어 실패로 인한 결과와 실패 시 보호해야 하는 중요한 정보, 오류 검출과 복구를 위한 방법을 포함한 안정성에 대한 대책을 명시했는가?
+ 최소 메모리와 디스크 공간을 명시했는가?
+ 특정한 기능의 변경과 운영 환경의 변경, 다른 소프트웨어와의 인터페이스의 변경을 수용할 수 있는 능력을 포함한 시스템의 유지보수성을 명시했는가?
+ 프로젝트의 성공이나 실패에 대해서 정의했는가?

&emsp;&emsp;


#### 요구사항의 품질

+ 요구사항을 사용자의 언어로 작성했고, 사용자도 동의하는가?
+ 각 요구사항이 다른 요구사항과 충돌하지 않는가?
+ 견고하면서 변경이 쉬워야 하는 것처럼 서로 충돌하는 특성들 사이의 트레이드오프를 명시했는가?
+ 요구사항에서 설계에 대한 명세를 피하고 있는가?
+ 요구사항이 일관된 수준으로 기술되어있는가? 더 구체적으로 기술해야 할 요구사항은 없는가? 덜 구체적으로 기술해야할 요구사항은 없는가?
+ 따로 구현할 수 있으면서 여전히 이해할 수 있을 정도로 요구사항이 명확한가? 개발자도 그리 생각하는가?
+ 각 항목이 문제점과 해결책에 관련되어 있는가? 각 항목을 문제 환경에서 그 근원까지 추적가능한가?
+ 각 요구사항이 테스트 가능한가? 각 요구사항이 만족스러운지를 결정하기 위한 개별적인 테스트가 가능한가?
+ 요구사항에 대한 가능한 모든 변경 사항을 명시했는가?

&emsp;&emsp;

#### 요구사항의 완성도

+ 개발 시작 전, 정보 사용이 불가능하다면 그 부분을 명시했는가?
+ 개발이 모든 요구사항을 충족한다는 점에서 요구사항이 완비되었다고 생각하는가?
+ 모든 요구사항에 만족하는가? 구현이 불가능한 요구사항과 고객과 상사에게 보여주기 위한 넣은 요구사항을 제거했는가?

<br>

# 아키텍처 선행 조건

> 소프트웨어 아키텍처는 소프트웨어 설계의 상위 부분에 속하며 설계중에서 더 상세한 부분을 담은 틀이다. 

+ 설명
	+ 아키텍처는 시스템 아키텍처, 상위 수준 설계, 최상위 설계라고도 불린다.
	+ 일반적으로 아키텍처 명세서, 최상위 설계라는 문서 하나로 작성된다.
	+ 아키텍처와 상위 수준 설계를 구분하여 아키텍처는 시스템 전반에 적용되는 설계상의 제약 사항을 가리키고 상위 수준 설계는 서브 시스템이나 여러 클래스 수준에 적용 가능하지만 시스템 전반에 적용된다는 보장은 없는 설계상의 제약 사항을 가리킨다고 말하는 사람들도 있다.
	+ 이 자료에서는 기존 아키텍처 품질을 결정하는 방법에 대해 알려주며 아키텍처가 요구사항보다 구현에 더 가깝기 때문에 요구사항보다 아키텍처에 대해 더 자세히 설명한다.
	+ 아키텍처는 아키텍처 품질이 시스템의 개념적인 무결성을 결정하기 때문에 선행조건에 포함된다.
		+ 이는 곧 시스템의 궁극적인 품질을 결정하며 고심해서 만든 아키텍처는 머리부터 발끝까지 시스템의 개념적인 무결성을 유지하는 데 필요한 구조를 제공한다.
		+ 개발자에게 필요한 기술과 당면한 일에 관련된 상세 내용을 제공하며 여러 개발자와 개발 팀이 독립적으로 작업할 수 있도록 작업을 분배한다.
	+ 좋은 아키텍처는 구현을 쉽게, 나쁜 아키텍처는 구현을 불가능하게 만든다.
	+ 아키텍처 변경시 구현이나 그 후 작업에 많은 비용이 든다.
		+ 소프트웨어 아키텍처에서의 오류 수정은 코드 오류를 수정할 때가 아니라 요구사항 오류를 수정할 때 함께 진행해야 한다.

&emsp;&emsp;

## 전형적인 아키텍처의 구성요소

&emsp;&emsp;

### 프로그램 구조(구조도)

+ 설명
	+ 시스템 아키텍처는 시스템을 일반적인 말로 기술할 개요가 필요하다.
		+ 그러한 개요가 없다면 1000개가 넘는 세부 사항과 수십 개의 클래스로부터 전체적인 그림을 그리기 어려울 것이다.
	+ 아키텍처에서 최종구조에 대한 대안을 고려했던 근거와 다른 대안들 대신 지금의 구조를 선택한 이유를 찾아야한다.
		+ 시스템에서 클래스의 역할이 명확하지 않은 것처럼 보이면 클래스를 작성하기 어렵다.(당연한 말)
		+ 구조적인 대안들을 기술하여 아키텍처가 현재의 시스템 구조에 대한 논리적 근거를 제공하고 각 클래스가 신중하게 고려되었음을 보여준다.
		+ **설계에 대한 논리적인 근거는 설계 자체만큼이나 유지보수에 중요하다.**
	+ 아키텍처는 프로그램 내의 중요한 빌딩 블록을 정의해야 한다.
		+ 프로그램 크기에 따라 각 빌딩 블록은 하나의 독립된 클래스이거나 많은 클래스로 구성된 서브시스템일 수도 있다.
		+ 각 빌딩 블록은 하나의 클래스이거나 유저와 상호작용하거나 웹 페이지를 보여주거나 명령을 해석하거나 비즈니스 규칙을 캡슐화하거나 데이터에 접근하는 것과 같이 상위 수준의 기능을 처리하는 클래스나 루틴의 집합이다.
		+ 빌딩 블록에 적어도 요구사항에서 명시한 기능이 하나는 들어가야 한다.
			+ 두 개 이상의 빌딩 블록에서 처리되는 기능이 있다면 그것을 이용할 때 서로 충돌하지 않고 협력해야 한다.
	+ 각 빌딩 블록에서 책임져야 하는 내용은 반드시 명확하게 정의해야 한다.
		+ 하나의 빌딩 블록은 반드시 한 분야를 책임져야 하며 다른 빌딩 블록에 대해서는 가능한 조금 알아야 한다.
			+ 한 딜딩 블록이 다른 빌딩 블록에 대해 아는 내용을 최소화함으로써 설계에 관한 정보를 단일 빌딩 블록으로 제한하는 것이다.
	+ 각 빌딩 블록에 대한 커뮤니케이션 규칙도 명확해야한다.
		+ 직접 사용가능한 빌딩 블록, 간접적으로 사용가능한 빌딩 블록, 절대로 접근하면 안되는 빌딩블록이 무엇인지 기술해야한다.

&emsp;&emsp;

### 주요 클래스

+ 설명
	+ 아키텍처는 주요 클래스를 명시해야한다.
		+ 각각 중요한 클래스가 맡은 역할과 클래스 사이의 상호작용을 어떻게 할 것인지를 규명해야한다.
		+ 클래스 계층 구조와 상태전이, 객체 지속성에 대한 설명도 포함해야 한다.
		+ 시스템이 꽤 크다면 클래스들의 서브시스템에 대해서도 기술해야한다.
	+ 아키텍처는 고려했던 다른 클래스 설계에 대해서 기술하고 외 지금과 같은 구조를 선택하게 되었는지에 대한 이유를 설명해야한다.
		+ 아키텍처가 시스템에 사용되는 모든 클래스를 명시할 필요는 없다.
		+ **80 : 20 비율로, 시스템 기능의 80프로를 담당하는 20프로의 클래스에 대해서만 명시하는게 좋다.**

&emsp;&emsp;

### 데이터 설계

+ 설명
	+ 아키텍처는 중요한 파일과 테이블 설계를 기술해야 한다.
		+ 고려했던 다른 대안들에 대해서 기술하고 현재의 방법을 선택한 이유도 설명해야 한다.
		+ 응용 프로그램이 고객 ID 목록을 유지하는 데 이를 구현하기 위해 설계자가 순차적 접근 리스트를 사용했다면 왜 순차적 접근 리스트가 비순차 접근 리스트나, 스택, 해시 테이블보다 더 나은 선택이였는지 설명해야 한다.
		+ 유지보수나 구현시 이러한 정보가 개발자나 설계자를 이해하는 데 도움을 준다.
	+ 데이터는 일반적으로 하나의 서브시스템(도메인)이나 클래스에서만 직접 접근해야한다.
		+ 이때 특별한 관리를 하거나 추상적인 방법으로 데이터를 접근하다록 허락한 접근 클래스나 루틴은 예외이다.
	+ 아키텍처는 모든 데이터베이스의 고수준 구조와 내용에 대해서 명시해야한다.
		+ 만약 단일 데이터베이스가 아닌 다중 데이터베이스를 쓴다면 그 장점과 선택 이유를 명시해야하고 데이터베이스가 일반 텍스트 파일보다 나았던 이유도 설명해야하고 동일한 데이터를 접근하는 다른 프로그램과의 상호 연동이 가능한지 규명하고 데이터에 대해 생성한 뷰를 설명해야 한다.


&emsp;&emsp;

### 비즈니스 규칙

+ 설명
	+ 아키텍처가 특정한 비즈니스 규칙을 따른다면 반드시 이를 규명하고 그러한 규칙들이 시스템 설계에 미친 영향을 기술해야한다.
		+ 고객 세션을 10분이상 유지하면 안된다는 비즈니스 규칙을 따른느 시스템의 경우, 고객 세션을 최신정보로 유지하고 동기화하기 위한 아키텍처 접근 방법에 대해 그 규칙이 미치는 영향도 기술해야한다.

&emsp;&emsp;

### 사용자 인터페이스 설계

+ 설명
	+ 유저 인터페이스는 종종 요구사항 작성시 명세된다.
		+ 이게 아니면 소프트웨어 아키텍처 작성시 명시되어야 한다.
	+ 아키텍처는 웹페이지 형식, GUI, CLI등 주요 요소를 명시해야한다.
	+ 사용자 인터페이스를 얼마나 신중하게 고려했는지에 따라 널리 사용되는 프로그램과 그렇지 않은 프로그램으로 나뉜다.
	+ 아키텍처는 비즈니스 규칙이나 프로그램의 결과에 영향을 미치지 않고 새로운 유저 인터페이스로 대체할 수 있도록 모듈화되어야 한다.
		+ 예시로, 아키텍처는 대화형 인터페이스 클래스를 삭제하고 CLI 클래스를 넣기 매우 쉽게 만들어야 한다.
			+ 이러한 기능은 CLI 인터페이스가 단위 혹은 서브시스템 수준에서 소프트웨어 테스트시 편리하기 때문에 유용한 경우가 종종 있다.
	+ 유저 인터페이스 설계만으로 또다른 책을 한권 작성이 가능하다.


&emsp;&emsp;

### 자원 관리

+ 설명
	+ 아키텍처는 데이터베이스 연결, 쓰레드, 핸들과 같은 부족한 자원을 관리하기 위한 계획을 기술해야한다.
	+ 메모리 관리는 드라이버 개발이나 임베디드 시스템과 같이 메모리가 한정된 애플리케이션을 다룰 때 중요한 분야이다.
	+ 아키텍처는 일반적인 상황과 최악의 상황에서 사용되는 자원을 측정해야한다.
		+ 간단하게라도 그러한 평과 결과가 예상 구현 환경에서 필요한 자원이 충분하다는 것을 보여줘야한다.
		+ 복잡하게 한다면 애플리케이션이 자원을 적극적으로 관리하게 끔 해야할 수도 있다.
		+ 그렇다면 자원 관리부분도 시스템의 다른 부분 못지 않게 신중하게 설계되어야한다.


&emsp;&emsp;

### 보안

+ 설명
	+ 아키텍처는 설계 단계와 코드 단계의 보안에 대한 접근 방법을 기술해야 한다.
	+ 위협 모델을 이전에 구성하지 않았다면 아키텍처 작성 시 구성해야한다.
	+ 코드 지침서는 버퍼 처리 방법, 신뢰할수 없는 데이터(유저, 쿠키, 환경 설정 데이터, 외부 인터페이스로부터 데이터 입력) 처리 규칙, 암호화, 오류 메시지에 포함될 내용의 상세함 정도, 메모리에 있는 중요 데이터 보호화 같은 보안 관련 사항을 염두에 두고 작성해야 한다.


&emsp;&emsp;
### 성능

+ 설명
	+ 성능을 염려한다면 요구사항에 원하는 성능을 명시해야 한다.
		+ 속도나 메모리, 비용 같은 자원사이의 우선순위를 성능 목표에 명시해야 하는 경우라면 자원 사용도 그 내용에 포함해야한다.
	+ 아키텍처는 추정치를 제공해야하며 설계자가 그러한 목표에 도달할 수 있다고 믿는 이유를 설명해야한다.
	+ 어떤 영역이 목표를 달성하지 못할 위험에 처해 있다면 그러한 내용에 대해서도 언급해야 한다.
	+ 어떤 영역이 성능 목표를 달성하기 위해 특정 알고리즘이나 데이터 형식을 사용했다면 그러한 내용에 대해서도 언급해야한다.
	+ 또한 아키텍처에는 각 클래스와 객체의 크기와 시간에 대한 예산도 들어갈 수 있다.


&emsp;&emsp;

### 확장성

+ 설명
	+ 확장성은 추후의 요구를 충족시키기 위해 시스템이 확장할 수 있는 능력이다. 
		+ 아키텍처는 사용자 수와 서버 수 , 네트워크 노드의 수, 데이터베이스 레코드의 수, 데이터베이스 레코드의 크기, 트랜잭션 용량 등의 증가를 시스템이 어떻게 처리할 것인지를 기술해야 한다.
	+ 시스템이 확장될 가능성이 없거나 확장성이 문제가 되지 않는다면 아키텍처는 그러한 가정에 대해서 명시적으로 언급해야 한다.

&emsp;&emsp;

### 상호운용성

+ 설명
	+ 시스템이 다른 소프트웨어나 하드웨어와 함께 데이터나 자원을 공유할 것으로 예상된다면 아키텍처는 그러한 기능을 어떻게 구현할 것인지 기술해야 한다.

&emsp;&emsp;

### 국제화와 지역화

+ 설명
	+ 국제화는 프로그램이 여러 나라를 지원하기 위한 기술적인 준비작업이다.
		+ 이를 I18n이라고 부르기도 한다.
			+ I는 국제화의 첫글자 N은 마지막 글자, 18은 그 사이에 있는 글자 수를 의미한다.
			+ k8s와 비슷한 작명법이다.
	+ 지역화도 L10n으로 부르기도 하며 특정한 언어를 지원하기 위한 번역작업이다.
	+ 국제화 이슈는 대화식 시스템을 위한 아키텍처 작성 시 주의해야 하는 부분이다.
		+ 대부분 대화식 시스템에는 수십에서 수백 개의 안내 메시지와 상태표시, 도움말 메시지, 오류 메시지가 들어 있다.
		+ 문자열을 사용하는 자원들은 미리 예측하거나 코드작성시 상수값으로 빼둬야한다.
		+ 이러한 문자열들(특히 키워드나 레이블들)은 기획에서도 중요하기 때문에 따로 상수로 빼두고 기획팀에서 수시로 변경이 가능하도록 미리 손써두는 것이 좋다.(개인적인 의견)

&emsp;&emsp;

### 입력/출력

+ 설명
	+ 아키텍처에서 입출력에 대해서도 주의깊게 봐야한다.
		+ 입력 체계가 선행인지 후행인지, 상황에 따라 선택되는지 명시해야 한다.
		+ 필드나 레코드, 스트림, 파일 수준에서 어떤 입출력 오류가 검출되는지를 명시해야한다.


&emsp;&emsp;

### 오류 처리

+ 설명
	+ 오류 처리는 현대 컴퓨터 과학에서 가장 어려운 문제중 하나로 인식되고 있기 때문에 오류를 함부로 처리할 수 없다.
		+ 어떤 사람들은 프로그램 코드의 90프로정도가 예외적인 오류를 처리하거나 이를 정리하기 위한 것이고 나머지 10프로만이 일반적인 경우를 위한 것이라고 추정하기도 한다.
		+ 오류처리를 위해 많은 코드가 작성되므로 오류를 처리하기 위한 일관된 방법이 아키텍처에 명시되어 있어야 한다.
	+ 오류 처리는 종종 코드 작성 관습 수준의 문제로 취급되는데 오류는 시스템 전반적으로 영향을 미치므로 아키텍처 수준에서 다뤄야 맞다.


+ 오류 처리시 고려사항
	+ 오류 처리가 오류 수정을 하는가, 단순히 검출만 하는가? 
		+ 수정을 하는 경우
			+ 프로그램을 오류로부터 복구하기 위한 시도를 할 수 있다.
		+ 검출만 하는 경우
			+ 프로그램은 아무 일도 없던 것처럼 처리를 진행하거나 중단할 수 있다.
		+ 어느 경우에도 오류를 검출했다는 사실은 유저에게 알려줘야 한다.
	+ 오류 검출이 능동적인가? 수동적인가?
		+ 시스템은 유저 입력 값의 유효성 검사를 통해 오류를 능동적으로 예상하거나 유저 입력 값에 오버플로가 발생했을 때 처럼 오류를 피할 수 없을 때 오류에 수동적으로 대응할 수 있다.
		+ 시스템은 입력 방법을 명확히 하거나 오류가 발생한 상황을 정리할 수 있다.
		+ 이 경우에도 어느 경우를 선택하든 유저 인터페이스와 밀접하게 관련되어 있다.
	+ 프로그램이 오류를 어떻게 전달하는가?
		+ 일단 오류를 검출하면 오류를 발생시킨 데이터를 곧바로 버리거나 오류를 처리하기 위해서 오류 처리 과정으로 넘어갈 수 있다.
		+ 위의 경우가 아니라면 프로그램의 모든 처리가 완료될 때까지 기다렸다가 어디에선가 오류가 검출되었다는 것을 사용자에게 알릴 수 있다.
	+ 오류 처리 메시지에 대한 규약이 있는가? 
		+ 아키텍처가 하나의 일관된 방법을 명시하지 않는다면 사용자 인터페이스는 여러 부분에서 서로 다른 인터페이스가 뒤섞인 것처럼 보일 것이다.
		+ 위 처럼 보이지 않도록 아키텍처는 오류메시지에 대한 규약을 수립해야 한다.
	+ 예외를 어떻게 처리할 것인가?
		+ 아키텍처는 코드가 언제 예외를 던지고 어디서 처리되며 어떻게 기록되고 어떻게 문서화 될것 인지에 대한 내용을 설명해야 한다.
	+ 프로그램 내부에서 어떤 수준에서 오류가 처리될 것인가?
		+ 오류는 검출 당시에 처리하거나 오류 처리 클래스로 전달하거나 호출 체인으로 전달될 수 있다.
	+ 입력 데이터를 검증하기 위해서 각 클래스가 어느 수준까지 책임져야 하는가?
		+ 각 클래스가 자신의 데이터를 검증하는지, 아니면 시스템의 데이터를 검증하는 특정 클래스 집합이 있는지, 모든 수준의 클래스가 받은 데이터에 문제가 없다고 가정할 수 있는지?
	+ 사용자 환경에서 기존에 제공하고 있던 오류 처리 방법을 사용할 것인지, 아니면 새로 만들 것인가?
		+ 사용자의 환경에 특정 오류 처리 방법이 있다고 해도 그것이 요구사항에 가장 적합한 방법은 아닐 수 있다.

&emsp;&emsp;

### 장애 허용

+ 설명
	+ 아키텍처는 예상되는 장애 허용의 종류 또한 지정해야 한다.
		+ 장애 허용은 오류를 검출하고 가능한 경우에는 오률고부터 복구하고 그렇지 않은 경우에는 시스템에 미치는 악영향을 방지함으로써 시스템의 신뢰도를 높이는 기술이다.
	+ 아래와 다른 장애 허용방법에는 오류를 발견했을 때 시스템을 부분 작업 상태나 기능 축소 상태로 전환하는 방법이 있다. 또한 전원을 끄거나 자동으로 재실행할 수 있다. 이러한 예상들은 간단한 것들이다.
	+ 장애 허용은 흥미로우면서도 어려운 주제이다.

+ 장애 허용 구성 방법
	+ 오류를 발견할 때 시스템의 자료를 백업하거나 다시 시도할 수 있다.
		+ 처음 구한 답이 틀렸다면 잘된 부분까지백업하고 그 부분부터 계속한다.
	+ 시스템은 주 코드에서 오류가 발견된 경우 보조 코드를 사용할 수 있다.
		+ 이 경우에는 첫 번째 답이 틀리면 다른 시스템이 또 다른 제곱근 공식을 사용한다.
	+ 시스템은 투표 알고리즘을 사용할 수 있다.
		+ 시스템이 서로 다른 방법을 사용하는 세 가지 제곱근 클래스를 가지고 있다고 하면 각 클래스가 제곱근을 계산한 후 시스템이 결과를 비교한다.
		+ 시스템에 구축된 장애 허용 정도에 따라 시스템이 평균 값이나 중간 값, 또는 세 값에서 가장 많이 나타난 값(최빈수)를 사용한다.
	+ 시스템은 잘못된 값을 시스템의 나머지 부분에 악영향을 끼치지 않는 가짜 값으로 대체할 수 있다.

&emsp;&emsp;

### 구조적인 실행 가능성

+ 설명
	+ 설계자는 시스템이 성능 목표를 달성할 수 있는지, 자원의 한계 내에서 실행 가능한지, 또는 구현 환경에서 충분히 지원되는지에 대해서 관심을 가질 것이다.
	+ 아키텍처는 시스템이 기술적으로 실행 가능함을 보여줘야 한다.
		+ 특정 분야에서의 실행 불가능 때문에 프로젝트 전체가 실행 불가능해 보인다면 아키텍처는 기술 검증 프로토타입이나 조사, 기타 다른 방법을 통해서 그러한 문제점을 어떻게 조사했는지 설명해야 한다.
		+ 그러한 위험 요소는 전체 구현 작업을 시작하기 전에 해결되어야 한다.

&emsp;&emsp;

### 과도한 엔지니어링

+ 설명
	+ 견고함은 시스템이 오류를 발견한 후에도 계속 실행할 수 있는 능력을 말한다.
		+ 아키텍처는 요구사항에 명시된 것 보다 더 견고한 시스템을 명시하고는 한다.
			+ 이 이유는 최소한의 견고함을 갖고 있는 여러 부분으로 구성된 시스템은 전체적으로 봤을 때 요구된 것보다 견고함이 떨어질 수 있다는 것이다.
			+ 소프트웨어에서 각 부분 간의 연결고리는 가장 약하게 연결되어 있는 링크보다도 약하기 때문에 여러 약한 고리로 연결된 프로그램은 그만큼 더 약해지게 된다.
			+ 아키텍처는 개발자의 잘못이 지나치게 엔지니어링을 수행한 것인지, 아니면 지나치게 일을 간소화한 것인지를 명확하게 지적해야 한다.
	+ 과도한 엔지니어링에 대한 대처법을 명시하는 것은 많은 개발자가 전문가라는 자부심이 지나쳐 자기도 모르게 클래스를 과도하게 엔지니어링을 하기 때문에 중요하다.
		+ 아키텍처에서 명쾌하게 예측해놓으면 일부 클래스는 유난히 견고하고 다른 클래스는 거의 적정 수준에도 못 미치는 현상을 피할 수 있다.

&emsp;&emsp;

### 구입과 구현 결정

+ 설명
	+ 소프트웨어를 구현하는 가장 급진적인 해결책은 모든 것을 직접 구현하는 대신 사거나 무료로 제공되는 오픈소스 소프트웨어를 사용하는 것이다.
	+ 오늘날에는 정말 많은 GUI 생산툴들이 무료로 제공되고 있으며 이걸 그냥 가져다 사용만 하면 되는 세상이다.
	+ 아키텍처가 시장에서 판매하는 컴포넌트를 사용하지 않는다면 맞춤 제작하는 컴포넌트가 판매 중인 라이브러리와 컴포넌트의 기능을 어떤 부분에서 능가할 것인지 충분히 설명해야 한다.

&emsp;&emsp;

### 재사용 결정

+ 설명
	+ 기존 소프트웨어나 테스트 케이스, 데이터 형식, 다른 요소들을 사용할 계획이라면 아키텍처는 재상용된 소프트웨어가 다른 아키텍처 목표에 어떻게 부합할 것인지를 설명해야한다.

&emsp;&emsp;

### 변경 전략

+ 설명
	+ 소프트웨어 제품을 만드는 일은 개발자와 사용자 모두에게 배우는 과정이기 때문에 제품은 개발 내내 변경될 수 있다.
		+ 변경은 바꾸기 쉬운 데이터 유형, 파일 형식, 변경된 기능, 새로운 기능등으로부터 발생한다.
		+ 계획된 기능 향상이나 시스템의 첫 번째 버전에서 구현하지 못했던 기능 보완을 위해 변경한다.
		+ 결과적으로 소프트웨어 설계자가 마주하고 있는 과제는 변경 사항을 수용할 수 있을 정도로 유연한 아키텍처를 만드는 것이다.
	+ 아키텍처는 변경을 처리하기 위한 전략을 명확히 기술해야 한다.
		+ 아키텍처는 가능한 기능 향상을 고려했으며 해당 기능 향상을 쉽게 구현할 수 있음을 보여줘야 한다.
		+ 입출력 형식, 사용자와의 상호작용 방식, 처리 요구사항이 변경될 것 같다면 아키텍처는 모든 변경 사항을 예상했고 한 가지 사항을 변경할 때마다 소수의 클래스에만 영향을 미친다는 점을 보여줘야한다.
		+ 아키텍처의 변경 계획은 데이터 파일에 버전 번호를 추가하거나 나중에 사용할 목적으로 필드를 예약하거나 새로운 테이블을 추가할 수 있도록 파일을 설계하는 것처럼 간단할 수 있다.
		+ 코드 제네레이터를 사용하고 있다면 아키텍처는 코드 제네레이터의 기능을 이용하여 구현 가능하다는 것을 보여야 한다.
	+ 아키텍처는 작업을 지연하는 데 사용할 전략을 명시해야 한다.
		+ 아키텍처는 테스트를 위해 코드를 직접 입력하는 대신 테이블 기반의 기법을 사용한다는 것을 명시해야 할 것이다.
		+ 테이블로 저장된 데이터는 프로그램 내부에 직접 입력되지 않고 외부 파일에 저장되기 때문에 프로그램을 재 컴파일하지 않고도 프로그램을 변경할 수 있다.(당연한 말)


&emsp;&emsp;

### 일반적인 아키텍처 품질

+ 설명
	+ 좋은 아키텍처 명세서는 시스템에 있는 클래스와 각 클래스에 숨어있는 정보, 가능한 모든 설계 대안을 포함하거나 제외한 근거를 다루고 있다는 특징이 있다.
	+ 아키텍처는 임의로 추가할 사항 없이 깔끔하고 개념적으로 완전해야한다.
		+ 맨먼스 미신에서는 큰 시스템에서 발생하는 핵심적인 문제점은 개념적 무결성을 유지하는 것이라고 강조한다.
		+ 좋은 아키텍처는 문제에 적합해야하며 아키텍쳐를 봤을 대 감동적일 정도로 해결책이 자연스럽고 쉬워보여야 한다.
	+ 아마도 개발 시 아키텍처를 변경하는 방법에 대해서 알고 있을 것이다.
		+ 각 변경 사항은 전체적인 개념과 명확히 일치해야한다.
		+ 아키텍처가 허술하게 보여서는 안된다.
	+ 아키텍처의 목표는 명확하게 기술되어야 한다.
		+ 두 시스템이 동일한 기능을 제공하더라도 변경 가능성이 주요 목표인 시스템에 대한 설계와 아직 성능 목표가 정해지지 않은 시스템에 대한 설계는 다를 것이다.
	+ 아키텍처는 모든 주요 결정사항에 대한 동기를 기술해야 한다.
		+ 항상 그래왔었다는 식으로 정당화해서는 안된다.
		+ 책에서는 예시를 요리법으로 알려줬지만 난 이것을 군대에서 겪어본 경험이 있어서 내 방식대로 기술해보자면 이런 것이다.
			+ 포사격을 하는 부대에서는 늘 포각을 설정할때는 특정 상수값을 빼줘야 정확하게 적을 타격했다고 한다. 이유는 아주 예전부터 그냥 사수로부터 그렇게 배워왔어서 그랬다고 하는데 사회에 나와보니 이런 부대가 한둘이 아니였다.
			+ 그러나 아키텍처는 이런식으로 굴러가면 안된다는 것이다.
	+ 훌륭한 소프트웨어 아키텍처는 대부분 기계와 언어에 독립적이다.
		+ 가능한 환경에 독립적일 수록 시스템 아키텍처를 과잉으로 작성하거나 구현 단계에서도 충분히 할 수 있는 업무를 아키텍처 단계에서 수행하는 일을 피할 수 있다.
		+ 이 지침은 프로그램의 목적이 특정한 기계나 언어를 활용할 때는 적용되지 않는다.
	+ 아키텍처는 시스템을 명시할 때 지나치거나 모자라지 않게 선을 잘 그어야한다.
		+ 아키텍처의 어느 부분도 지나치게 주의를 끌거나 과도하게 설계되어서는 안된다.
		+ 아키텍처는 다른 부분을 희생하면서 특정 부분을 집중적으로 다루어서는 안된다.
		+ 아키텍처는 필요 없는 요소는 넣지 말고 금으로 도금하지 않는 채 모든 요구사항을 나타내야 한다.
	+ 아키텍처는 명시적으로 위험 영역을 규명해야 한다.
		+ 그것이 왜 위험하며 위험을 최소화하기 위한 절차는 무엇인지 설명해야 한다.
	+ 아키텍처에는 여러 관점이 들어가야 한다.
		+ 집을 짓기 위한 계획서에는 높이, 바닥, 골조, 전선 설계도를 비롯해 집에 대한 여러 가지 관점을 포함할 것이다.
		+ 소프트웨어 아키텍처 설명서 또한 시스템에 대한 오류와 모순을 밝혀내는 다양한 관점을 제공함으로써 개발자가 시스템의 설계를 완전하게 이해하는 데 도움을 주낟.
	+ 아키텍처에는 확신이 있어야 한다.
		+ 상사를 기쁘게 하려는 내용이나 이해하기 어려운 내용이 들어가서는 안된다.
		+ 실제로 구현할 사람이 나인데 내가 이해하지 못하면 어떻게 구현이 가능한가?

&emsp;&emsp;

### 아키텍처 체크리스트

> 다음은 훌륭한 아키텍처가 갖추어야할 항목이다.
> 
> 이 목록이 아키텍처에 대한 종합 안내서가 되지는 않겠지만 개발자가 소프트웨어 먹이 사슬 끝 단계에서 얻는 영양분이 무엇인지를 평가하는 실용적인 방법은 될 수 있다.

+ 설명
	+ 이 체크리스트를 자신만의 리스트를 만드는 시작점으로 사용하자
	+ 요구사항 체크리스트에서처럼 비형식적인 프로젝트를 진행중이라면 고려할 필요가 없는 항목이 또다시 존재한다.
	+ 큰 프로젝트를 진행중이라면 마찬가지로 대부분 항목이 유용하다.

&emsp;&emsp;

#### 구체적인 아키텍처 주제

+  좋은 아키텍처의 개요와 설명을 포함한 전체적인 프로그램 구조가 명확한가?
+ 주요 빌딩 블록을 그 책임 영역과 다른 빌딩 블록에 대한 인터페이스를 포함해 잘 정의했는가?
+ 요구사항에 있는 모든 기능을 적절한 수의 빌딩 블록으로 다루었는가?
+ 가장 중요한 클래스를 기술하고 정당성을 증명했는가?
+ 데이터베이스 구조와 내용을 명시했는가?
+ 핵심 비즈니스 규칙을 모두 명시하고 그 규칙이 시스템에 미치는 영향을 기술했는가?
+ 사용자 인터페이스 설계 전략을 기술했는가?
+ 사용자 인터페이스를 일부 변경해도 프로그램의 나머지 부분에 영향을 미치지 않도록 모듈화를 했는가?
+ 입출력 처리방법을 기술하고 정당성을 증명했는가?
+ 쓰레드와 데이터베이스 연결, 핸들, 네트워크 대역폭 등과 같이 부족한 자원에 대해서 자원 사용 예측 및 자원 관리 방법을 기술했는가?
+ 아키텍처의 보안 요구사항을 기술 했는가?
+ 아키텍처가 각 클래스나 서브시스템, 기능 영역에 대한 공간과 속도를 설정했는가?
+ 아키텍처가 확장성을 어떻게 구현할지 기술했는가?
+ 아키텍처가 상호운용성을 다루는가?
+ 국제와와 지역화를 위한 방법을 기술했는가?
+ 일관된 오류 처리 방법을 제공했는가?
+ 장애 허용에 대한 접근 방법을 정의했는가?(장애 허용이 필요한 경우)
+ 시스템의 모든 부분에 대해서 기술적인 구현 가능성을 확인했는가?
+ 과도한 엔지니어링에 대한 해결책을 명시했는가?
+ 구입할 것인지 구현할 것인지에 대한 결정을 포함했는가?
+ 재사용된 코드가 아키텍처의 다른 목표와 어떻게 부합할 것인지 기술했는가?
+ 아키텍처가 가능성 있는 변경 사항을 수용할 수 있도록 설계했는가?

&emsp;&emsp;

#### 일반적인 아키텍처 품질

+ 아키텍처가 모든 요구사항을 설명하고 있는가?
+ 지나치거나 부족한 부분은 없는가? 이 부분에 대한 기대치를 명확히 설정하고 있는가?
+ 전체적인 아키텍처가 개념적으로 일관성을 갖는가?
+ 최상위 설계가 구현에 사용될 기계와 언어에 독립적인가?
+ 모든 중요한 결정에 대한 근거를 제공하는가?
+ 시스템을 구현할 당사자로서 아키텍처에 만족하는가?


<br>


# 선행 조건에 소요되는 시간

+ 설명
	+ 문제 정의와 요구사항, 소프트웨어 아키텍처 작업에 소요하는 시간은 프로젝트의 필요에 따라 달라진다.
		+ 일반적으로 제대로 진행되는 프로젝트는 오구사항과 아키텍처, 사전 계획 수립을 위해 전체 노력의 10~20프로 정도와 전체 시간의 20~30프로 정도를 투자한다.
			+ 이 수치에는 상세 설계를 위한 시간은 포함하지 않는다. 상세 설계는 구현의 일부이기 때문이다.
	+ 요구사항이 불안정하고 작업 중인 프로젝트의 규모가 크고 형식적인 프로젝트를 진행중인 경우 
		+ 구현 초기에 발생하는 요구사항 문제점을 해결하기 위해 요구사항 분석가와 작업해야할 수도 있다.
		+ 요구사항 분석가와 상담하고 요구사항 분석가가 요구사항을 교정하게 한 후 구현 가능한 요구사항을 확정 짓는다.
	+ 요구사항이 불안정하고 작업 중인 프로젝트의 규모가 작고 비형식적인 경우
		+ 직접 요구사항 이슈를 해결해야 할 것이다.
		+ 요구사항을 정의하는 데 충분한 시간을 투입하여 요구사항의 변경이 구현에 미치는 영향을 최소화한다.
	+ 프로젝트가 형식적이든 비형식적이든 상관없이 요구사항이 불완전한 경우
		+ 요구사항 수집 작업 자체를 하나의 프로젝트로 다뤄야한다.
		+ 요구사항 작업을 마친 뒤 프로젝트의 나머지 시간을 추정한다.
		+ 어느 누구도 무엇을 만들기 알기 전까지 일정을 예측할 수 없으니 이렇게 진행하는 편이 현명하다.
		+ 고객이 무엇을 원하는지도 모르는데 일을 진행하려 해봐야 프로젝트 진행에 의미가 없다.
	+ 소프트웨어 아키텍처에 시간을 할당할 때도 요구사항 개발과 유사한 방법을 사용한다.
		+ 지금까지 한 번도 다루지 않은 소프트웨어라면 새로운 분야에서의 불확실한 설계에 대하여 더 많은 시간을 할애 한다.
	+ 좋은 아키텍처를 위해 소비하는 시간 때문에 다른 작업 영역에 지장을 주지 않도록 해야한다.
		+ 필요하다면 이 역시 다른 프로젝트로 취급하여 진행하는 편이 좋다.

&emsp;&emsp;

### 선행 조건 체크리스트 

+ 진행할 소프트웨어 프로젝트의 종류를 규명했고 적절한 접근 방법을 선택했는가?
+ 요구사항이 충분히 명확하게 정의되었으며 구현을 시작할 수 있을 정도로 안정적인가? (요구사항 체크리스트 확인)
+ 아키텍처가 구현을 시작할 수 있을 정도로 충분히 명확하게 정의되었는가? (아키텍처 체크리스트 확인)
+ 구현이 필요 이상으로 위험에 노출되어서는 안 된다는 사항과 같이 진행 중인 프로젝트에만 해당하는 다른 위험 요소에 대해 언급했는가?

&emsp;&emsp;

## 요점 정리

+ 구현을 준비할 때 가장 중요한 목표는 위험을 줄이는 것이다.
	+ 준비 작업이 위험을 증가시키는 것이 아니라 감소시킬 수 있도록 한다.
+ 품질이 뛰어난 소프트웨어를 개발하고 싶다면 처음부터 끝까지 소프트웨어 개발 과정 내내 품질에 관심을 가져아한다.
	+ 품질에 대한 관심을 처음부터 가지는 것이 나중에 갖는 것보다 제품의 품질에 훨씬 큰 영향을 끼친다.
+ 프로그래밍을 시작하기 전 적절한 준비의 중요성을 포함한 소프트웨어 개발 과정에 대해 상사와 동료를 교육하는 것도 개발자의 몫이다.
+ 프로젝트의 종류가 구현 선행 조건에 중대한 영향을 미친다.
	+ 반복적으로 진행해야하는 프로젝트도 많지만 순차적으로 진행해야하는 프로젝트도 많다.
+ 문제 정의가 명시되어 있지 않다면 구현시에 잘못된 문제를 풀게 된다.
+ 요구사항 개발이 제대로 이루워지지 않는다면 문제의 중요한 사항을 놓칠 수 있다.
	+ 구현 다음 단계부터는 요구사항을 변경할 때 처음보다 20배에서 100배정도 비용이 더 들기 때문에 프로그래밍을 시작하기 전에 요구사항이 맞는지 확인해야한다.
+ 아키텍처 설계가 제대로 이루어지지 않는다면 구현시에 올바른 문제를 잘못된 방법으로 해결할 수 있다.
	+ 잘못된 아키텍처로 작성된 코드가 증가할 수록 구조적인 변경 비용이 증가하므로 아키텍처가 맞는지 확인해야 한다.
+ 프로젝트에서 구현 선행 조건에 어떤 접근 방법을 적용했는지 알고 그에 따라 적절한 구현 방법을 선택한다.