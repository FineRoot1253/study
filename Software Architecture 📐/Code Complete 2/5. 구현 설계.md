
> 설계가 실질적인 구현 작업이 아니라고 주장하는 사람도 있지만 작은 프로젝트에서는 설계를 포함한 많은 작업이 구현의 범위에 들어간다고 여긴다.

+ 설명
	+ 일부 대형 프로젝트에서는 형식적인 아키텍처 작업에서 시스템 수준의 사항만 다루고 의도적으로 설계 작업의 상당 부분을 구현 과정으로 미룬다.
		+ 물론 다른 큰 프로젝트에서는 코드를 입력하기만 해도 프로젝트를 마칠 수 있을 정도로 자세히 설계하는 경우도 있지만 설계가 그 정도로 완벽하기란 거의 불가능하다.
		+ 개발자들은 공식적이든 아니든 프로그램 일부를 설계하기 마련이다.
	+ 작고 비형식적인 프로젝트에서는 설계의 상당 부분이 개발자가 키보드 앞에 앉아 있는 동안에 진행된다.
		+ 설계란 단순히 상당 부분을 작성하기 전 의사코드를 작성하거나 코드로 구현하기 전 클래스 사이 관계를 다이어그램으로 그리는 것일 수도 있고, 다른 개발자에게 어떤 디자인 패턴이 더 나은지 물어보는 것 일수도 있다.
		+ 설계를 어떻게 하든 상관없이 큰 프로젝트는 물론이고 작은 프로젝트도 신중히 설계하면 좋은 점이 있고 설계를 명백하게 수행하는 작업으로 인식하고 진행하면 그로부터 얻는 해택이 최대화될 것이다.
	+ 설계는 광범위한 주제라서 모든 부분을 다루지는 못한다.
		+ 훌륭한 클래스와 루틴 설계의 상당 부분이 시스템 아키텍처로 결정되기 때문에 3.5절에서 다룬 아키텍처 선행 조건들을 만족하는지 확인해야 한다.
		+ 클래스와 루틴을 개발하는 중에도 훨씬 더 많은 설계 작업을 수행할 수 있다.


# 설계의 어려움

+ 설명
	+ 소프트웨어 설계는 컴퓨터 소프트웨어에 대한 명세를 동작 가능한 소프트웨어로 변환하기 위한 계획에 대한 구상이나 창작, 도구를 뜻한다.
	+ 설계는 요구사항을 코드 작성과 디버깅에 연결하는 작업이다.
		+ 훌륭한 상위 수준 설계는 여러 개의 하위 수준 설계를 무리 없이 담을 수 있는 구조를 제공한다.
		+ 훌륭한 설계는 규모가 큰 프로젝트에서 꼭 필요한 작업이며 작은 프로젝트에서도 유용하다.

&emsp;&emsp;

## 설계는 불명확한 문제이다.

+ 설명
	+ 호스트 리텔과 멜빈 웨버는 불명확한 문제란 전체 혹은 일부를 해결해야만 정의할 수 있는 문제라고 정의했다고 한다.
		+ 본질적으로 역설적인 이 문구는 문제를 명확히 정의하기 위해서는 한번 해결해야할 필요가 있다는 뜻이며 작동하는 솔루션을 만들기 위해서도 다시 문제를 해결해야한다는 의미를 담는다.
		+ 이러한 프로세스는 소프트웨어 개발에서 수십 년 동안 내려온 오랜 관습이다.
	+ 다리를 다 짓고나서야 다리를 다시 짓게 만든 문제를 추가로 고려해야하는 경우가 있었다. (타코마 다리)
		+ 과제로 프로젝트를 수행하다보면 설계 이후에 갑자기 과제를 바꾸는 교수가 있다면 욕을 먹을 것이다.
		+ 현실은 이것과 동일하다.

&emsp;&emsp;

## 설계는 엉성한 프로세스이다.

+ 설명
	+ 완성된 소프트웨어 설계는 정돈되어 있고 깔끔해 보여야 하지만 설계 과정은 최종 결과물처럼 깔끔하지 않다.
	+ 설계하면서 잘못된 길로 들어설수도 있고 실수도 많이 하기 때문에 설계는 뭔가 좀 엉성하다.
		+ **사실 실수를 하는 것이 설계의 핵심이다.**
		+ 설계 단계에서 실수하고 고치는 것이 똑같은 실수를 코드 작성 후에 발견하여 코드를 수정하는 것보다 비용이 적게 든다.
	+ 설계는 훌륭한 해결책과 그렇지 않은 해결책의 차이가 크지 않은 경우가 많아서 설계를 엉성하다고 말하기도 한다.
	+ 설계는 충분한 상태를 알기 어렵기 때문에 엉성해 보이기도 한다.
	+ 설계는 얼마나 구체적이어야 할까? 설계를 공식 설계 표기법을 얼만큼 작용해 작성하고, 얼마나 코드 작성의 몫으로 남겨둬야 할까? 설계를 언제 끝내야할까?
		+ 설계는 완성되는 시점이 분명하지 않으며 가장 흔한 대답은 더 이상 시간이 없을 때까지이다.

&emsp;&emsp;

## 설계는 절충과 우선순위의 문제이다.

+ 설명
	+ 이상 세계라면 모든 시스템은 즉시 실행 가능하며 저장 공간을 사용하지 않으며 네트워크 대역폭을 사용하지 않고 오류도 없는 데다 구축하는 데 비용도 없을 것이다.
	+ 현실 세계에서는 설계자의 주요 업무 중 하나가 서로 상충하는 설계 특징을 비교하여 그 특성들 사이의 균형을 맞추는 일이다.
		+ 예시로 빠른 응답 속도가 개발 시간을 최소화하는 것보다 중요하다면 설계자는 그에 맞는 설계를 선택할 것이다.
		+ 아니면 개발 시간을 최소화하는 것이 가장 중요하다면 좋은 디자이너는 그 목적에 맞게 다른 설계를 작성할 것이다.

&emsp;&emsp;
## 설계에는 제약이 따른다.

+ 설명
	+ 설계의 핵심은 어느 정도는 가능성을 만들고 어느 정도는 가능성을 제한한다는 데에 있다.
		+ 물리적으로 어떤 구조물을 짓는 데 필요한 시간과 자원, 공간이 무제한 있었다면 신발 한 짝마다 보관할 방을 하나씩 만들고 방이 수백 개인 엄청나게 넓은 빌딩을 지을 것이다.
	+ 계획적으로 제약 사항을 두지 않으면 소프트웨어 역시 이와 같은 결과를 낳을 것이다.
		+ 빌딩을 지을 때 자원이 제한적이라는 제약 사항 덕분에 좀 더 간결한 해결방안을 고안할 수밖에 없고 그 결과 더 나은 해결책이 나온다. 물론 소프트웨어 설계도 마찬가지이다.


&emsp;&emsp;

## 설계는 비결정적이다.

+ 설명
	+ 세 사람에게 같은 문제를 설계하도록하면 서로 완전히 다른 설계를 내놓겠지만 모두 충분히 쓸만할 것이다.
	+ 어떤 목적을 달성하는 방법은 한 가지이상일 수도 있지만 컴퓨터 프로그램의 경우에는 보통 수십가지에 이른다.

&emsp;&emsp;

## 설계는 발견적 학습 과정이다.

+ 설명
	+ 설계는 비결정적이기 때문에 설계 기법은 예상된 결과를 만들어내는 반복적인 처리과정이라기 보단 발견적 학습(경험 법칙, 작동하는지 시도해보는 것)이라고 할 수 있다.
	+ 설계는 시행착오가 따르며 어떤 작업에서 효과가 있던 설계 툴이나 기법이 다음 프로젝트에서는 효과가 없을 수도 있다.
	+ 만능 도구는 없다.

&emsp;&emsp;

## 설계는 창발적이다.


+ 설명
	+ 설계의 이런 특성들은 설계가 창발적이라는 말로 깔끔하게 요약할 수 있다.
		+ 설계는 누군가의 머릿속에서 완전한 형태로 갑자기 솟아나오지 않는다.
		+ 설계는 설계 검토와 격식 없는 토론, 코드 작성 경험 자체, 코드 수정 경험을 통해 진화하고 발전한다.
	+ 실질적으로 모든 시스템은 초기 개발 과정에서 어느 정도 설계 변경 절차를 거치게 되며 그 후 보통 애초에 예상했던 것보다 훨씬 많은 내용이 변경된다.
		+ 어느 정도까지 변경하는 것이 이로운지 혹은 타당한지는 만드는 소프트웨어 종류에 따라 달라진다.

<br>

# 핵심 설계 개념

&emsp;&emsp;

## 소프트웨어의 주요 기술적 의무: 복잡성 관리

&emsp;&emsp;

### 본질적 어려움과 비본질적 어려움

+ 설명
	+ 복잡성 관리의 논문을 쓴 브룩스의 의견에 따르면 소프트웨어 개발이 어려운 이유는 본질적이고 우연에 기인하는 서로 다른 문제 때문이라고 주장했다.
		+ 브룩스는 아리스토텔레스 시절의 철학에서 두 용어를 가져왔다. 
		+ 본질적인 속성 
			+ 어떠한 사물이 그러한 사물이 되기 위해서 반드시 가져야 하는 속성이다.
		+ 비본질적인 속성
			+ 특정 사물을 일컬을 때 그것이 무엇이라고 결정하는 데 영향을 끼치지 않는 우연의 산물이다.
			+ 예시
				+ 4기통 터보엔진, V8 자동차든 다른 엔진이 장착된 자동차든 엔진의 종류와 상관없이 자동차라고 말할 수 있다.
				+ 이런 세부 사항을 가리켜 비본질적인 속성이라고 부른다.
			+ 부수적이고 임의적이며 추가적이고 우연한 것으로 생각할 수도 있다.
	+ 브룩스는 소프트웨어에서의 중요한 비본질적인 어려움이 오래 전에 해결되었음을 발견했다.
		+ 예시
			+ 쓰기 불편한 언어 문법과 관련된 비본질적인 어려움은 어셈블리어에서 3세대 언어로 진화하는 과정에서 급격하게 줄었다.
			+ 비대화식 컴퓨터와 관련된 비본질적인 어려움은 시분할 운영체제가 배치 모드 시스템을 대체했을 때 해결되었다.
	+ 브룩스는 소프트웨어에 남아있는 본질적인 어려움은 느리게 해결될 수 밖에 없다고 주장한다.
		+ 소프트웨어 개발이 본질적으로 매우 복잡하고 서로 연관된 개념들에 관한 세부 사항들을 해결하는 작업이기 때문이다.
		+ 소프트웨어 개발이 갖는 본질적인 어려움은 복잡하고 무질서한 현실 세계와 상호작용하고, 종속 관계와 예외 상황들을 정확하고 완벽하게 규명하며 대충이 아니라 정확히 맞는 솔루션을 설계해야하기 때문에 발생한다.
		+ 실제 세계의 문제점과 정확하게 같은 용어를 사용하는 프로그래밍 언어를 개발한다고 하더라도 실제 세계가 어떻게 돌아갈지 정확히 판단하는 문제 때문에 프로그래밍은 여전히 어려울 수 밖에 없다.
		+ 소프트웨어가 매우 큰 실제 세계의 문제를 해결하고있고 현실 세계에서 사물 간 상호작용이 매우 복잡해짐에 따라 소프트웨어 솔루션의 본질적인 어려움 또한 오히려 증가했다.
	+ 이 본질적인 어려움의 근원은 본질적이고 비본질적인 복잡성 때문이다.

&emsp;&emsp;

### 복잡성 관리의 중요성

+ 설명
	+ 소프트웨어 프로젝트 보고서에서 프로젝트 실패의 원인을 보고할 때 기술적인 이유로 프로젝트가 실패했다고 보고하는 경우는 거의 없다.
		+ 대부분 실패한 프로젝트는 요구사항, 계획 수립, 관리가 부족해서 발생한다.
		+ 하지만 프로젝트가 기술적인 이유로 실패한 경우에는 그 원인을 복잡성 관리 부족에서 찾을 수 있다.
	+ 소프트웨어는 무슨일이 일어나는지 아무도 모를 정도로 복잡성이 증가할 수 있다.
		+ 프로젝트에서 한 영역의 코드를 변경했을 때 다른 부분에 영향을 미치는지 완벽하게 이해하는 사람이 없을 정도라면 더 이상 개발을 할 수 없는 지경에 이른 것이다.
	+ 복잡성 관리는 소프트웨어 개발에서 가장 중요한 기술적 주제이다.
		+ 개인적으로 소프트웨어의 주요 기술적 의무는 복잡성을 관리하는 것이라고 생각한다.
	+ 복잡성은 소프트웨어 개발의 새로운 특징이 아니다.
		+ 컴퓨터 분야의 선구자인 다익스트라는 컴퓨팅은 그저 1비트에서 수백 메가비트 (1~10^9)차이에 온통 집중해야하는 작업이라고 지적했다.
			+ 이 비율은 어마어마한 값이며 의미적 층위 측면에서 보면 보통의 수학 공식은 층위가 없고, 심오한 개념적인 계층 구조에 대한 필요로 인해 컴퓨터는 인류에게 유례없는 새로운 본질적인 문제들을 제시했다고 말했다.
	+ 다익크스트라는 현대 컴퓨터 프로그램을 보관할 수 있을 정도의 큰 두뇌를 가진 사람은 아무도 없다고 지적했는데 곧 소프트웨어 개발자가 전체 프로그램을 억지로 한 번에 머릿속에 밀어 넣으려고 해서는 안 된다는 뜻이다.
		+ 따라서 한 번에 한 부분을 제대로 집중할 수 있게 프로그램을 구성하도록 노력해야 한다.
		+ 목표는 한 번에 생각해야하는 프로그램의 크기를 최소화 하는 것이다.
			+ 저글링과 비슷하다고 보면 된다.
	+ 소프트웨어 아키텍처 레벨에서는 시스템을 서브시스템으로 나누어 문제의 복잡성을 줄인다.
		+ 인간은 하나의 복잡한 부분보다 여러 개의 간단한 정보를 더 빠르게 이해한다.
		+ **모든 소프트웨어 설계 기법의 목표는 복잡한 문제를 간단하게 나누는 것이다.**
			+ 즉, 서브 시스템이 각기 독립적일 수록 한 번에 복잡한 부분의 일부에 집중하기가 더 좋다.
			+ 객체를 신충하게 정의함으로써 한번에 하나의 기능에만 집중하도록 작업을 나눈다.
			+ 패키지도 더 높은 수준의 통합이라는 장점을 제공한다.
	+ 루틴을 짧게 유지하면 신경쓸 부분이 줄어든다.
		+ 저수준의 상세 구현보다는 문제 범위 면에서 프로그램을 작성하고 추상성을 최대화하여 작업하면 뇌에 부담이 줄어든다.
	+ 결론적으로 인간의 선천적인 한계를 보완할 줄 아는 개발자는 자신뿐만 아니라 다른 사람도 이해하기 쉽고 오류가 적은 코드를 작성한다.

&emsp;&emsp;

### 복잡성을 해결하는 방법

+ 설명
	+ 지나치게 비용이 많이 드는 설계의 발생 경우
		+ 간단한 문제를 복잡하게 해결하는 경우
		+ 복잡한 문제를 단순하게 잘못된 방법으로 해결하는 경우
		+ 복잡한 문제를 부적절하고 복잡하게 해결하는 경우
	+ 다익크스트라가 지적했듯, 오늘날에는 소프트웨어는 태생적으로 복잡하고 아무리 노력해도 결국 현실 세계의 문제가 내포하는 본질적인 복잡성과 마주하게 된다.
	+ 복잡성 관리 접근 방법
		+ 두뇌가 한 번에 처리해야하는 본질적인 복잡성의 양을 최소화한다.
		+ 비본질적인 복잡성이 불필요하게 증가하지 않도록 한다.
	+ 일단 소프트웨어에서 복잡성을 관리하는 것이 다른 기술적인 목표를 달성하는 것보다 중요하다는 점을 이애하고 있다면 설계시 무엇을 고려할지 분명해진다.


&emsp;&emsp;

## 바람직한 설계의 특징

+ 설명
	+ 뛰어난 설계는 공통적인 특징이 존재하며 모두 충족해야 매우 훌륭한 설계라고 할 수 있다.
		+ 이중 몇가지 목표는 다른 목표와 상충하는 면이 있어 설계 단계에서 적절히 균형을 맞추기 위한 방안을 마련해야하는 어려움이 따른다. 
		+ 신뢰성이나 성능과 같은 설계의 품질에 대한 몇 가지 특징은 훌륭한 프로그램이 갖는 특징이기도 하다.
	+ 내부 설계의 특징
		+ 복잡성 최소화
			+ 설계의 일차적인 목표는 앞에서 설명한 것과 같이 복잡성을 최소화하는 것이어야 한다.
				+ 재치 있는 설계는 피하고 간단하고 이해하기 쉬운 설계를 만들어라
			+ 특정부분을 살펴볼때 다른 부분도 함께 살펴봐야한다면 이는 잘못된 설계일 확률이 높다.
		+ 유지보수의 편리함
			+ 유지보수가 편리하다는 것은 유지보수 개발자를 위해 고려한 설계라는 뜻이다.
		+ 느슨한 결합
			+ 느슨한 결합은 프로그램의 각 부분 사이의 연결을 최소화하도록 설계하는 것을 의미한다.
			+ 클래스 사이의 연결을 최소화하기 위해 클래스 인터페이스에서의 추상화, 캡슐화, 정보 은닉과 같은 방법을 사용한다.
			+ 연결을 최소화하면 통합이나 테스트, 유지보수의 작업을 최소화할 수 있다.
		+ 확장성
			+ 확장성은 내부 구조를 해치지 않고 시스템의 기능을 개선할 수 있다는 뜻이다.
			+ 다른 부분에 영향을 미치지 않고 시스템 일부분을 변경할 수 있다.
			+ 예측 가능한 변경사항을 미리 고민하면 시스템에 입히는 충격을 최소화할 수 있다.
		+ 재사용성
			+ 재사용성은 현재 시스템의 일부를 다른 시스템에도 다시 사용할 수 있도록 시스템을 설계하는 것을 의미한다.
		+ 높은 팬인(fan-in)
			+ 높은 팬인은 특정 클래스를 사용하는 클래스의 수가 많다는 것을 의미한다.
			+ 높은 팬인은 시스템이 유틸리티 클래스를 잘 활용하도록 설계되었다는 것을 의미한다.
		+ 낮은 팬아웃(fan-out)
			+ 낮은 팬아웃은 특정 클래스가 다른 클래스를 적개 사용한다는 것을 의미한다.
			+ 높은 팬아웃은 한 클래스가 다른 클래스를 여러개 사용하는 것을 의미하며 매우 지나친 복잡도에는 보통 높은 팬아웃이 발견된다.
			+ 낮은 팬아웃 법칙은 루틴 내에서 호출되는 루틴 수나 클래스 내에서 사용되는 클래스의 수를 계산할 때 유용하다
		+ 이식성
			+ 이식성은 시스템을 다른 환경에 쉽게 이동하여 설치할 수 있도록 설계하는 것을 의미한다.
		+ 간결성
			+ 간결성은 불필요한 부분 없이 시스템을 설계하는 것을 의미한다.
				+ 보통 한 권의 책이 완성될 때는 더이상 쓸 내용이 없는 경우가 아닌 뺄 내용이 없는 경우라고 한다.
				+ 소프트웨어또한 어떤 코드를 수정하면 다시 개발하고 검토하고 테스트하고 확인해야한다.
				+ 소프트웨어의 차기 버전은 반드시 나머지 코드와 하위 호환성을 유지해야한다.
				+ '기능을 추가하기 쉬운데 추가시 발생할 상황은 무엇인가?' 라는 질문이 자연스레 나와야 간결성을 유지했다고 볼 수 있다.
		+ 계층화
			+ 시스템에 대해 특정한 계층에서 바라보고 일관되게 이해할 수 있도록 분산 계층을 유지하는 것을 의미한다.
			+ 시스템을 다른 계층으로 보지 않고도 특정 계층에서 볼 수 있도록 설계해야 한다.
			+ 예시
				+ 오래되고 잘못 설계된 코드를 많이 사용해야하는 시스템을 개발하고 있다면 새 시스템에 대해 이전 코드와 조화를 이룰 수 있는 계층을 만들어야 한다.(이것을 어뎁터 패턴으로 주로 해결한다.)
					+ 어뎁터 패턴은 이전 코드의 잘못된 점을 감출 수 있도록 해당 계층을 설계해 새로만든 계층에 일관성 있는 서비스를 제공한다.
					+ 그리고 시스템의 나머지 부분에서는 이전 코드가 아닌 새로운 클래스를 사용하게 한다.
					+ 이 경우 잘못된 코드가 불러오는 혼란을 방지하며 이전 코드를 버리거나 재구성할 수 있는 여건이 되었을 때 해당 인터페이스 계층을 제외한 어떠한 코드도 변경할 필요가 없다.
		+ 표준 기법들
			+ 시스템이 색다른 방법에만 의존할 수록 다른 사람이 처음에 코드를 이해하기 더 어려워질 것이다.
			+ 표준화되고 일반적인 접근 방법을 시스템에 기용해 전체 시스템이 친숙해지도록 만들어야 한다.

&emsp;&emsp;

## 설계 레벨

+ 설명
	+ 하나의 시스템에도 여러 상세 수준(이하 레벨)이 존재하는데 각 상세 레벨마다 설계가 필요하다.
	+ 몇몇 설계 기법은 모든 레벨에 적용이 가능하지만 몇몇은 한두 가지 경우에만 적용이 가능하다.

![[스크린샷 2023-10-16 오후 8.25.18.png]]

&emsp;&emsp;

### 설계 레벨 1: 소프트웨어 시스템

+ 설명
	+ 최상위 레벨이며 어떤 개발자들은 바로 시스템 레벨이나 클래스 설계로 넘어가기도 하지만 시스템 레벨은 서브시스템이나 패키지 같은 상위 레벨 클래스 조합을 충분히 생각하는 데 도움을 준다.

&emsp;&emsp;

### 설계 레벨 2: 서브시스템이나 패키지로 분할

+ 설명
	+ 중요한 핵심 사항
		+ 먼저 모든 중요한 서브시스템을 식별하는 것이 중요하다.
			+ 서브 시스템은 데이터베이스, 사용자 인터페이스, 비즈니스 규칙, 명령 해석기, 보고서 엔진과 같이 클 수도 있다.
		+ 프로그램을 주요 서브시스템으로 어떻게 나눌 것인지, 각 서브시스템이 다른 서브시스템을 어떻게 사용하게 할 것인지 결정하는 것도 중요하다.
		+ 이 레벨의 분할은 일반적으로 몆 주 이상 소요되는 모든 프로젝트에 필요하며 시스템의 각 부분에 가장 적합한 방법을 선택해 서브시스템마다 서로 다른 설계 방법을 사용할 수 있다.
		+ 이 레벨에서는 서로 다른 서브 시스템이 서로 어떻게 소통할 것인지에 대한 규칙을 정하는 것이 중요하다.
			+ 모든 서브 시스템이 다른 모든 서브시스템과 소통할 수 있다면 그것을 나눔으로써 얻는 장점이 없어질 것이다.
			+ 커뮤니케이션을 제한하여 각 서브시스템을 의미있게 만들어야 한다.
		+ 규칙이 없으면 서브시스템간 막무가내로 커뮤니케이션이 발생하여 복잡성이 말도안되게 증가한다.
			+ **따라서 서브시스템간 소통은 서로 알 필요가 있는 경우에만 가능하게 만들어야 한다.**
			+ **확신이 안서면 우선 소통을 제한하고 나중에 필요한 경우 완화하는 것이 훨씬 편하다.**
		+ 상호 연결관계를 이해하고 유지하기 쉽게 하려면 내부 서브시스템의 관계를 간단하게 만든다.
			+ 가장 간단한 관계는 하나의 서브시스템이 다른 서브시스템에 있는 루틴을 호출하는 것이다.
			+ 가장 복잡한 관계는 한 서브시스템에 있는 클래스가 다른 서브 클래스에 있는 클래스를 상속받는 것이다.
		+ **서브시스템끼리 순환 구조를 갖지 않도록 만드는 것 또한 중요하다.**
		+ 규모가 큰 프로그램이나 프로그램군에서는 서브시스템 수준의 설계가 중요한 차이를 만든다.
			+ 아주 규모가 작은 경우에 한해서만 이 레벨 설계를 넘기는 것이 가능하다.
	+ 예제의 서브시스템간 커뮤니케이션시 고려 사항
		+ 개발자가 특정 서브시스템에서 무언가 변경하기 위해서 전체 시스템에서 얼마나 많은 부분을 이해하고 있어야 할까?
		+ 다른 시스템에서 비즈니스 규칙을 사용하려고 할 때 무슨 일이 발생할까?
		+ 시스템에 테스트를 위한 명령줄 UI 같은 새로운 기능을 추가하고자하면 어떤일이 벌어질까?
		+ 원격 기기에 데이터를 저장하고 싶다면 어떤 일이 발생할까?
	+ 공통 서브시스템
		+ 몇몇 서브 시스템은 서로 다른 시스템에서 계속 나타난다.
		+ 공통 서브시스템 예시
			+ 비즈니스 규칙
				+ 컴퓨터 시스템에 입력하는 법률과 규칙, 정책, 절차를 의미한다.
				+ 이런 규율, 규칙은 공공기관 시스템이나 법률 관련 시스템이 아닌 경우 보통 운영 정책, 절차등이 들어가는데 이런 경우에는 기획에서 내려주는 요구사항 명세가 가장 중요하다.
				+ 보통 이런 서브시스템은 \~Policy라는 이름으로 작명해 하나의 Policy 패키지로 관리하는편인데 작은 시스템의 경우 없는 경우도 많지만 중간 규모 이상의 경우 일반적으로 추가하는 것이 보편적이다.
				+ 예시
					+ 급여 시스템의 경우 국세청에서 얻은 원천세 공제와 예납 세율에 대한 규칙을 입력할 것이고 초과 근무 수당, 휴일과 공휴일 수당등을 명시한 조합규약에서 가져올 수 있다.
					+ 자동차 보험료 계산 시스템의 경우 필수 책임 보험이나 보험 통계 비율표, 인수 제한 사항을 정부 규정에서 가져올 것이다.
			+ 사용자 인터페이스
				+ 유저 인터페이스는 프로그램의 나머지 부분에 지장을 주지 않고 발전할 수 있도록 유저 인터페이스 컴포턴트를 고립시키는 서브시스템으로 개발한다.
				+ GUI는 물론 CLI, 메뉴 처리, 윈도우 관리, 도움말 시스템등에 대한 여러 개의 종속적인 서브시스템이나 클래스를 사용한다.
				+ 오늘날에는 이것을 View 레이어로 구분짓는다.
			+ 데이터베이스 접근
				+ 데이터베이스 접근에 대한 구현 세부사항을 감춰 프로그램 대부분이 저수준 구조체를 다루기 위한 복잡한 세부 사항에 대해서 걱정할 필요가 없게 만들고 비즈니스 수준에서 사용되는 형태로 데이터를 처리할 수 있다.
				+ 구현 세부사항을 감춘 서브시스템은 프로그램의 복잡성을 줄여주는 유용한 추상화 수준을 제공한다.
				+ 이런 서브시스템은 데이터베이스 연산을 한곳에 집중시키고 데이털르 다룰 때의 오류 발생 가능성도 줄인다.
				+ 프로그램 대부분을 변경하지 않고도 데이터베이스 설계 구조를 쉽게 바꿀 수 있다.
				+ 오늘날에는 레이어를 나눠 비즈니스 로직을 넣은 서비스 레이어, 데이터를 정의하고 접근을 하고 제어하는 데이터베이스 접근 레이어, 각종 호출등을 처리하는 컨트롤러 레이어로 나눠서 진행한다.
			+ 시스템 의존성
				+ 하드웨어의 의존성을 패키지화 하는 것과 같은 이유로 운영체제에 대한 의존성을 서브시스템으로 패키지화 한다.
				+ 보통 이런 서브시스템은 다른 OS의 API를 연결하는 공통 인터페이스를 만들고 구현을 하는 편이다.
				+ 이때 이 서브시스템 구현체만 갈아 끼우면 원하는 OS에서 공통 인터페이스를 통한 동일한 동작을 예상하고 이용할 수 있다.
				+ 요즘은 이런것들도 다 표 준 라이브러리로 추상화하여 만들어둔 경우가 대다수이긴해서 넘겨도 되는 영역이긴하다.

&emsp;&emsp;

### 설계 레벨 3: 클래스로 분할

+ 설명
	+ 이 수준의 설계에는 시스템에 필요한 모든 클래스를 구체화하는 작업이 들어간다.
	+ 예시
		+ 데이터베이스 - 인터페이스 서브시스템은 데이터베이스의 메타데이터뿐만 아니라 데이터 접근 클래스와 지속성 프레임워크 클래스로 나눌 수 있다.
			+ 위의 그림에서 레벨 2의 서브시스템 하나가 어떻게 클래스로 나뉘는지 보여주며 이것은 곧 레벨 2에 있는 다른 세 걔의 서브시스템도 클래스로 분리된다는 의미이다.
	+ 각 클래스가 시스템의 나머지 부분과 상호작용하는 방법에 대한 세부적인 사항도 클래스에 명시되어야 한다.
		+ **특히 클래스의 인터페이스가 정의된다.**
		+ 전반적으로 이 단계에서 가장 중요한 작업은 개별적인 클래스로 구현할 수 있을 만큼 자세한 수준으로 모든 서브시스템을 확실하게 분해하는 것이다.
	+ 일반적으로 며칠 이상 걸리는 프로젝트라면 서브시스템을 클래스로 나누는 작업이 필요하다.
		+ 프로젝트의 규모가 크다면 레벨 2에서 할 일이 좀 더 분명해지겠지만, 프로젝트의 규모가 작으면 레벨 1의 전체 시스템에 대한 부분만 명시하고 곧바로 레벨 3인 클래스 뷰 구현으로 넘어갈 수도 있다.
	+ 클래스와 객체
		+ 객체지향 설계에서 가장 핵심적인 개념은 객체와 클래스의 차이를 이해하는 데애 있다.
			+ 객체
				+ 실행중인 프로그램에 존재하는 구체적인 엔티티
				+ 프로그램을 실행시 생성되는 특정한 값과 속성을 갖는 동적인 것
			+ 클래스
				+ 프로그램 코드로 정적이다.

&emsp;&emsp;

### 설계 레벨 4: 루틴으로 분할

+ 설명
	+ 클래스를 루틴으로 나누는 레벨이다.
		+ 레벨 3에서 정의한 클래스 인터페이스가 몇 가지 루틴을 정의할 것이다.
	+ 레벨 4에서는 비공개 루틴을 상세히 설계한다.
		+ 클래스 내부에 있는 루팅 상세 부분을 살펴보면 간단한 루틴도 많지만 계층적으로 구성되어 있어 좀 더 자세한 설계가 필요한 루틴도 있는 것을 알 수 있다.
	+ 클래스의 루틴을 완전하게 정의하는 작업을 통해서 클래스의 인터페이스에 대해 더 잘 이해하게 되면 인터페이스도 그것에 맞게 변경해야하는 경우가 생긴다.
		+ 이런 경우는 레벨 3으로 돌아가서 수정해야한다는 의미이다.
	+ 이 단계의 분할과 설계는 종종 개별 개발자가 수행하는 몇 시간 정도 걸리는 프로젝트에서도 반드시 실행되는 작업이다.
		+ 형식적으로 하지 않더라도 머리속에서라도 해야한다.


&emsp;&emsp;

### 설계 레벨 5: 내부 루틴 설계

+ 설명
	+ 이 단계의 설계에서는 각 루틴의 상세한 기능을 구현한다.
		+ 내부 루틴 설계는 일반적으로 개별적인 루틴을 개발하는 개발자의 몫이다.
		+ 설계는 의사코드를 작성하고 참고 서적에서 알고리즘을 살펴보고 루틴 내의 코드 단락을 어떻게 구성할 것인지를 결정하고 프로그래밍 언어 코드로 작성하는 활동으로 구성된다.
	+ **이 단계는 항상 무조건 수행이 되는 단계이지만 의식적으로 잘하기 보다는 무의식적으로 엉터리로 하는 경우가 많다.**
	+ 만약 TDD로 수행된다고 한다면 중간에 테스트 코드 작성 단계가 추가된다.
		+ 즉, 1, 2, 3, 4, 5단계로 진행하는 것이 아닌 전체적으로 1, 2 단계만 진행하고 서브시스템별이나 기능 별, 요구사항 기능 단위 별(이 경우가 대부분이다)로  테스트 코드를 우선 작성한 뒤 3, 4, 5를 진행하는 것이다.
		+ 테스트 코드 작성 당시 당연히 실제로 구현하지 않은 클래스들 뿐이니 IDE에 빨간 줄로 도배되어 실패할 수밖에 없다.
			+ 이 상태에서 성공할 수 있도록 레벨 3부터 진행하는 것이다. 
		+ 이것이 TDD를 운용하는 과정이며 실패 테스트 코드 작성 상태를 레드, 통과하는 상태를 그린으로 부르며 이 레드와 그린을 오가는 시간을 최대한 단축하는 것에 몰두하는 것이 생산성을 높이는 방법이다.


<br>

# 설계 빌딩 블록: 발견적 학습

+ 설명
	+ 소프트웨어 개발자들은 다음과 같이 틀에 박힌 답변을 좋아하는 경향이 있다.
		+ A와 B와 C의 결과는 언제나 X, Y, Z일 것이다.
		+ 개발자는 기대하는 결과를 만들어내는 비밀스러우느 단계를 학습하는 것에 큰 자부심을 느끼고 있고 어떤 명령이 배운 대로 작동하지 않으면 짜증을 낸다.
		+ 이런 결정론적인 사고방식은 상세 프로그래밍에 매우 적합해 상세 사항에 엄격한 주의를 기울이냐에 따라 프로그램이 작동할 수도, 작동하지 않을 수도 있다.
		+ 하지만 소프트웨어 설계는 이와 상당히 다르다.
	+ 설계에는 정답이 존재하지 않아 좋은 소프트웨어 설계를 위해서 발견적 학습(경험이론)을 효과적으로 적용해야한다.

&emsp;&emsp;

## 현실 세계의 객체를 찾아라

+ 설명
	+ 설계의 대안을 규명하는 최초이자 가장 널리 알려지 방법은 정석대로의 객체지향적 접근 방법으로 현실 세계의 객체와 가상의 객체를 찾는 것에 초점을 맞춘다.
	+ 아래의 객체 설계 단계는 꼭 순서대로 진행되는 편은 아니며 종종 반복 수행한다.
	+ 최상위 레벨의 객체지향 시스템을 구성하기 위해서 소개할 단계를 마치고 나면 두 가지 과정을 반복하게 되는데 더 나은 클래스 구성을 얻기 위해 최상위 레벨의 시스템 구성을 반복하여 진행할 테고, 지금까지 정의한 각 클래스를 더 상세하게 설계하는 작업을 반복할 것이다.
	+ 객체 설계 단게
		1. 객체와 객체의 속성(메서드와 데이터)을 식별한다.
		2. 각 객체에 무엇을 할 수 있는지 결정한다.
		3. 각 객체가 다른 객체에 무엇을 할 수 있는지 결정한다.
		4. 각 객체에서 다른 객체에 보일 부분을 결정한다.
		5. 각 객체의 공개 인터페이스를 정의한다.

+ 객체 설계 단계별 설명
	+ 객체와 객체의 속성을 식별
		+ 컴퓨터 프로그램은 대개 현실세계의 엔티티에 기반을 둔다.
		+ 객체를 식별하면 객체의 속성을 찾는 것은 어렵지 않으며 각 겍체는 컴퓨터 프로그램과 관련된 속성을 갖는다.
		+ 예시
			+ 청구 시스템
				+ 직원
				+ 고객
				+ 근무시간 기록표
				+ 청구서
				+ 예시
					![[스크린샷 2023-10-17 오전 11.16.40.png]]
	+ 각 객체에 무엇을 할 수 있는지 결정한다.
		+ 각 객체에 다양한 작업을 수행할 수 있다.
		+ 예시
			+ 위의 청구 시스템에서는 직원 객체는 직함이나 청구율을 변경할 수 있고 고객 객체는 이름이나 청구서 배달 주소 등을 변경할 수 있다.
	+ 각 객체가 다른 객체에 무엇을 할 수 있는지 결정한다.
		+ 통상 객체가 서로에게 할 수 있는 두 가지 사항은 포함과 상속이다.
		+ 위의 청구 시스템에서 시간 기록표는 직원 객체와 고객 객체를 포함할 수 있으며 청구서 객체는 하나 이상의 시간 기록표 객체를 포함할 수 있다.
			+ 청구서 객체는 고객에게 청구할 수 잇고 고객은 해당 청구서에 대한 요금을 지불할 수 있다.
			+ 더 복잡한 시스템에는 상호작용이 추가로 더 많이, 거기에 policy까지 포함하여 추가된다.
	+ 각 객체에서 다른 객체에 보일 부분을 결정한다.
		+ 설계시 객체의 어느 부분을 상호에게 공개하고 어느 부분을 비공개로 유지해야하는 지를 파악하는 것은 가장 중요한 결정 중 하나이다.
		+ 이는 데이터, 메서드 둘다 해당된다.
	+ 각 객체의 인터페이스를 결정한다.
		+ 각 객체에 대해 형식적이고 이해하기 쉬운 프로그래밍 언어 수준의 인터페이스를 정의한다.
		+ 해당 객체가 다른 모든 객체에 노출하는 데이터와 메서드를 객체의 공개 인터페이스라고 부른다.
		+ 객체가 상속을 통해 파생된 객체에 노출하는 부분을 객체의 보호 인터페이스라고 부른다.
		+ 서로 다른 인터페이스 차이점을 파악해야한다


&emsp;&emsp;

## 일관성 있게 추상화하라

+ 설명
	+ 다른 레벨에 있는 서로 다른 세부 사항을 다루지만 세부사항을 무시해도 문제가 없는 개념과 맞물리는 능력을 추상화라고 한다.
	+ 집합체(aggregate)라는 개념을 도입해 작업할 때 추상화를 통해 작합하고 있다고 말할 수 있다.
		+ 어떤 물체를 유리, 나무, 못의 결합을 집이라고 부른다면 추상화를 한 것이다.
		+ 집이 모여있는 집합을 마을이라고 한다면 그 또한 추상화를 한 것이다.
	+ 기초 클래스(base class, C++ 계열에서는 이렇게 부른다.)는 기초 클래스에 대해 작업할 때 상속받은 클래스가 갖는 공통 특성틀에 집중하고 다른 세부사항은 무시하기 위해 만들어진 추상화이다.
		+ 좋은 클래스 인터페이스는 클래스의 내부 작업에 신경 쓰지 않고 인터페이스에 집중하게 해주는 추상화이다.
		+ 잘 설계된 루틴에 대한 인터페이스는 저수준 세부 사항과 동일한 혜택을 제공하며 잘 설계된 패키지나 서브시스템에 대한 인터페이스는 고수준 세부 사항의 이득을 제공한다.
	+ 복잡성 관점에서 보면 추상화의 가장 큰 장점은 관련 없는 세부 사항을 무시할 수 있다는 것이다.
		+ 대부분의 현실 객체는 이미 어느 정도 추상화되어 있다.
			+ 위에서 설명한 집이 그 예시인 추상체이다.
	+ 사람들은 끊임없이 추상화를 한다.
		+ 문도 추상체이고, 집도 추상체이고, 섬유도 추상체이고, 옷도 추상체이다.
	+ 때로는 소프트웨어 개발자가 목질 섬유와 니스 분자, 철 분자 수준으로 시스템을 구축하기도 하지만 이러면 복잡성이 지나치게 올라가 논리적으로 관리하기 힘들어진다.
		+ 개발자가 더 큰 프로그래밍 추상화를 제공하지 못하면 집은 커녕 창문조차 만들 수 없게 된다.
	+ 훌륭한 개발자는 루틴 인터페이스 수준, 클래스 인터페이스 수준, 패키지 인터페이스 수준의 단계적인 추상화를 제공해 더 빠르고 안전하게 프로그래밍 할 수 있게 해준다.
	+ 다만 경고로써 적긴하지만 추상화를 굳이 상속으로 표현하는 것보다 포함관계로 만드는 것이 더 안전하고 결합도가 내려간다.
		+ 이후에 나오는 내용이기도 하지만 알아두는게 좋다.
		+ 심지어 제임스 고슬링은 상속을 만든 것을 후회하기도 했다.

&emsp;&emsp;

## 구현 세부 사항을 캡슐화하라

+ 설명
	+ 추상화 다음 캡슐화를 진행한다.
		+ 추상화는 높은 레벨에서 내려다볼 수 있게 하고, 캡슐화는 다른 레벨에서 해당 객체를 특정 수준 이상으로 볼 수 없도록 하는 것이다.
	+ 캡슐화는 집의 외관을 볼 수 는 있지만 문의 재료가 무엇인지 알수 있을 만큼 가까이 접근할 수 없다는 개념이다.
	+ 복잡한 부분을 보지 못하게 함으로써 복잡성을 관리하는데 도움을 준다.
	+ 사실 이런 접근 제한 기능은 협업에 도움을 주는 기능이라고 보는게 좀 더 맞긴하다.
		+ 협업을 하지 않고 혼자서 개발한다면 이런 기능은 없어도 상관없다.
		+ 다만 이런 기능을 추가하면 다른 사람이 개발을 하더라도 쓸때 없이 내가 개발한 코드를 굳이 들여다보지 않고도 가져다 쓰게 만들거나 루틴을 함부로 수정하지 못하도록 만드는 것이 가능하니 언어 차원에서 결국 집어 넣어주게 된 기능이다.
		+ 초창기 C가 핫하게 사용되던 시절에는 이런 기능이 없어서 툴 플러그인을 사람들끼리 만들어서 컴파일 이전 단계 차원에서 방지했지만 이는 결국 후속 객체 지향언어에서는 모두 추가하게된 아주 기본적인 기능이 되었다.

&emsp;&emsp;

## 상속이 설계를 단순화할 수 있을 때만 상속하라

+ 설명
	+ 소프트웨어 시스템을 설계할 때 약간 다를 뿐 다른 객체들과 상당히 비슷한 객체를 종종 발견하게 될 것이다.
		+ 예시
			+ 회계 시스템
				+ 정규직과 계약직 직원이 있을 것이다.
				+ 두 종류의 직원에 대한 데이터 구성은 비슷하지만 일부는 달라야한다.
				+ 객체 지향 프로그래밍에서는 직원이란 일반적인 타입을 정의하면 일반 직원에 속하면서 몇가지 다른 점을 가진 정규 직원과 역시 일반 직원에 속하면서 몇 가지 다른 저을 가진 계약 직원으로 정의가 가능하다.
				+ 직원에 대한 어떤 작업을 구현할 때 해당 작업이 고용형태와 무관하면 직원을 일반 직원으로 보고 처리한다.
				+ 직원에 따라 작업을 다르게 수행해야한다면 이점 역시 다르게 처리한다.
	+ 위의 예시에서 정규직과 계약직 직원이 일반 직원 타입의 특성을 상속받기 때문에 그러한 객체 사이의 유사성과 차이점을 정의하는 것을 상속이라고 부른다.
	+ 상속은 추상화와 시너지 효과가 있다.
		+ 추상화는 서로 다른 수준에서 객체를 다룬다.
	+ 상속은 프로그래밍을 단순화한다.
		+ 예시
			+ 문
				+ 문의 일반적 특성에 의존하는 것을 처리하는 일반 루틴을 작성한 후 특정 종류의 문에 대한 특정 작업을 처리하는 구체화 루틴을 작성하면 된다.
				+ 실외든, 실내든, 유리문이든, 미닫이문이든, open(), close()는 상관없이 적용될 것이다.
				+ 이런 능력을 다형성이라고 부른다.
	+ 상속은 객체지향 프로그래밍에서 가장 강력한 도구의 하나이다.
		+ 잘사용하면 엄청난 이점이 있고 제대로 사용하지 못하면 큰 손해를 입을 수 있다.
		+ 큰 손해는 높은 결합도를 의미하며 엄청난 이점은 다형성과 적은 타이핑(typing)이다.
		+ 따라서 요즘 추세는 인터페이스를 구성한뒤 이를 구현하는 방식의 단순한 덕 타이핑식 개발방법이 유행이며 상속 자체는 점점 꺼리는 추세이다.
		+ 이런 구조를 IS-A 관계라고 부르며 단순 포함관계는 HAS-A 관계라고 부른다.

&emsp;&emsp;

## 비밀을 숨겨라(정보 은닉)

+ 설명
	+ 정보 은닉은 구조적 설계와 객체지향 설계 모두에 있어 기본적인 부분이다.
		+ 구조적 설계에서는 블랙박스 개념이 정보 은닉에 해당된다.
		+ 객체지향적 설계에서는 정보 은닉을 위해 캡슐화와 모듈성 개념이 생겼고 이는 곧 추상화 개념과 이어진다.
	+ 정보 은닉은 비밀이라는 개념을 특징으로 하며 소프트웨어 개발자가 설계나 구현에서 나머지 프로그램으로부터 한 부분을 숨기기로 결정하는 것이다.
	+ 정보 은닉은 복잡성을 감추는 데 중점을 두고 있고 소프트웨어의 주요기술적 의무에 가장 강력한 발견적 기법이다.

&emsp;&emsp;

### 비밀과 프라이버시

+ 설명
	+ 정보 은닉 관점에서 각 클래스(또는 패키지나 루틴)는 그것을 다른 클래스로부터 숨기는 설계 결정이나 구현 결정으로 특징지어진다.
		+ 그 비밀은 변경이 쉬운 영역일 수도 있고 파일의 포맷이나 데이터 타입이 구현되는 방법, 어떤 영역에서의 오류가 가능한 한 프로그램에 입히는 피해가 작도록 프로그램의 다른 부분으로부터 차단될 필요가 있는 영역이 될 수도 있다.
		+ 클래스의 역할은 이러한 정보들을 숨기고 프라이버시를 보호하는 것이다.
		+ 시스템에서 사소하게 변경된 사항이 클래스 내부의 여러 루틴에 영향을 미칠 수는 있지마 ㄴ클래스 인터페이스를 넘어서는 범위까지 영향을 끼쳐서는 안된다.
	+ 클래스 설계에서 가장 중요한 작업 중 하나는 어떤 기능을 클래스 외부에 알리고 어떤 기능을 비밀로 남길지 결정하는 것이다.
		+ 어떤 클래스가 25개의 루틴이 필요해 사용을 할 때 다섯 개만을 외부로 노출하고 20개는 내부적으로 사용할 수 있다.
		+ 어떤 클래스는 여러가지 데이터 타입을 내부적으로 사용하지만 데이터 타입에 대해 어떤 정보도 노출하지 않을 것이다.
			+ 클래스 설계의 이러한 측면을 가시성이라고 부르며 클래스의 어떤 기능이 외부에 보이는지, 노출되는지와 관련이 있기 때문이다.
	+ 클래스에 대한 인터페이스는 가능한 한 내부작업을 드러내지 않아야 한다. 마치 빙산의 조각을 생각하면 된다.
	+ 클래스 인터페이스 설계도 다른 설계 작업처럼 반복적인 과정이다.
		+ 처음에 제대로 설계하지 못했다면 계속해서 시도하는 것이다.
		+ 그래도 만족스럽지 않다면 다른 접근 방법을 시도해볼 필요가 있다.


&emsp;&emsp;

### 정보 은닉의 예

+ 설명
	+ 각 객체가 id라는 멤버 변수에 저장된 고유한 ID를 가진 프로그램이 있다고 가정해보자
		+ 한가지 설게 방법은 ID로 정수를 사용하고 g_maxID라는 전역변수에 할당된 가장 높은 ID 값을 저장하는 것이다.
		+ 새로운 객체가 할당될 때마다 각 개체의 생성자에 간단히 id = ++ g_maxId문을 사용해 계속 증가하는 고유한 ID를 갖게 할 수 있고 그것으로 객체가 생성된 곳마다 확실히 최소한의 코드를 추가하게 될 것이다.
		+ 이러한 접근 방법에 존재하는 문제점
			+ 특별한 목적으로 특정 ID 범위를 잡아두고 싶은 경우
			+ 보안 향상을 위해 비순차적인 ID를 사용하고 싶은 경우
			+ 삭제한 객체의 ID를 다시 사용하고 싶은 경우
			+ 예상한 최댓값보다 큰 ID값을 할당할 때 오류를 발생시키는 assertion을 추가하고 싶은 경우
			+ 프로그램이 다중 스레드로 개발된 경우
	+ 즉, 새로운 ID가 생성되는 방법은 무조건 숨겨야하는 설계 사항의 예시이다.
		+ 프로그램 전체에 ID = ++ g_maxID를 사용하지 말고 새로운 ID가 g_maxId의 값을 하나 증가시켜 생성된다는 사실을 외부에 노출하게 하면 된다.
			+ 그 대신에 전체 프로그램에서 id = newId()명령 문을 사용하면 새로운 Id의 생성과정을 숨길 수 있고 newId() 루틴 안에 위에서 존재하는 문제점들을 해결하면 자연스레 newId()를 사용중인 모든 호출부에서도 해결이 된다.
				+ 즉, 다른 범위에 영향을 미치진 않는다는 뜻이다.
	+ 만약 ID의 타입을 문자열로 변경해야한다면 newID()는 해결되진 않는다.
	+ 즉, ID의 원시 타입까지도 숨겨야하는 대상인 것이다
		+ 정수라는 타입자체가 노출되면 개발자는 어디에서는 오퍼레이터 연산을 적용해보려할 것이다.
		+ 만약 ID라는 타입으로 래핑하여 다른 정수에서 사용하던 오퍼레이터 연산 대부분을 오버로딩하지 않는다면 (C++의 경우에만 연산자 오버로딩을 지원하는 자유로움이 존재한다.) 의도적으로 변경의 범위를 줄일 수 있는 것이다.
	+ 정보 은닉은 숫자 상수 대신 이름 상수를 사용하는 것부터 데이터 타입의 생성을 비롯해 클래스설계, 루틴 설계, 서브 시스템 설계에 이르기까지 모든 설계 수준에서 유용하다.

&emsp;&emsp;

### 은닉의 두 가지 부류

+ 설명
	+ 정보 은닉 비밀 그룹
		+ 특별하게 관심이 없는 경우에 고민할 필요가 없도록 복잡성을 감추는 것
		+ 변경이 발생했을 때 그 효과가 일부에만 영향을 미치도록 변경의 원인을 감추는 것
	+ 복잡한 데이터 타입, 파일 구조, 참 거짓 테스트, 알고리즘 등이 복잡성의 원인이 된다.
		+ 변경의 원인에 대한 전체적인 목록은 아래에 나열되있다.

&emsp;&emsp;

### 정보 은닉의 장애물

+ 설명
	+ 상황에 따라 정보 은닉이 불가능한 경우가 있지만 정보 은닉을 어렵게 만드는 장애물은 대부분 다른 기법을 사용하던 관행으로부터 형성된 정신적인 장벽이다.

+ 정보 은닉의 장애물 종류
	+ 정보의 지나친 배분
		+ 시스템 전체에 정보를 지나치게 배분하는 것인데 공통 상수값을 여기저기서 사용할때는 확실하게 공통 상수 변수로 만들어 사용하자는 것이다.
		+ 시스템 전체에 유저와 상호작용하는 하는 경우에도 사용자 상호작용을 단일 클래스나 패키지 서브시스템에 모아야 전체 시스템에 영향을 주지 않는다는 것이다.
	+ 순환 의존성
		+ 가장 대표적인 정보 은닉 파괴의 예시이다.
		+ 클래스 A가 클래스 B의 루틴을 호출하고 B에 있는 루틴이 A에 있는 루틴을 호출하면 발생한다.
			+ 서로가 서로 소스에 포함관계가 되선 안된다. 일직선 관계가 되어야한다.
		+ 이 경우에는 심지어 테스트도 하기 힘들다.
	+ 전역 데이터로 오해받는 클래스 데이터
		+ 성실한 개발자의 경우 효과적인 정보 은닉을 방해하는 것 중 하나는 클래스 데이터를 전역 데이터로 생각해서 전역 데이터와 관련된 문제를 피하고자 클래스 데이터를 사용하지 않는 것일 수 있다.
		+ 전역변수는 늘 지옥문에 비유한다.
			+ 전역 변수의 문제점
				+ 전역 데이터를 다루고 있다는 사실을 알지 못한 채 전역 데이터를 접근하는 경우
				+ 다른 루틴도 전역 데이터를 다루고 있다는 사실을 인지하지 못한 경우
			+ 위의 문제점들은 클래스 데이터(자바에서는 인스턴스 데이터)에는 이러한 문제가 없다.
			+ 데이터에 대한 직접적인 접근은 단일 클래스로 구성된 일부 루틴으로 제한된다.
		+ 물론 전역변수는 다음과 같이 사용하면 문제는 없다.
			+ 전역 변수를 다루는 클래스로 레핑한 뒤 접근은 이 클래스로만 접근하고 조회를 제외한 연산에는 뮤텍스로직을 확실히 걸어주는 것
			+ 다른 영역에서 전역변수를 추측이 불가능하게 여러 도메인에서 변경하지 못하도록 방지하는 것
			+ 변경의 영역을 한곳으로 모아야 그나마 사용하기 편해지지만 그럼에도 불구하고 전역변수를 사용하면 전체 시스템 루틴이 점차 예측불가능해진다.
	+ 성능 손해
		+ 정보 은닉에 대한 마지막 장애물은 아키텍처 레벨과 코드 작성 레벨에서 성능 손해를 피하기 위한 시도일 것이다.
		+ 아키텍처 레벨의 경우
			+ 정보 은닉을 위한 시스템 설계가 성능을 위한 설계와 충돌하지 않기 때문에 걱정할 필요는 없다.
		+ 코드 작성 레벨의 경우
			+ 데이터 항목에 간접적으로 접근하면 객체 생성과 루틴 호출이라는 추가적인 부하때문에 런타임시 성능 손해가 발생한다는 걱정이다.
			+ 이런 걱정은 시스템의 성능을 측정해 병목이 발생하는 위치를 찾기 전까지는 걱정을 해서는 안된다.
			+ **이런 위치를 찾기 전까지 가능한 코드는 모듈화 되어야한다.**
				+ 객체 지향언어는 최대한 클래스로 레핑해야하고, 최대한 패키지로 분할해야한다.
				+ 그리고 이런 병목지점(hot spot)을 찾을 때 그때 시스템의 다른 부분에는 영향을 주지않고 개벌적인 클래스와 루틴을 최적화하는 것이다.
				+ 심지어 모든 원시값에 대해 클래스로 래핑하자는 개발자도 존재한다.
		+ 정말 많은 주니어가 테스트도 안해보고 지레겁먹고 성능 최적화를 미리하는 경우가 너무나 많다.
			+ 최적화는 늘 성능 테스트가 우선이 되어야한다. 그 다음 최적화를 진행해도 늦지 않는다.
			+ 만약 시간이 적다면 이때 타협을 해야하는것이다.

&emsp;&emsp;

### 정보 은닉의 가치

+ 설명
	+ 정보 은닉은 실무에서 그 가치가 분명하게 증명된 몇 안되는 이론적인 기법의 하나라는 점은 오래 전부터 이미 알려진 사실이다.
		+ 수년 전에 정보 은닉을 사용한 큰 프로그램이 그렇지 않은 프로그램보다 4배나 수정하기 쉽다는 게 밝혀졌다.
		+ 게다가 정보 은닉은 구조적인 설계와 객체지향적인 설계 모두에 있어서 기본적인 부분이다.
	+ 정보 은닉은 고유한 특성에 기반을 두고 발견적인 방법으로 좋은 설계를 돕는다.
		+ 하지만 전형적인 객체지향적인 설계는 객체로 현실 세계를 모델링할 수 있는 발견적인 능력을 제공하지만 객체지향적인 사고가 ID를 Id 객체 대신 int로 선언하지 않게 도움을 주진 않는다.
		+ 객체지향적인 설계자는 ID가 객체여야 하는가? 라는 질문을 한다면 프로젝트의 컨벤션에 따라 다르겠지만 그렇다라고 대답하면 생성자와 소멸자, 복사 연산자, 할당 연산자를 작성하고(C++의 기준 rule of 5를 의미한다.) 모든 코드에 주석을 작성한 다음 코드를 git에 커밋해야한다.
		+ 주니어의 경우에는 일반적으로 ID를 위해서 클래스가 필요는 없을 것같다고 말하기 쉽다.
	+ 이 예제에서 객체지향적인 설계와 정보 은닉의 차이는 구분하기 힘들 것이다.
		+ 차이점은 정보 은닉에 대한 발견적인 사고가 객체지향적인 사고가 하지 않는 설계 결정을 돕는다는데 있다.
	+ 정보 은닉은 클래스의 공개 인터페이스를 설계할 때 유용하다.
		+ 클래스 설계에서 이론과 실제 사이의 차이가 크고 많은 클래스 설계자들 사이에서 클래스의 공개 인터페이스에 무엇을 놓아야 하는지에 대한 결정은 어떤 인터페이스가 가장 사용하기 편리한지를 결정하는 것과 같다.
			+ 이것은 대개 클래스를 가능한 많이 노출하는 결과를 낳는다.
			+ **열줄만 추가로 타이핑하면 클래스의 비밀을 보호할수 있지만 클래스의 모든 비공개 데이터를 노출한 개발자도 정말 많다.**
	+ 이 클래스에서 무엇을 숨겨야하는지 묻는 것이 인터페이스 설계 문제를 대개 해결해준다.
		+ 클래스의 비밀을 훼손하지 않고 함수나 데이터를 공개 인터페이스에 놓을 수 있다면 그렇게 하는게 좋고 아니라면 안하는게 좋다.
		+ 무엇을 숨겨야 하는지에 대한 질문은 모든 레벨에서 좋은 설계 결정에 도움을 준다.
		+ 구현 레벨에서 리터럴 대신 이름상수를 사용하면 클래스 내부에서 좋은 루틴과 좋은 매개변수 이름을 생성하는 데 도움이 된다.
		+ 시스템 레벨에서는 그 질문이 클래스와 서브시스템의 분해 및 상호 연결에 대한 결정에 도움을 줄 것이다.
	+ 무엇을 숨겨야하는가? 라는 질문하는 습관을 갖자. 설계에 관한 결정하기 어려운 문제의 대개 상당수가 해결된다.

&emsp;&emsp;

## 변경가능 영역을 찾아라

+ 설명
	+ 훌륭한 설계자에 대한 연구에서 그들이 변경을 예측할 수 있는 능력을 공통으로 갖고 있다는 사실을 발견했다.
		+ 변경사항을 수용하는 것은 좋은 프로그램 설계에서 가장 어려운 부분이다.
		+ 변경의 효과가 한 루틴이나 클래스, 패키지에 제한되도록 불안정한 영역을 고립시키는 것이 목표이다.
	+ **변화 대비 3단계**
		**1. 변경될 것처럼 보이는 항목을 찾는다.**
			요구사항 개발을 잘했다면 그 안에 변경 가능성이 있는 것의 목록과 각 변경이 일어날 확률을 담고 있을 것이다.
			이런 경우 변경 가능성이 있는 것을 파악하기가 쉽지만 요구사항 분석에서 변경 가능성이 있는 것을 다루지 않았다면 어느 프로젝트에서나 변경될 가능성이 큰 영역에 대한 이어지는 내용을 살펴본다.
		**2. 변경될 것 같은 항목을 분류한다.**
			1단계에서 찾은 변경되기 쉬운 요소를 고유한 클래스로 분류하거나 함께 변경될 수 있는 다른 요소들과 함께 고유한 클래스로 분류한다.
		**3. 변경될 것처럼 보이는 항목을 고립시킨다.**
			잠재적인 변경에 영향을 받지 않는 상호 클래스 인터페이스를 설계한다.
			그 다음 그러한 변화가 해당 클래스의 내부에 제한되어 외부에는 영향을 받지 않도록 인터페이스를 설계한다.
			변경된 클래스를 사용하는 클래스는 변경이 발생했다는 사실을 몰라야 한다.
			클래스의 인터페이스가 자신의 비밀을 보호해야 한다.
	+ 변경 가능성이 높은 영역 종류
		+ 비즈니스 규칙
			+ 비즈니스 규칙으로 인해 종종 소프트웨어가 변하게 된다.
			+ 정보 은닉의 기본 원칙을 따른다면 이런 규칙에 기반을 둔 로직은 프로그램 전체에 영향을 미치지는 않는다.
				+ 언젠가 변경이 예고될 때까진 조용히 지내게 된다.
			+ 예시
				+ 국회는 조세구조를 변경하고 기업은 계약을 재협상하고 보험 회사는 보험요율표를 변경한다.
		+ 하드웨어 의존성
			+ 예시
				+ 화면, 프린터, 키보드, 마우스, 디스크 드라이브, 음향 장치, 장치 사이의 의사소통에 대한 인터페이스
			+ 하드웨어 의존성을 자체적인 서브시스템이나 클래스로 고립시켜야 한다.
				+ 이러면 프로그램을 새로운 하드웨어 환경으로 이식할 때 편안하게 이식이 가능하다.
				+ 특정 하드웨어와의 상호작용을 흉내 내는 소프트웨어를 작성하고 하드웨어가 불안정하거나 사용 불가능할 때 하드웨어 인터페이스의 서브시스템을 시뮬레이터로 사용하게 만들고 나서 하드웨어가 사용할 준비가 되면 시뮬레이터에서 하드웨어 인터페이스 서브시스템을 빼고 그 서브시스템을 하드웨어에 연결하게 된다.
			+ 애초에 우리가 PC를 조립할때 인터페이스만 지원된다면, 드라이버만 존재한다면, 메인보드에 마음대로 꼽고 조립해서 쓸 수 있는 이유는 하드웨어의 소통은 드라이버가 전담하기 때문이다.
				+ 소프트웨어도 마찬가지로 사용시 전용 컨트롤러 클래스를 만드는 것이 현명하다는 이야기이며 요즘은 표준 라이브러리가 잘되어있지만 저수준 레밸까지 컨트롤하는 라이브러리라면 계층 더 추상화를 해주면 된다.
		+ 입출력
			+ 초기 하드웨어 인터페이스보다 약간 더 높은 수준의 설계에서는 입력과 출력은 변하기 항상 쉬운 영역이다.
				+ 응용 프로그램이 자신만의 데이터 파일을 생성하는 경우 응용 프로그램이 정교해짐에 따라 파일 포맷도 변하게 된다.
				+ 페이지에서 필드의 위치나 번호, 순서등 사용자 수준의 입력과 출력 포멧도 변하게 된다.
				+ 일반적으로 외부 인터페이스에 대해 변경이 일어날 수 있는 모든 사항을 조사하고 요구사항 명세에 조건으로 걸어야만 한다. 
					+ 그래야 변수 없이 제대로 입출력 테스트가 가능하고 성능 또한 예측이 가능해진다.
		+ 표준을 따르지 않는 언어 기능
			+ 대부분의 언어 구현체는 편리하지만 표준을 안따르는 확장 기능을 포함하기도 한다.
				+ 이런 확장 기능은 환경에 따라 지원이 되지 않아 양날의 검과 같다.
			+ 현재 사용중인 프로그래밍 언어에서 표준을 따르지 않는 확장 기능을 사용하고 있다면 다른 환경으로 이관할 때도 해당 확장 기능을 새로운 코드로 대체할 수 있도록 확장 기능을 별도의 클래스로 래핑해야한다.
				+ 이 처럼 환경을 타는 라이브러리 루틴을 사용한다면 실질적인 라이브러리 함수를 다른 환경에서도 사용이 가능하게끔 한 계층 래핑해야한다.
		+ 어려운 설계 및 구현 부분
			+ 어려운 설계와 구현 부분은 잘못 구현될 가능성이 늘 높고 나중에 다시 구현할 필요가 늘 존재해 숨기는 것이 좋다.
				+ 기능을 분류하여 나쁜 설계나 구현이 나머지 시스템에 미치는 영향을 최소화한다.
		+ 상태 변수
			+ 상태 변수는 프로그램의 상태를 나타내고 다른 데이터보다 자주 변경되는 경향이 있다.
			+ 예시
				+ 오류 메시지 상태 변수
			+ 주의점
				+ 상태 변수 사용시 유연성과 가독성을 고려한다.
				+ 불린 변수 대신 열거형이나 문자열을 사용하자.
				+ 변수에 직접 접근 하지 말고 접근 루틴을 만들어 사용하고 변수 대신 접근 루틴을 검사해 더욱 정교히 상태를 점검해야한다.
		+ 데이터 크기 제약
			+ 배열의 크기를 100으로 선언하면 100이라는 불필요한 정보가 노출된다.
				+ 이를 전에도 지적했듯 상수 변수로 대체해주는 것이 좋다.

&emsp;&emsp;

### 변경 정도 예측하기

+ 설명
	+ 시스템에 대한 잠재적인 변경에 대해서 생각할 때 변경의 효과나 범위가 변경이 발생할 가능성에 비례하도록 시스템을 설계한다.
		+ 변경 발생 가능성이 있는 경우
			+ 시스템이 그러한 변경을 쉽게 수용할 수 있는지 확인한다.
			+ 변경 가능성이 없는 부분만 시스템에서 하나 이상의 클래스에 큰 영향을 미치도록 허용해야한다.
	+ 좋은 설계자는 변경을 예상하는 데 드는 비용도 고려한다.
		+ 변경 가능성은 희박하지만 대책 수립이 쉬운 경우에는 변경 가능성이 크고 대책 수립이 어려운 경우보다 더 많이 고민해야한다.
	+ 변경될 것 같은 영역을 식별하는 좋은 기법
		1. 우선 프로그램에서 사용자에게 쓸모가 있는 최소한의 부분을 파악하는 것이다.
			+ 이 부분이 시스템의 핵심을 이루고 변경될 가능성은 늘 적다.
		2. 시스템에 대한 최소한의 변경 사항이 무엇인지 정의한다.
			+ 이 부분이 너무 작아 별로 안 중요해 보일 수 있다.
	+ 기능적인 변경을 고려할 때는 프로그램을 쓰레드 세이프하게 만들고 변경을 지역화하는 등 질적인 변경도 고려해야한다.
	+ 개선 가능성이 있는 부분은 시스템의 잠재적인 변경으로 이어지며 이런 변경은 정보 은닉의 원칙을 사용해 설계한다.
	+ 핵심적인 부분을 먼저 식별함으로써 어떤 컴포넌트가 추가되는 부분인지 알 수 있고 거기서 개선할 내용을 추정하고 숨길 수 있다.

&emsp;&emsp;

## 결합을 느슨하게 유지하라

+ 설명
	+ 결합
		+ 클래스나 루틴이 다른 클래스나 루틴과 얼마나 밀접하게 연관되어 있는지를 기술한다.
		+ 결합은 클래스와 루틴 둘 다 해당되므로 이 책에서는 이 둘을 통칭으로 모듈이라고 부른다.
	+ 이 주제의 목표 
		+ 클래스나 루틴을 작고 직접적이며 눈에 띄고 유연한 관계를 갖는 클래스와 루틴을 생성하는 것
		+ 이것을 loose coupling이라고 한다.
	+ 하나의 모듈이 다른 모듈에 의해 쉽게 사용될 수 있을 정도로 느슨한 상태가 훌륭하다고 할 수 있다.
		+ 소프트웨어의 모듈 사이의 결합은 될 수 있는 한 최대한 단순해야한다.
	+ 다른 모듈에 거의 의존하지 않는 모듈을 생성하려고 노력해야한다.
		+ 만약 두 클래스가 동일한 전역 데이터를 사용하는 경우엔 혈연관계라고 봐도 무방하다.

&emsp;&emsp;

### 결합의 기준

+ 크기
	+ 모듈 사이의 연결횟수를 의미한다.
	+ 인터페이스는 작을 수록 결합도가 내려간다.
		+ 보통 작은 인터페이스를 가진 모듈이 다른 모듈에 연결하기가 상대적으로 쉽기 때문에 가능하면 작은 것이 좋다.
		+ 예시
			+ 매개변수를 하나만 받는 루틴이 여섯 개의 매개변수를 받는 루틴보다 호출하는 모듈에 느슨하게 연결되어있다.
			+ 잘 정의된 네 개의 public 메서드를 갖는 클래스는 37개의 작은 public 메서드를 가진 클래스보다 호출하는 모듈에 더 나은 결합도를 가진다.
				+ 이것 때문에 자바게열 개발사중 롬복을 꺼리는 회사도 많다.

+ 가시성
	+ 두 모듈 간의 연결이 얼마나 명시적인지 의미한다.
	+ 프로그래밍에서는 연결 부분을 최대한 눈에 띄게 표현해야한다.
		+ 예시
			+ 매개변수 리스트에 데이터를 전달하는 것은 분명하게 연결되는 것이라 좋은 가시성에 해당한다.
			+ 전역 변수를 두 클래스에서 동시에 접근하는 것은 막연하게 연결되는 것이라 나쁜 가시성에 해당한다.
				+ 정 사용해야한다면 전역 데이터 연결에 대한 내용을 문서로 작성해야 하는데 문서를 읽지 않는 인간들은 어디에나 있으므로 최대한 전역변수는 지양하는게 낫다.

+ 유연성
	+ 얼마나 쉽게 모듈 사이의 연결을 변경할 수 있는지를 의미한다.
	+ 예시
		+ 직원 객체가 있고 직원의 1년 휴가 일수를 조회하는 루틴이 존재한다고 가정하자.
			+ 한 모듈 1에 이 객체가 있고 모듈 1이 이 객체를 조회 루틴에 전달한다고 가정해보자.
			+ 두 모듈이 직원 객체로 연결되었지만 (직원과 직원을 포함하는 모듈 1) 연결은 하나다.
			+ 이때 만약 직원 객체가 없는 모듈 2에서 조회루틴을 그냥 사용한다고 가정해보자.
				+ 이러면 모듈 2는 직원 클래스를 모르기 때문에 우선 직원 객체를 알아야한다.
				+ 직원 객체에서 입사 날짜와 직무정보 필드, 즉 2개의 필드를 패울 수있지만 그렇게 하기 위해서는 조회 루틴에 대한 내부지식이 필요하다.
					+ 이 루틴이 두 필드만을 사용한다는 사실이다.
				+ 차라리 조회 루틴에 두 가지 필드를 매개변수로 받도록 수정할 수도 있다.
				+ 어떤 방법이던지 처음보단 유연성이 떨어지게 될것 이다.
		+ 이 예시는 어떤 모듈이 다른 모듈을 호출하는 게 쉬울수록 결합은 더 느슨해지는데 그렇게 하면 유연성도 커지고 유지보수하기도 쉽기 때문에 좋다는 의미에서 만든 것이다.

&emsp;&emsp;

### 결합의 종류

+ 일반적인 결합의 종류
	+ 간단한 데이터 매개변수 결합
		+ 두 모듈 사이에서 전달되는 모든 데이터가 원시 데이터형이고 모든 데이터가 매개변수로 전달된다면 두 모듈은 단순-데이터-매개변수로 결합된 것 이다.
		+ 이 경우 자연스럽고 대부분 허용된다.
	+ 간단한 객체 결합
		+ 모듈이 객체를 인스턴스화 한다면, 그 모듈은 객체에 단순-객체로 결합된 것이다.
		+ 이 경우도 자연스럽고 좋다.
	+ 객체 매개변수 결합
		+ 객체1이 객체2에게 객체3을 요구하는 것은 이 두 모듈은 서로에 대해서 객체-매개변수로 결합한 것이다.
		+ 이런 종류의 결합은 객체2가 객체3을 알아야하기 때문에 객체1이 윈시 데이터형을 요구하는 것보다더 결합이 강하다.
		+ 그래도 이 경우가 가장 실무에서 많이 쓰인다.
	+ 의미론적인 결합
		+ 한 모듈이 다른 프로그래밍 요소를 이용하지 않고 다른 모듈의 내부 작동에 대한 논리적인 지식을 사용할 때이다.
		+ 이 경우 가장 발견하기 어려운 종류의 결합이 발생한다.
		+ 사용된 모듈의 코드를 변경하면 모듈을 사용하는 코드가 컴파일러로 절대 감지할 수 없기 때문에 의미론적 결합은 매우 위험하다.
			+ 심각한 경우엔 왜 이 코드에 문제가 있는지 알지도 못한 채 항상 유리를 씹어 삼키는 것과 같은 고통을 느끼며 디버깅을 해야한다.
		+ 어려운 결합의 예시
			+ 모듈 1이 모듈 2에 무엇을 할지 지시하기 위해 모듈 2에 제어플러그를 전달하는 경우
			+ 모듈 1이 전역 데이터를 수정한 후 모듈 2가 그 전역데이터를 사용하는 경우
			+ 모듈1의 인터페이스는 모듈1.특정루틴()이 호출되기 전에 모듈1.init() 루틴이 내부적으로 호출된다는 것을 말해주고 이를 사용하는 모듈2가 이를 알고서 호출시에는 따로 모듈1.init()을 호출하지 않는 경우
			+ 모듈1이 객체를 모듈2에 전달하고 모듈2가 객체에서 사용할 루틴에 해당하는 데이터를 부분적으로 초기화하는 경우
			+ 모듈1이 기반객체를 모듈2에 전달하고 모듈2는 모듈1이 실제로는 구현 객체를 넘긴다는 것을 알기 때문에 구현 객체로 캐스팅하여 구현 객체의 메서드를 호출하는 경우

+ 추가 설명
	+ 효과적인 모듈이 추가적인 추상화 수준을 제공하는 것이 느슨한 결합의 핵심이다.
		+ 즉, 래핑이 대부분 해결해준다는 뜻이다.
		+ 단, 어떤 모듈을 사용할 때 내부 작업에 대한 이해나 전역 데이터의 수정, 불확실한 기능중 하나 이상에 집중해야한다면 추상적인 효과는 사라지고 복잡성 관리에 도움을 주는 모듈의 능력은 사라진다.
	+ 결론적으론 클래스와 루틴은 복잡도를 줄이기 위해 탄생하여 지금까지 존재하는 것이며 이 둘이 일을 더 복잡하게 만든다면 제대로 사용하지 못하는 것이다.


&emsp;&emsp;

## 일반적으로 널리 사용되는 디자인 패턴을 찾아라

+ 설명
	+ 디자인 패턴
		+ 가장 흔히 발생하는 많은 문제를 해결하는 데 사용할 수 있는 이미 만들어진 솔루션의 핵심적인 부분을 제공한다.
		+ 어떤 문제는 처음부터 뒤집어봐야 해결될 수도 있고 이미 해결했었던 어떤 과거의 문제와 유사하여 비슷한 해결책 패턴을 사용해 해결할 수 있다.
	+ 패턴은 완전히 직접 작성한 설계로는 얻을 수 없는 여러 가지 이점을 제공한다.
	+ 디자인 패턴의 특징
		+ 패턴은 이미 만들어진 추상화를 제공하여 복잡성을 줄인다.
			+ 타 개발자들에게도 코드에 있는 설계 접근 방법을 이해시키려고 모든 코드를 뒤집어까서 설명할 필요가 없어진다는 뜻이다.
		+ 패턴은 일반적으로 널리 사용되는 해결책의 세부 사항들을 규정함으로써 오류를 줄인다.
			+ 개념적으로는 패턴은 표준 라이브러리를 가져다 쓰는 것과 비슷한 효과를 낸다.
		+ 패턴은 대안을 제안함으로써 발견적 학습의 가치를 제공한다.
			+ 일반적으로 널리 사용되는 패턴을 잘 써먹어본 설계자는 설계 문제에 맞는 패턴을 옷 잘 골라입는 패셔너블한 사람처럼 골라서 사용한다.
		+ 패턴은 설계에 대해 수준 높은 논의를 하게 해주어 의사소통을 원할하게 해준다.
	+ 주의 사항
		+ 코드를 억지로 패턴에 끼워 넣지 말아야한다.
			+ 패턴에 따라 코드를 약간 바꾸어 이해하기 쉽게 만드는 경우가 있지만 이 작업이 지나치면 패턴과 비슷하게 보이게 하려는 작업이 오히려 코드를 더 복잡하게 만든다.
		+ 기능에 집착하지 말아야한다.
			+ 패턴을 사용해보기 위해 패턴을 적용해서는 안된다.
		+ 모든 패턴은 어느 상황에서는 안티 패턴이다.
			+ 즉, 상황에 맞게 사용하지 않으면 복잡성을 증대시키거나 성능을 저하시키는 등 여러 장애의 원인이 된다.
			+ 따라서 반드시 디자인 패턴을 공부할 때에는 상황에 맞게 사용하려는 연습과 고민을 수없이 시도한 뒤에 실전에서 사용해보는 것이 좋다.
		+ 실전에서는 왠만해서는 쓸려고 노력하지 않는 것이 좋다.
			+ 두번째 주의사항와 거의 일맥상통하는 내 의견이다.
			+ 대부분의 장애 해결책들의 경우 디자인 패턴적으로 장애를 극복하는 경우는 매우 드문 경우이다.
				+ 개인적으로 몇번의 프로젝트를 진행해 본 결과 디자인 패턴으로 해결을 하고 싶은 욕구는 시스템의 복잡성만 증대시켰다.
					+ 디자인 패턴들은 상속을 지나치게 많이 사용한다는 점이 한몫 한다.
						+ 이것이 디자인 패턴을 적용해보아도 시스템의 복잡성만 증대했던 이유이기도하다.
						+ 상속은 기본적으로 결합도를 올리는 거의 모든 상황에서의 안티패턴이다.
							+ 거의 객체지향이 등장한지 20년이 된 지금 이 의견은 어느 계열을 막론하고 공감하는 정론에 가깝다.
			+ 장애를 대처할 때 디자인 패턴을 먼저 떠올리지말고 우선 내 방식으로 해결한 뒤 이것과 비슷한 패턴을 찾아 몇 번 더 리펙토링하는 것이 좀 더 우아한 방식이라 생각한다. 
				+ 즉, 책에서 설명하는 인과 관계를 뒤집어 접근하는 것이 더 낫다고 보는 것이다.
	+ 가장 널리 사용되는 디자인 패턴
		+ 추상 팩토리
			+ 구체적인 클래스를 지정하지 않고 집합의 종류를 지정해 관련 객체의 집합을 생성하는 기능을 제공한다.
			+ 주로 여러 구현체를 알지 않고 추상 팩토리를 통해 공통메서드를 사용하는데 주로 환경에 상관없이 추상 팩토리로 접근해서 원하는 객체를 가져다 사용함에 용이하다.
				+ 예를 들면 화면 인터페이스 기능 클래스를 맥 화면 인터페이스인지, 윈도우 화면 인터페이스인지 내부 구현을 알 필요 없이 추상 팩토리에 있는 공통 메서드인 createWindow(), changeSize()등을 호출해 구현한다.
				+ 여러 펙토리 관련 인터페이스를 주로 솔루션에서 자주 볼 수 있는데 위의 예시와 같은 맥락에서 자주 사용된다.
		+ 어뎁터
			+ 클래스의 인터페이스를 다른 인터페이스로 변환한다.
			+ 주로 구 시스템을 수정하지 않고 인터페이스로 레이어를 하나 더 만든 뒤 새 인터페이스를 통해 구 시스템을 그대로 사용하기위해 사용된다.
				+ 레거시에서 지겹게 자주보게 된다.
		+ 브릿지
			+ 인터페이스와 구현을 분리하여 각각을 독립적으로 변형할 수 있게 한다.
			+ 추상 펙토리와 비슷해보이지만 브릿지는 구현 객체를 위임해서 쓴다는 것에 큰 차이가 존재한다.
				+ 사실 전형적인 위임 구조 그 자체나 다름이 없다고 볼 수 있는 패턴인데 이 패턴은 주로 구현을 알지 않아도 주입하거나 플래그값을 통해 생성한 구현 객체를 통해 공통 메서드를 사용하는 구조이다.
				+ 목적 자체는 추상 펙토리와 동일하지만 주로 실무에서는 훨씬 자주 사용되는 패턴이다.
				+ 그 이유는 주로 위임 구조는 런타임에 타입이 결정되는데 이것이 결합도를 낮추는데 탁월한 성능을 발휘하기 때문이다.
		+ 컴포짓
			+ 고유한 타입의 추가 객체가 담긴 객체로 구성되어 클라이언트는 최상위 레벨의 객체를 사용하지만 세부적인 객체에는 관여하지 않는 패턴
			+ 쉽게 말하자면 트리 형태의 복합구조이다. 주로 여러 동일한 인터페이스를 지닌 객체를 여러개를 지닌 구현 객체를 클라이언트에서는 다시 추상적으로 접근해 단순한 메서드로 원하는 목적을 달성하는 구조이다.
			+ 주로 화면단을 컴포짓 형태로 자주 구성한다.
				+ 예를 들면 화면의 어떤 형태를 Component라는 인터페이스를 가진다고 가정하자.
				+ 인터페이스 이지만 내부적으로는 부모 Component의 주소를 가지게끔 만들어야한다.(최상위 루트는 null)
				+ 그러면 다양한 형태를 지닌 Component들을 가지는 Composite라는 Component의구현체가 이 컴포넌트를 배열이나 리스트로 위임하게 되고 이 Composite또한 Component의 구현이므로 다른 Component에 해당된다.
					+ 일종의 recursive한 구조이다.
				+ 이런 구조에서 Component의 메서드인 draw를 호출하면 이 Component를 넘겨받은 객체는 컴포넌트 전체를 그리는 동작을 실행하게 된다 (이것도 다른 객체에서 일부만 구현하면 그렇게 할수도 있다.)
				+ 이런 구조는 사실 선언형 프론트 프레임워크들을 사용해보면 금방 찾을 수 있다.
					+ 개인적으로는 모바일 앱쪽에서도 이건 거의 필수적인 구조이다.
		+ 데코레이터
			+ 책임 설정시 서브클래스를 생성하지 않고 객체에 동적으로 책임을 추가한다.
			+ 연쇄적으로 구현체를 구현해서 만드는 패턴이다.
				+ 보통 이 패턴은 미리 설정한 정책들중 추가조항을 연속적으로 추가하거나 여러 행위들을 연속적으로 런타임에 구현하는 경우에 사용한다.
			+ 이 패턴을 IOS 계열에서는 정말 자주사용하는데 개인적으로는 별로 좋아하진 않는다.
				+ 코드 분기 흐름을 결국 구현체 클래스를 전부 들려서 확인해야 동작이 예측되기 때문이다.
		+ 파사드
			+ 일관된 인터페이스를 갖지 않은 코드에 일관된 인터페이스를 제공한다.
			+ 이것도 위임을 활용한 패턴으로 주로 파사드는 각기 인터페이스가 다른 객체들을 한 클래스에 묶어서 공통 인터페이스를 제공하는데 사용하는데 보통 핸들러와 같은 역할로 사용하고 싶을 때사용한다.
			+ 이건 실무에서 종종 사용하곤 한다.
				+ 파사드 형태의 구조로 클래스를 래핑하는 것이 가장 실무에서 자주 보이는 패턴이다.
		+ 펙토리 메서드
			+ 팩토리 메서드를 제외하고는 다른 개발 파생 클래스에 대해 알 필요 없이 특정 기본 클래스로부터 파생된 클래스의 인스턴스를 제공한다.
			+ 주로 이 메서드는 추상 펙토리에 섞어서 쓴다.
				+ 실무에서는 잘 못보고 솔루션 라이브러리에서만 자주 보게 되는 패턴이다.
		+ 이터레이터
			+ 집합에 잇는 각 요소에 순차적으로 접근하는 기능을 제공하는 서버 객체
			+ 소위 말하는 컬렉션 그룹의 객체들은 전부 이터레이터를 구현체인데 말 그대로 집합에 있는 각 요소에 접근하기 위함이다.
			+ 역으로 말하면 이터레이터를 구현하지 않고는 컬렉션이라고 부르긴 어렵다.
		+ 옵저버
			+ 집합의 멤버가 변경되었다는 것을 관련 객체에게 알리는 객체를 만들어 여러 객체가 동기화 상태에 있게 만든다.
			+ 주로 프론트 프레임워크 라이브러리와 백엔드에서는 이벤트 관련 프레임워크에서 정말 자주 보는 패턴이다.
				+ 주로 직접 구현하기 보단 가져다 쓰는 경우가 많다.
		+ 싱글턴
			+ 오직 하나의 인스턴스만을 갖는 클래스에대한 전역적인 접근을 제공한다.
			+ 주로 데이터베이스 접근 인스턴스에 사용된다.
				+ 특히 대부분 객체 생체 주기 관리 프레임워크들이나 요즘 최신 언어들은 객체를 싱글턴으로 만들어버리거나 싱글턴 처럼 쓸수있게 메모리를 분리해서 그룹을 관리하는 언어들도 많다.
				+ 이 싱글턴 객체를 쓰레드 세이프하게 만들려면 객체가 상태를 가지고 있지 못하게 만들어야한다.
				+ 주로 스프링을 이용한 백엔드 서버에서 모든 빈이 싱글턴으로 관리가 되도 괜찮은 이유는 에코 형태의 요청과 응답 구조의 서버에서는 상태를 디비에 저장하지 서버에는 온메모리로 앵간하면 저장하진 않기 때문이다.
		+ 스트레티지
			+ 동적으로 상호 교환이 가능한 알고리즘이나 행위를 정의한다.
			+ 전략 패턴은 구현을 통해 동작을 하나씩 런타임에 구현하는 패턴이다.
			+ 주로 안드로이드나 게임 클라이언트쪽의 대부분 로직은 전략패턴을 구사한다.
				+ 전략패턴또한 오버라이딩에 매몰되는 구조라 실무에서는 솔루션 라이브러리를 가져다 쓰는 경우가 아닌이상 쓸일이 별로 없다.
		+ 템플릿 메서드
			+ 상세한 구현 일부를 서브클래스에 남겨두고 알고리즘 구조를 정의한다.
			+ 주로 로직을 나중에 오버로딩해서 구현하는 경우에 사용하는데 스트레티지와 다른점은 상속을 주로 사용한다는 점이고 스트레티지는 위임이 기반이다.

&emsp;&emsp;

## 다른 발견적 학습

&emsp;&emsp;

### 응집력을 강하게 하라

+ 설명
	+ 응집력은 구조적인 설계의 결과로 얻을 수 있고 대개 결합과 같은 맥락으로 다룬다.
		+ 응집력은 클래스에 있는 모든 루틴이나 루틴에 있는 모든 코드가 얼마나 밀접하게 중심목적을 지원하고 있는지, 그 클래스가 얼마나 집중되어 있는지를 나타낸다.
	+ 매우 연광성이 높은 기능을 포함하는 클래스를 응집력이 강하다고 부르며 발견적 학습의 목표는 가능한 한 응집력을 강하게 만드는 것이다.
	+ 응집력은 복잡성 관리에 유용한 도구이며 클래스의 코드가 중심 목표를 더 많이 지원할수록 코드가 수행하는 모든 것을 더 쉽게 기억할 수 있기 때문이다.
	+ 루틴 레벨의 응집력에 대해서 생각하는 것은 지난 수십년 동안 유용한 발견적 학습이었으며 오늘날에도 여전히 유용하다.
	+ 클래스 레벨의 응집력은 이 장 앞부분과 6장에 설명한 잘 정의된 추상화 기법에 의해 널리 적용됐다.
		+ 추상화도 루틴 레벨에 유용하지만 루틴 레벨에는 응집력이 더 잘 맞는다.
	+ 주의점
		+ 결합도와 응집도를 늘 햇갈려하는 사람이 너무 많은데 응집도는 클래스나 모듈에 연관된 기능들이 최대한 한 클래스 또는 모듈에 집중이 얼마나 잘 되었는지 나타내는 척도이며 결합도는 타 모듈과 얼마나 연결이 되어있는지를 나타낸다.
		+ 결합은 모듈간 연결, 응집은 모듈 내 집중이라고 기억해 두면 안 헷갈린다.

&emsp;&emsp;

### 계층을 만들어라

+ 설명
	+ 계층은 단계식 정보구조로 가장 일반적이거나 추상적인 항목이 최상위에 위치하고 점차 상세하고 구체적인 항목은 낮은 레벨에 위치한다.
		+ 소프트웨어에서는 클래스 계층과 루틴 호출 계층에서도 계층을 확인할 수 있다.
	+ 계층은 적어도 2천년 이상 정보의 복잡성을 다루기 위한 중요한 도구였는데 예를 들면 아리스토텔레스는 계층을 이용해 동물의 왕국을 체계화했다.
		+ 인간은 복잡한 정보를 체계화하기 위해 계층구조로 파악한다.
	+ 계층은 소프트웨어의 주요 기술적 의무인 복잡성 관리를 달성하는 데 유용한 도구이다.
		+ 계층을 이용하면 현재 다루고 있는 수준에만 집중할 수 있기 때문이다.
			+ 이렇다고 세부 사항이 완전히 사라지는 것이 아닌 모든 것을 동시에 생각하는 대신 원할 때만 생각할 수 있도록 세부 사항을 다른 수준으로 옮기는 것뿐이다.


&emsp;&emsp;
### 클래스 계약을 형식화하라

+ 설명
	+ 더 상세한 레벨에서는 각 클래스의 인터페이스를 나머지 프로그램과의 계약으로 생각하는 것이 이해하는 데 도움이 된다.
	+ 전형적으로 '계약(프로토콜)'은 다음과 같다.
		+ 예시
			+ 데이터 x, y, z를 제공하기로 약속하고 그 데이터들이 ㄱ, ㄴ, ㄷ이라는 특성을 갖는다는 것을 약속하면 8, 9, 10이라는 제약 내에서 1, 2, 3의 연산을 수행하는 것을 약속합니다.
		+ 클래스의 클라이언트가 클래스와 맺는 그러한 계약을 전형적으로 "선행 조건"이라고 하며 객체가 클라이언트와 맺는 계약을 "후행 조건"이라고 부른다.
	+ 계약은 적어도 이론상으로는 객체가 계약에 없는 행위를 무시해도 되기 때문에 복잡성을 관리하는 데 유용하다.
		+ 실무에서는 이런 문제가 훨씬 더 어렵다.
		+ 계약을 지정해서 코드를 작성하는 일은 실무에서는 거의 없다. 

&emsp;&emsp;

### 책임을 할당하라

+ 설명
	+ 객체에 어떻게 책임을 할당할 것인지 생각하는 것이다.
	+ 어떤 책임을 지게 하는 것과 어떤 정보를 정보 은닉하는 것은 유사하지만 책임을 묻는 것이 좀 더 포괄적인 답을 제공해 딱 정보 은닉과 다른 경험적 가치를 제공한다.

&emsp;&emsp;
### 테스트가 가능하도록 설계하라

+ 설명
	+ 테스트가 용이한 시스템은 무엇인지를 고민하면 흥미로운 설계를 만들 수 있다.
	+ 테스트가 가능하도록 설계하면 더 규격화된 클래스 인터페이스가 만들어지는 경향이 존재하며 이는 일반적으로 도움이 된다.
	+ 개인적인 의견
		+ 어떤 클래스가 필요하며 기본적으로 어떤 인터페이스를 지닐지 정도만 구상하는 것은 uml상으로 가능하지만 실제로 테스트를 해야하는 상황에 직면하는 순간, 클라이언트 단에서 사용될 여러 기능들을 하나씩 단위 테스트를 해야하는 상황을 생각해보면 결국 다시 설계를 해야하는 경험이 셀 수도 없이 많이 있었다.
		+ TDD가 애초에 대세가 된 이유이기도 한데 위와 같은 순간을 방지하기 위해 클래스, 루틴 설계 및 작성 전에 미리 실패하는 테스트부터 작성해버리는 것이 정말 도움이 된다.
		+ 누군가는 TDD는 데이터 주도로 개발하는 경우에만 유용하고 클라이언트 개발에는 대체로 유용하지 않다는 의견을 내는 사람도 정말 많은데 사실 모든 경우에 TDD를 사용할 수 있다.
			+ 다만 클라이언트 단에서 진행해보려면 테스팅 툴이 따로 존재해야하는 경우가 대다수라 좀 더 진행 조건이 까다로운 편이긴하다.
			+ 서버단에서는 TDD가 대세가 될 수 밖에 없는 이유이기도 하다.
			+ 요즘 개발관련 최신 프레임워크들이나 라이브러리들은 테스팅을 정말 중요하게 생각해 이걸 빼놓고 개발하는 경우는 매우 드문 상황인지라 왠만해서는 도입하는 것이 낫다.

&emsp;&emsp;
### 실패를 피하라

+ 설명
	+ 늘 실패하는 사례를 참고해 피해서 설계하다보면 성공하는 소프트웨어가 탄생한다는 지론이다.

&emsp;&emsp;

### 결합 시점을 의식적으로 선택하라

+ 설명
	+ binding 시점은 특정 값이 변수에 결합하는 시점을 말한다.
		+ 초기에 결합하는 것은 간단하지만 유연성이 떨어지기 쉽다.(특히 컴파일 타임시 binding)
		+ 따라서 binding 직전에 지금 타이밍이 맞는지 늘 고민을 해야한다.
		+ 개인적으로 주로 이 고민은 변경 가능성, 테스트 설계를 고려해보면 대체로 맞는다.
			+ 변경 가능성이 높고 테스트 설계가 필요하면 binding은 최대한 느슨하게 만드는 것이 좋다.
			+ 변경 가능성이 낮고 테스트 설계가 필요하지 않는 경우엔 binding은 유연성이 적게 만들어도 상관이 없는 상황이다.
			+ 다만 경험상 대부분의 경우 변경 가능성이 아예 없는 경우는 없었다. 결합은 최대한 느슨하게 만들어주자.

&emsp;&emsp;

### 제어 지점을 정하라

+ 설명
	+ 정확한 장소의 법칙을 의미하며 핵심코드를 찾기 위한 정확한 장소와 유지보수 변경을 수행하기 위한 정확한 장소가 있어야한다고 말했다.
		+ **주로 클라이언트 코드를 조합하는 핵심 비즈니스 루틴을 의미한다.**
	+ 제어는 클래스와 루틴, 프리프로세서 매크로, \#include 파일에 집중될 수도 있고 이름 상수도 제어 지점이 될 수 있다.
	+ 복잡성이 줄어들면 찾아야 하는 장소가 줄고 더 쉽고 안전하게 변경할 수 있다는 이점을 얻는다.

&emsp;&emsp;
### 주먹구구식 기법의 사용을 고려하라

+ 설명
	+ 주먹구구식으로 우선 수행하고 나중에 우아한 방식(graceful)을 찾으라는 지론이다.
		+ 리눅스의 아버지인 도널드 커누스는 이진 탐색 알고리즘은 1946에 공개됬지만 리스트의 크기와 상관없이 탐색하는 알고리즘을 공개하는데 16년이 걸렸다는 것을 지적했다고 한다.
		+ 즉, 무엇이 됬든지 우아한 방식을 고안하는 데 시간이 상당히 많이 걸릴 수 밖에 없다는 것이다.

&emsp;&emsp;

### 다이어그램을 그려라

+ 설명
	+ 다이어그램은 늘 강력한 발견적 학습 도구이다.
		+ 말로 천마디를 설명하지말고 그림 한장으로 표현하라
		+ 문제를 상세히 다뤄야하는 경우도 많지만 대체로 일반적인 추상화된 레벨에서부터 구상해야하는 경우가 대다수이며 이걸 빼먹는경우 엉뚱한 문제를 상세히 다루는 경우가 대다수였다.
	+ 예를 들면 개인적인 경험상 아무리 개차반, 주먹구구식으로 운영되는 서버여도 ERD는 늘 존재했다.
		+ 다른 핵심 요구사항 명세나 다른 핵심 설계 문서가 빠져도 저 ERD는 늘 존재한다. 이게 구현의 핵심 설계 다이어그램 파일이기 때문이다.

&emsp;&emsp;

### 모듈화를 유지하라

+ 설명
	+ 모듈화의 목표는 각 루틴, 클래스를 블랙박스로 만드는 것이다.
	+ 모듈화의 개념은 정보 은닉과 캡슐화, 다른 설계에서의 발견적 학습 방법과 관련이 있다.
		+ 그러나 때로는 시스템을 어떤 형태의 블랙박스 집합으로 구성할 것인지에 대한 고민이 정보 은닉과 캡슐화가 제공하지 않는 통찰력을 제공하기 때문에 이 개념도 알아둘 가치가 있다.


&emsp;&emsp;

## 설계의 발견적 학습에 대한 요약 정리

+ 현실 세계의 객체를 찾아라
+ 일관성 있는 추상화를 구성하라
+ 세부 사항을 캡슐화하라
+ 가능할 때 상속하라
+ 비밀을 숨겨라
+ 변경 가능 영역을 규명하라
+ 느슨한 결합을 유지하라
+ 일반적으로 널리 사용되는 디자인 패턴을 찾아라
+ 응집력을 강하게 하라
+ 계층을 만들어라
+ 클래스 계약을 형식화하라
+ 책임을 할당하라
+ 테스트가 가능하도록 설계하라
+ 실패를 피하라
+ 결합 시점을 의식적으로 선택하라
+ 제어 지점을 정하라
+ 주먹구구식 기법의 사용을 고려하라
+ 다이어그램을 그려라
+ 모듈화를 유지하라

&emsp;&emsp;


## 발견적 접근 방법을 위한 지침


+ 접근 방법 설명
	1. 문제의 이해
		+ 그림을 그리고 적절할 표기법을 도입하라
		+ 조건을 여러부분으로 분리하라
		+ 이것들을 적어둬야한다.
	2. 계획의 고안
		+ 데이터와 모르는 것과의 관계를 찾아라
			+ 연결 고리를 찾을 수 없다면 부차적인 문제를 고려해야할 수도 있다.
			+ 결국은 해결책에 대한 계획을 세워야한다.
		+ 그 문제를 경험 해본적이 있는지, 해봤어도 모르는 부분을 찾아야한다.
			+ 예전에 겪어본 문제를 활용해볼 수 있다면 활용하고 다른 보조적인 요소가 필요한지 확인해야한다.
		+ 문제를 다시 다르게 기술할 수도 있다면 정의부분으로 돌아가야한다.
		+ 제시된 문제를 해결할 수 없다면 2번째와 같이 관련된 문제를 해결해보는 방식으로 좀 더 쉬운 난이도로 돌아가는 방법을 써보자
			+ 이때 조건의 일부만 유지하고 나머지 부분을 제거하면 모르는 부분을 추론하고 데이터를 알아낼 수 있다면 좋다.
		+ 모든 데이터를 사용했는지 조건, 핵심적인 사항을 고려했는지도 확인해야한다.
	3. 계획의 실행
		+ 문제 해결 계획을 실행할 대 각 단계를 검사한다.
			+ 각 단계가 옳은지 분명해야하며 옳다는 사실을 증명할 수 있어야한다.
			+ 어떤 공리를 증명하는 과정중 사용되는 명제인 보조정리(lemma)와 비슷하다.
	4. 검토
		+ 결과를 확인하고 논거를 검사할 수 있어야한다.
			+ 이때 결과를 다르게 유추할 수 있는지, 한눈에 알아볼 수 있는지 확인한다.
			+ 그리고 다른 문제에 대해서도 그 결과를 정리로써 사용할 수 있는지 확인한다.

+ 설명
	+ 위의 접근 방법 설명은 폴리아 고안한 접근 방법론이다.
	+ 가장 효과적인 지침 중 하나는 여러 방법으로 접근해야한다는 것이다.
		+ 정말 곰곰히 생각해봐도 안되는 경우에는 살짝 손에 놓는게 잡고 늘어지는 것보다 더 빨리 해결되는 경우도 많다.
	+ 설계 문제 전체를 한번에 해결할 필요는 없다.
		+ 보통 설계 문제에 봉착하면 그 순간은 늘 문제 해결을 위한 정보가 가장 부족한 상태임을 깨달아야한다.
		+ 캔트 벡의 조언이 여기서 늘 쓰이는데 설계에 대한 결정은 가장 마지막까지 미뤄서 해야한다는 것이다.
			+ 설계는 경험으로 풀어나가는 것이 가장 효과적임을 이미 이책에서 계속해서 강조하는 바로 따라서 최대한 미루고 미뤄서 선택하는 것이 여러가지 선택 중 최선을 선택하는 것이라고 볼 수 있다.

<br>

# 설계 실천법

&emsp;&emsp;
## 반복

+ 설명
	+ 어떤 프로그램을 처음 작성했을 때 얻은 깨달음으로 다시 프로그램을 작성하면서 많은 것을 배운 경험이 있을 것이다.
		+ 이 현상은 설계에도 적용되지만 이 주기가 더 짧고 파생되는 영향력도 크기 때문에 설계 과정을 몇번 반복할 수 있는 여유가 필요하다.
	+ 설계는 전에도 강조했지만 반복적인 프로세스이다.
	+ 설계 후보를 여러 번 훑어 보고 여러 가지 방법을 싣도해 보면 상위 레벨과 하위 레벨 관점에서 모두 바라보게 될 것이다.
		+ 상위 레벨 문제를 다루면서 얻는 큰 그림은 거시적 관점에서 하위 레벨 세부 사항을 기재하는 데 도움될 것이다.
		+ 하위 레벨 문제를 다루면서 얻는 세부 사항은 더 현실적인 상위 레벨 설계를 가능케 한다.
		+ 즉, 최상위 레벨과 최하위 레벨의 고려사항을 전부 왔다갔다 하면서 조율하는 것은 바람직한 활동이며 단순 하향식 또는 상향식으로만 만드는 것보다 담금질 하듯이 단단한 안정된 강화 구조를 만든다.
	+ 많은 개발자들은 상위 레벨, 하위 레벨의 고려 사항 사이의 범위를 정하는 데 어려움을 겪곤 한다.
		+ 시스템의 한 관점에서 다른 관점으로 전환하며 고려 사항을 탐색하는 것은 정신적으로 힘든 노동이지만 효과적인 설계를 작성하는 데는 필수적이다.
	+ 처음 작성한 설계가 충분히 좋아보여도 멈추지 말아야한다.
		+ 늘 두번째 시도는 첫 번째보다 항상 좋고 이 과정을 반복하면 전체 설계를 점진적으로 향상시킬 수 있다는 것을 배우게 된다.

&emsp;&emsp;

## 분할과 정복

+ 설명
	+ 데이크스트라의 조언을 앞에서 인용했듯, 복잡한 프로그램의 모든 세부 사항을 기억할 만큼 두뇌가 큰사람은 아무도 없고 설계도 마찬가지이다.
		+ 인간은 옛날부터 여러운 문제는 추상화하여 바라보거나(모델링) 분할하여 쪼개서 분석하곤 했다.
	+ 점증적인 개선은 복잡성을 다루는 강력한 도구이다.

&emsp;&emsp;

## 하향식과 상향식 설계 접근 방법

+ 설명
	+ 하향식 설계
		+ 높은 추상화 수준에서 시작함
		+ 기본 클래스가 인터페이스 설계부터 시작한다.(구체 클래스가 아닌 인터페이스부터)
		+ 설계시 파생 클래스 규명하기와 클래스 공동 작업, 다른 세부적인 설계 요소 등 상세화 수준을 높인다.
	+ 상향식 설계
		+ 구체적인 것에서 시작해 일반적인 쪽으로 작업한다.
		+ 구체적인 객체를 규명하는 것으로 시작해 이 내용으로 객체와 기본 클래스 집합을 일반화한다.
		+ 이런 접근 방법은 대체적으로 TDD가 이에 얼추 비슷하게 속한다.
			+ 요구사항을 토대로 실패하는 테스트를 구성하고 성공하도록 필요한 객체만 우선 규명하여 객체와 기본 클래스 집합을 일반화하는 과정이기 때문이다.


&emsp;&emsp;

### 하향식 접근 방법을 지지하는 주장

+ 설명
	+ 인간의 두뇌는 한 번에 하나에만 집중할 수 있다는 것으로 시작된 개념이다.
	+ 분할 정복 프로세스의 반복적인 특징
		+ 일반적으로 한 수준만 분해하고 작업을 중단하지 않기 때문에 반복적이다.
			+ 계속해서 여러 레벨로 진행한다.
		+ 일반적으로 첫 번째 시도에서 만족하지 않기 때문에 반복적이다.
			+ 프로그램을 한 방향으로 분해하며 분해하는 중 어떤 방향으로 서브시스템을 분해하고 상속 트리를 배치하고 객체의 구조를 구성할 것인지 선택해야 할 때가 여러번 있을 것이다.
			+ 선택을 한 후 결과를 보고 다시 처음부터 다른 방식으로 분해하고 이 결과과 서로 비교해본다.
			+ 이런 짓을 몇번 더 해보면 왜 효과적이고 왜 그런지 이해가 확실하게 된다.
	+ 프로그램을 코드 작성이 더 쉬워보일 때까지 계속해서 분해해야한다.
		+ 설계가 너무 분명하고 쉬워 보여 안절부절 못할 정도까지 작업한다. 보통 이러면 작업이 완료된 것이다.

&emsp;&emsp;

### 상향식 접근 방법을 지지하는 주장

+ 설명
	+ 가끔 분석이나 대상에 대한 이해도가 부족한 대상을 하향식으로 접근하는 경우 너무 추상적이여서 시작하기가 어렵다.
		+ 더 가시적으로 작업해야한다면 이 방법을 도입하자.
		+ 구체적인 클래스에 할당할 수 있는 저레벨 책임을 그래도 식별할 수도 있다.
	+ 예시
		+ 어느 시스템에 여러가지 구체적인 행위들이 우선 필요하다는 것을 알게 된다면 이런 것들을 여러가지 하위 레벨의 책임으로 식별한 후 일반적으로 상위 레벨을 편하게 볼 수 있다.
	+ 상향식 구성시 필독 사항
		+ 시스템이 무엇을 해야하는 지 목표를 알고 있는지 스스로 묻는다.
		+ 위 질문으로부터 구체적인 객체와 책임을 파악한다.
		+ 공통적인 객체를 식별하고, 서브시스템 구조나 패키지, 객체 내에서의 합성, 상속 등 적합한 것을 사용해 그 객체들을 그룹짓는다.
		+ 다음 상위 레벨에서 작업을 계속하거나 최상위로 돌아가 다시 하위 레벨 방향으로 작업을 진행한다.


&emsp;&emsp;

### 사실상 논쟁은 없다.

+ 설명
	+ 하향식은 분해, 상향식은 결합 전략이다.
		+ 하향식은 일반적인 문제에서 시작해 관리 가능한 조각까지 나눈다.
		+ 상향식은 관리 가능한 조작에서 시작해 일반적인 솔루션을 구축한다.
	+ 하향식의 장점
		+ 쉽다.
		+ 세부 사항 구현을 미룰 수 있다.
		+ 계층 최하위에 변경가능성이 높은 어느 구체 클래스의 존재에 대해 쉽게 예측이 가능하다.
	+ 상향식의 장점
		+ 일반적으로 필요한 유틸리티 기능을 초기에 파악할 수 있어서 간결하고 잘 구성된 설계가 만들어진다.
		+ 특히 이미 존재하는 시스템에서 이 방식을 사용하면 이전 시스템에서 재사용가능한 모듈응ㄹ 살펴보고 새로운 시스템 설계가 가능해진다.
	+ 상향식의 단점
		+ 이 접근방법만으로는 개발하기 쉽지 않다.
			+ 사람은 작은 개념을 큰 개념으로 조립하는 것보단 큰 개념을 작은 개념으로 분할하는 것을 좀 더 잘한다.
		+ 이미 시작한 조각으로 프로그램을 만들 수는 없다.
			+ 위에서 설명했든 이미 존재하는 시스템에서 작업을 한다면 여기서 다른 무에서 유를 창조하는 것은 이미 불가능하다.
			+ 벽돌로 비행기를 만들 수 없는 것처럼 말이다.
	+ 결론
		+ 둘의 관계는 상호 보완적인 관계이며 상호베타적인 대척점에 선 관계가 아니다.
		+ 둘 다 사용하며 발견적 학습을 하는 것이 베스트이며 어차피 좋은 설계가 나올 때까지 시행착오는 매순간 겪에 될 것이다.

&emsp;&emsp;

## 실험적인 프로토타이핑

+ 설명
	+ 소프트웨어의 본질적 사악함은 최소한 부분적으로라도 문제를 해결하기 전까지는 설계 문제를 완전하게 정의할 수 없다.
	+ 적은 비용으로 이런 문제를 해결하는 기법은 프로토타이핑이다.
	+ 프로토타이핑은 개발자가 질문에 답하는 데 필요한 최소한의 코드를 작성해야 한다는 원칙을 지키지 않으면 제대로 동작하지 않는다.
		+ 예시
			+ DB가 일정 수준 필요한 트랜잭션 양을 지원하는가?
			+ 이럴때는 제품 코드를 작성하지 말고 문제 공간을 어림짐작할 수 있는 정보만 알고서 매우 간단한 프로토 타이핑 코드를 작성한 뒤 더미데이터로 테이블을 만들어 성능 테스트를 수행하면 된다.
		+ 이것을 XP에서 스파이크라고도 부른다.
	+ 프로토타이핑은 설계 질문이 구체적이지 않을 땐 효과가 없다.
	+ 프로토타이핑은 개발자가 프로토타이핑에 사용한 코드를 쓰고 버리는 코드로 취급하지 않았을 때도 효과를 발휘하지 않는다.
	+ 즉 프로토 타이핑은 설계의 사악함과 싸우는 설계자에게 큰 도움이 되지만 원칙 없이 사용하면 더 힘들어진다.

&emsp;&emsp;


## 협력적인 설계

+ 설명
	+ 설계에서는 조직 구성이 공식적이든 비공식적이든 한 명보단 두 명이 낫다.
	+ 협력의 다양한 형태
		+ 비공식적으로 동료에게 다가가 아이디어를 생각해보자고 요청한다.
		+ 동료와 함께 잠깐 비어있는 회의실에 들어가 화이트보드에 여러 가지 설계 아이디어를 그린다.
		+ 동료와 함께 키보드 앞에 앉아 사용하는 프로그래밍 언어로 세부적인 설계를 수행한다. 이때 페어프로그래밍을 해볼 수도 있다.
		+ 한 명 이상의 동료와 디자인 아이디어를 검토할 수 있게 회의 일정을 잡는다.
		+ 모든 방법을 총 동원해 공식 검토 일정을 잡는다.
		+ 자신이 작업을 검토해줄 수 있는 동료가 없다면 초기 설계 작업을 서랍에 넣어 놓고 일주일뒤 다시 살펴본다. 이러면 이전에 작업한 내용을 잊어버려 스스로 잘 검토하게 된다.
		+ 조직 외부에 도움을 요청한다.
			+ 특별한 포럼이나 뉴스 그룹에 질문을 올린다.
	+ 품질 보증이 목표인 경우 형식적인 정밀 검토를 추천한다.
		+ 단순 오류 탐색이 아닌 창조성 함양과 설계 아이디어를 더 많이 시도해 보는 것이 목표면 좀 더 유연한 접근 방법이 효과적이다.
		+ 구체적인 설계를 정한 후에는 프로젝트 성격에 따라서 더 형식적인 정밀 검토로 바꾸는 것이 적합하다.

&emsp;&emsp;

## 설계를 얼마나 해야하는지

+ 설명
	+ 이는 정해진 공식이라는게 없다.
		+ 팀의 경험, 시스템의 예상 수명, 적정한 신뢰도, 프로젝트와 팀의 크기가 모두 고려되어야 한다.
	+ 아래의 표의 두 개 이상의 요소가 어느 프로젝트든 나타날 것이고 때에 따라서 그 요소가 상충되기도 한다.
		+ 안정이 중요한 프로그램을 개발하는 경험 많은 팀은 중간 수준의 설계서를 원할 수도 있다.
			+ 이런 경우에는 각 요소의 중요성을 따져봐서 무엇이 가장 중요한지 판단해야한다.
	+ 설계를 어느 수준으로 할지를 각 개인에게 정하라고 하면 이전에 수행한 작업과 비슷한 수준이거나 간단하게 변경하거나 확장하는 수준의 설계에서는 설계를 중단하고 코드 작성을 시작하려는 사람이 많다.
	+ **설계의 가장 큰 어려움은 어려운 도메인에 대해 설계를 잘못했다고 깨닫는 경우가 아니라 너무 쉬워서 설계를 할 필요가 없다고 생각을 하는 순간에 발생한다.**
	+ 보통 설계 작업이 너무 많아 어려움을 겪은 프로젝트는 없다.
		+ 다만 문서 작업이 지나쳐 어려움을 겪는 프로젝트는 많다.
		+ 일반적으로 설계 대안을 분석하고 탐색하는데에 80프로의 노력, 문서작업에는 20프로의 노력만 들이는 편이 낫다고 한다.

|                           요소                           | 구현하기 전 설계에 요구되는 상세 레벨 |  문서화 형식   |
|:--------------------------------------------------------:|:-------------------------------------:|:--------------:|
|  설계/구현 팀이 응용 프로그램 분야에 대한 경험이 많다.   |               낮은 수준               |   낮은 수준    |
| 설계/구현 팀이 경험은 많지만, 해당 도메인에 경험이 적다. |               중간 수준               |   중간 수준    |
|               설계/구현 팀이 경험이 적다.                |           중간 ~ 높은 수준            | 낮은/중간 수준 |
|    설계/구현 팀의 이직률이 미드레벨에서 잦은 편이다.     |               중간 수준               | 낮은/중간 수준 |
|         응용 프로그램이 높은 안정성을 요구한다.          |               높은 수준               |   높은 수준    |
|             응용 프로그램이 특수 업무용이다.             |               중간 수준               | 중간/높은 수준 |
|                     프로젝트가 작다                      |               낮은 수준               |                |
|                     프로젝트가 크다                      |               낮은 수준               |   낮은 수준    |
|     소프트웨어의 예상 수명이 짧다(몇 주 또는 몇 달)      |               낮은 수준               |   낮은 수준    |
|     소프트웨어의 예상 수명이 길다(몇 달 또는 몇 년)      |               중간 수준               | 중간 수준               |

&emsp;&emsp;

## 설계 작업 기록하기

+ 설계 작업 기록하는 방법
	+ 설계 문서를 코드 자체에 넣기
		+ 가장 핵심적인 설계 결정 사항은 코드 주석으로 문서화한다.
		+ JAVADoc, Swagger와 같은 문서 생성기를 사용하면 그 코드를 작업하는 갭라자가 쉽게 설계 문서에 접근할 수 있기 때문에 설계 문서를 최신으로 유지할 가능성도 커진다.
		+ 다만 개발 프로세스가 하나 더 추가됬다고 싫어할 사람도 존재할 수도 있긴하다.
			+ 이건 앞에서 말했던 설득의 문제이다. 문서화는 필수이고 귀찮아서 자동화를 하려면 이 방식이 현재로서는 베스트이다.
	+ 설계에 대한 논의와 결정을 위키에 기록하기
		+ 설계에 대한 논의를 프로젝트 위키를 작성하는 것인데 키보드로 입력하는 부담이 있지만 조동으로 설계 논의와 결정을 기록하게 해주는 비법이 된다.
		+ 위키를 사용해 문자로 토론한 내용을 보기 위해 디지털 사진이나 설계 논의를 뒷받침하는 웹 사이트에 대한 링크, 벡서, 캡쳐본등의 자료를 기록할 수 있다.
		+ 이 기법은 옛날부터 전 세계 개발팀에 내려온 비법이다.
			+ 깃허브도, 지라도, 컨플루언스도, 트렐로도 위키 페이지가 존재한다.
	+ 이메일로 요약하기
		+ 설계 논의가 끝나면 누군가가 설계에 대한 요약정리본을 작성해 프로젝트 팀원에게 이메일을 보내자
		+ 이메일 복사본은 프로젝트 공용 이메일 폴더에 저장한다.
		+ 이미 전 세계 개발팀은 슬랙을 사용하기 때문에 이걸 이용하는게 일반적이나 메일도 괜찮다.
	+ 디지털카메라를 활용하기
		+ 설계를 문서화할 때 인기있는 그리기 툴을 사용해 그리기 쉽지 않다.
			+ 따라서 화이트보드에 설계 내용들을 포스트잇이나 마카로 잘 정리하며 진행하고 디카로 찍으면 편리하다.
			+ 이 디카 사진을 설계 문서에 넣으면 엄청나게 쉽게 관리가 가능하다.
	+ 설계 플립 차트를 보관하기
		+ 설계 문서가 표준 용지 크기여야 한다는 법은 없다.
			+ 설계 그림을 큰 플립 차트에 그렸다면 그 플립 차트를 편한 곳에 보관하거나 더 좋은 방법으로 사람들이 그 플립 차트를 쉽게 참조하고 필요할 때 갱신할 수 있도록 벽에 붙여도 된다.
		+ 보통 이 오늘날 설계 차트는 컨플루언스 공용 페이지나 슬랙 게시판 체널등 다양한 방식으로 게시되고 있다.
	+ CRC 카드를 사용하기
		+ 설계를 문서화하는 또 다른 기법은 색인카드를 사용하는 것이다.
			+ 각 카드 위에 설계자가 클래스의 이름과 클래스의 책임, 협력자(클래스와 같이 어우러지는 클래스)를 기록한다.
				+ 이때 설계 그룹은 설계를 잘했다고 만족할 때 까지 카드를 가지고 작업할 것이다.
				+ 이 시점이 되면 나중에 참조하기 위해 카드를 보관해도 된다.
			+ 이건 켄트벡의 회의 방법이며 이것은 오늘날에는 다양한 포커게임으로 진화했다고 할 수 있다.
				+ 클래스 뿐만 아니라 유저스토리에 보통 이 방식이 사용된다.
	+ 적절한 상세 수준에서 UML 다이어그램을 작성하기
		+ 설계를 도형으로 나타내는 잘 알려진 기법인 UML은 오브젝트 운영 그룹에 의해 정의되었다.
		+ 이 다이어그램은 설계 엔티티와 관계에 대한 형식적인 표현 방법을 풍부하게 제공한다.
		+ 설계 접근 방법을 조사하고 논의를 위해 비형식적으로 사용할 수도 있다.
		+ 우선 최소한 밑그림으로 시작하고 최종 설계 솔루션에 대해서 집중적으로 토론한 후에만 세부적인 사항을 추가하도록 한다.
		+ UML은 표준화되었기 때문에 설계 아이디어를 교류할 때 공통적으로 이해하는 데 도움을 주고 그룹으로 모여 일을하는 경우 설계 대안에 대한 논의를 빠르게 진행하는 데 도움을 준다.


<br>

# 잘 알려진 방법론에 대한 의견

+ 설명
	+ 모든 것을 설계하는 것은 불가능하니 아무것도 설계하지 말라는 쪽의 의견이 옳지는 않다.
	+ 충분한 정도로만 선행 설계를 진행하는 것이 늘 괜찮았다고 한다.
	+ **선행 설계를 적게 하거나 충분한 정도로 선행하자** 


&emsp;&emsp;

### 구현에서의 설계 체크리스트

&emsp;&emsp;

#### 설계 실천법

+ 한 번만 시도하지 않고 여러번 반복해서 설계 결과를 도출했는지?
+ 가장 효과적인 방법이 무엇인지 확인하기 위해 시스템을 여러 가지 방법으로 분해해봤는지?
+ 설계 문제에 상향식과 하향식 방법을 사용해 접근했는지?
+ 특정한 질문에 답하는데 필요한 스파이크를 작성해 잘 알지 못하거나 위험요소가 있는 부분을 프로토타이핑해봤는지?
+ 설계가 공식 또는 비공식적으로 다른 사람에 의해서 검토되었는지?
+ 구현이 분명해 보이는 지점까지 설계를 진행한건지?
+ 위키나 이메일, 플립차트, 슬랙, 캡쳐, UML, CRC 카드, 코드 내 주석등 다양한 기법을 사용해 작업을 기록했는지?


&emsp;&emsp;

#### 설계 목표

+ 설계가 아키텍처 레벨에서 식별되고 연기했던 문제를 적절히 해결하는지?
+ 설계가 계층화되었는지?
+ 프로그램이 서브시스템이나 패키지, 클래스로 분해되는 방법을 만족하는지?
+ 클래스가 다른 클래스와의 상호작요을 최소화하는 방향으로 설계되었는지?
+ 클래스와 서브시스템이 다른 시스템에 이식이 가능한지?
+ 프로그램이 유지보수 하기 쉬운지?
+ 설계에 군살이 없고 모든 부분이 엄격하게 필요한 것만 존재하는지?
+ 설계가 표준 기법을 사용하고 특이하거나 이해하기 어려운 요소를 피하는지?
+ 전체적으로 설계가 비본질적이고 본질적인 복잡성을 최소화하는 데 도움을 주는지?

&emsp;&emsp;

## 요점 정리

+ 소프트웨어의 주요 기술적 의무는 복잡성을 관리하는 것이다.
	+ 이는 단순함에 초점을 맞춘 설계가 큰 도움이 된다.
+ 단순함은 두 가지로 일반적인 방법으로 달성할 수 있다.
	+ 한 번에 뇌에서 처리해야 하는 본질적인 복잡성의 양을 최소화하는 것
	+ 부수적인 복잡성이 불필요하게 증가하지 않도록 하는 것
+ 설계는 발견적(경험) 학습이다.
	+ 여러 번 시도할 수록 최종 설계는 좋아져야한다.
+ 좋은 설계는 반복적이다. 여러번 시도할 수록 좋아질 것이다.
+ 정보 은닉은 매우 유용한 개념이며 무엇을 숨겨야하지? 라는 질문이 해결하기 어려운 설계상의 문제 대부분을 해결해준다.
+ 설계에 대한 수많은 유용하고 흥미로운 정보를 다른 자료에서도 구할 수 있다.
	+ 여기 내용은 빙산의 조각이다.