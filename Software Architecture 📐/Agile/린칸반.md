# 린/칸반

현재 소프트웨어 구축 방식을 이해하는 도구가 되는 마인드 셋

향후 개선된 프로세스로 발전하기 위한 방법


<br>

## 린

> lean은 마음가짐이다.

+ 설명
	스크럼도 가치를 제공하긴 하지만 정확한 체계를 알려주는 방면, 
	린은 오늘 일하는 방법을 찾아보고 어느 부분이 문제인지 파악하고 그 문제를 수정하기 위해 린 원칙을 적용하라고 강조한다.
	
	린은 현재 진행중인 프로세스의 어느 부분이 팀 목표에 부응하는 방법에 걸림돌이 되는지 알아보는 수단을 제공한다.

&emsp;&emsp;
### 호환성(확장성)

> 린, 스크럼, XP는 서로 섞어서 써도 괜찮다. 호환 되는 관계이다.

+ 설명
	린을 사용하기 위해 굳이 PO, SM을 둘 필요가 없다.
	
	스프린트 계획 수립 회의, 마지막날 회고를 할 필요도 없다.
	
	허나 XP, 스크럼 모두 린을 염두에 두고 개발되었다. 따라서 언제나 린은 적용이 가능하다.

<br>

### Lean Thinking

&emsp;&emsp;
#### 낭비 요소 제거하기

> 제품을 만들기 위해서는 많은 일을 수행해야한다. 꼭 필요한 일을 수행하고 한 팀에 완전 의존적인 업무라면 그 사이에 무엇이라도 관련 도움되는 업무를 수행하게 끔 해야한다.

&emsp;&emsp;
#### 학습 확대하기

> 지속적으로 반복하며 피드백을 사용하는 것이다.
> 
> 일하는 방식을 조금씩 변경하고 변경사항의 범위, 결과, 영향등을 관찰한 뒤 관찰 내용을 토대로 다음에 다시 어떻게 변경할 지 자주, 조금씩 시도해야한다.

&emsp;&emsp;
#### 가능하면 늦게 결정하기

> 가장 많은 정보를 갖고 있을 때, 가능하면 모든것을 경험해보기 위해 가능하면 늦게 결정해야 한다.
> 
> 섵부르게 결정해봐야 좋은 것은 없다.

&emsp;&emsp;
#### 가능하면 빨리 배포하기

> 프로젝트 지연에는 결국 더 많은 이슈(티켓)를 야기한다. 
> 
> 어느 부분에서 지연이 되는지 확인하기 위해 풀 모델을 만들어 업무의 제약 구역을 확인하고 
> 제약 이론에 기반해 병목이 일어나는 구간을 해소해야한다.


&emsp;&emsp;
#### 팀에게 권한 부여하기

> 팀이 일하는 방식은 현업에서 일하는 중인 현업자가 제일 잘아는 전문가이다.
> 
> 따라서 모든 팀원들로 하여금 프로젝트 목표, 진척 상황에 대한 것들에 대해 필요한 모든 정보에 접근할 수 있도록 해주어야한다.
> 
> (물론 회사 운영상 금기사항도 존재한다. 그건 당연히 제외해야한다. 연봉 테이블 등)


&emsp;&emsp;
#### 완전성 구축하기

> 최대한 사용자의 니즈에 충족하는 제품을 만들어야한다.
> 
> 필요도 하지 않을 기능, 피쳐를 집어넣는 것은 의미가 없다.


&emsp;&emsp;
#### 전체를 보기

> 팀이 프로젝트 작업을 어떻게 하는지 이해하기 위해 시간을 할애해야한다.
> 
> 그리고 측정 도구와 방법을 동원해 모든 사람들이 프로젝트에 대해 의사결정을 하는데 필요한 모든 정보를 최대한 노출시켜야한다.
> 
> 모든 팀원들은 다른 팀원이 하고 있는 작업을 이해하고 알아내는 순간 작업을 빠르게 완료하고 퀄리티 좋게 만들기 위해 가장 좋은 방법을 찾아 시도할 것이다. (그렇게 헌신하는 직원을 뽑았다면)


<br>

## 생각 도구

&emsp;&emsp;
### 낭비 요소 찾기

> 가치가 없는 행동을 하는 것은 당장 관둬야한다.

+ 설명
	아무도 보지 않는 서류, 자동화 하지 않아 가내 수공업으로 테스트하는 환경등등이 이에 속한다.

&emsp;&emsp;
### 가치 흐름 매핑하기

> 가치 흐름 맵을 만드면 프로세스에서 낭비요소를 찾는데 도움을 준다.

+ 설명
	+ 매핑 방법
		1. 백로그에서 고객이 중시하는 제품의 가장 작은 덩어리를 찾는다.
		2. 팀이 그 덩어리를 만들기 위해 밟은 모든 단계, 즉 처음 논의를 시작한 때부터 배포단계까지 되집어본다.
		3. 각 단계마다 상자로 만들고 화살표로 상자를 연결한다.
		4. 그다음 각 단계를 수행하는데 소요한 시간과 각 단계 사이에 대기했던 시간을 추적한다.
		5. 프로젝트 동작시 선은 위로, 프로젝트 동작 대기시 선은 아래로 내린다.
	
	+ 예시
		![[IMG_6F95FCE80497-1.jpeg]]

&emsp;&emsp;
### 대기 이론, Queuing threory

> 대기 행렬을 수학적으로 연구한 것

+ 설명
	대기 이론을 사용해 사람들이 너무 과도하지 않게 작업을 하도록 만들어야한다.
	
	이때 대기 행렬은 피처, 작업, 할 일 리스트가 해당된다.
	
	이때 작업들은 먼저 들어가는 작업이 완료되는 것이 일반적이다.
	
	린 팀은 이 대기 행렬의 순서를 투명하게 공개하고 프로세스의 의사결정을 팀이 하도록 만들어야한다.
	
	XP에서는 이와 비슷한 제약 이론을 엮어서 과도하지 않게 작업을 하도록 만드는 방법등을 설명하는데
	
	목표는 같지만 내용은 다르다.
	
	제약이론에서 제약은 병목과 같이 작업이 몰리는 현상을 말하며, 이론 내용은 다음과 같다. 
	
	제약은 무조건 하나 이상 존재하며, 절대 없어지지 않고 해소하면 다른 곳에 분산되어 나타난다는 이론이다.

### 풀 시스템(풀 모델)

> 팀에서 모든 작업을 하나의 백로그로 정리하고 개발자가 이전 작업을 완료하는 대로 새로운 작업을 선택한다면 이는 풀 시스템을 이용하는 것이다.

+ 설명
	풀 시스템이란 현재의 작업에서 이전의 작업에서 수행한 작업물을 끌어내(pull) 수행하는 시스템을 말한다.
	
	이때 백로그는 작업의 대기 행렬이다.
	
	+ 풀 시스템 동작 과정
		1. 사용자, 관리자, 제품 책임자가 작업 또는 요청사항을 팀에게 지시하는 대신 팀은 요청사항을 팀이 끌어올 수 있게 대기행렬에 추가한다.
		2. 풀 시스템은 한 번에 하나의 작업을 하고 작업자가 다음 작업이 가능해지면 다음 작업을 끌어온다.
		결과적으로 사람들은 자신들이 맡은 작업에 대해 가능한 최고의 작업만을 하도록 집중할 수 있다.

&emsp;&emsp;
### 옵션 생각

> 향후 배포에 어떤 피쳐가 포함될지 결정할 때 각 배포에 가치를 전달하기 위해 취할 옵션들에 대해 고민하는 행동

+ 설명
	예를 들면 스크럼에서 일일 스크럼을 진행할 때마다 수시로 작업을 추가할 수도 제거할 수도 있다.
	
	남은 프로젝트가 마감일을 넘기게 하는 늦은 작업 같은 것도 없다.
	
	**자신들의 작업 계획을 팀이 옵션으로 여기게 끔해서** 팀이 필요할 때 계획을 변경해서 너무 많은 책임을 지는 대신 **제품을 위해 가장 좋은 일을 선택적으로 할 수 있게**끔 해야한다.
	
	즉, 정말 필요한 업무가 아닌 다른 업무들은 옵션들로 생각해 추가할지 말지 잘 생각해야 한다는 뜻이다.

&emsp;&emsp;
### 지연의 대가

> 작업의 위헙도가 높을 수록 지연됬을 때 그에 대한 비용은 위험도가 낮은 작업보다 훨씬 높다.

+ 설명
	어떤 피처는 특정한 시간 내에 완료하지 못하면 전혀 소용이 없다.
	
	팀의 대기 행렬에 있는 **각 작업이 지연될 때의 대가를 이해하면** 어떤 작업을 먼저 완료해야하는지 더 나은 결정을 하는데 도움을 준다.
	
	린 팀은 새로운 피처를 배포하기 위해 배포 리듬을 만든다.
	
	즉, 특정 일정에 맞춰 피처를 배포하는 대신, 정기적인 간격으로 가장 가치 있는 것을 배포하는데 초점을 맞춘다.

&emsp;&emsp;
### 인지된 완전성과 개념적 완전성

> 린 팀은 항상 처음부터 제품에 완정성을 구축할 방법을 찾는다.

+ 설명
	+ 인지된 완전성은 피처가 사용자의 니즈에 얼마나 맞는지에 관한 생각이며, 개념적 완전성은 하나의 통합된 제품을 만들기 위해 각 피처들이 얼마나 잘 협업하는지에 관한 생각이다.

&emsp;&emsp;
### 세트 기반 개발

> set-based development를 실행할 때, 팀은 자신들의 옵션에 대해 시간을 들여 이야기하고 향후 옵션을 추가하기 위해 자신들이 일하는 방식을 변경한다.

+ 설명
	팀은 하나 이상의 옵션을 달성하기 위해 추가 작업을 하면서, 이런 추가 작업이 팀에게 더 많은 정보를 제공할 것이며, 이로 인해 향후 더 나은 의사 결정을 할 수 있을 것이라고 생각한다.
	
	그러게 함으로 한 번에 다양한 옵션에 관한 정보를 더 많이 수집하고 책임이 따르는 마지막 순간에 어떤 옵션을 완료할 지 의사결정을 한다.

<br>

## 측정 방법

> 스크럼 팀이 투명성, 점검, 적응에 중점을 두는 것 처럼 린은 변경사항을 적용하기 전에 시스템이 작동하는 방법을 측정하고 자신들이 실행한 변경사항으로 인한 영향을 측정한다.


&emsp;&emsp;
#### 주기, cycle time

> 개발자가 작업을 시작한 시점부터 배포하기까지 피처나 작업을 완료하기 위해 들인 시간

+ 특징
	개발 프로세스에 적용한 변경사항의 효과를 측정하는데 사용한다.

&emsp;&emsp;
#### 리드시간, lead time

> 피처를 식별한 시점부터 배포된 시점까지 걸린 시간,

+ 특징
	요구사항 수집과 지원 프로세스에 대한 변경사항을 측정하는 데 사용된다.

&emsp;&emsp;
#### 흐름 효율성, flow efficiency

> 팀에 피처에 대해 실제 작업한 총 시간을 퍼센테이지로 나타낸 것

+ 특징
	대기 시간의 반대 되는 시간에 대해 몇 퍼센트인지를 측정한 것

<br>

### 주기와 리드 시간

> 주기와 리드 시간은 두 개의 각기 다른 시각으로 프로세스를 생각하게 해준다.

+ 설명
	고객은 리드 시간에 관심이 있으며 일하는 팀원은 주기에 관심이 있을 것이다.
	
	**고객은 리드시간에만 관심을 가지고 있다는 점을 명심해야한다.**

<br>

## 소프트웨어 개발 7대 낭비 요소

> 프로젝트가 분명 늘어지고 제대로 돌아가지 않는다는 느낌이 들면 바로 낭비요소를 찾아봐야한다.
> 
> 아래의 7가지의 소프트웨어 개발시 낭비 요소들이 존재한다.

&emsp;&emsp;
### 일부만 완료된 작업

+ 설명
	프로젝트를 하다보면 그냥 이건 처음부터 다시 시작해야겠다 싶은 작업도 존재한다.
	
	이렇게 되면 제일 먼저 시작한 작업이 일부만 완료된 작업으로 남게 된다.

&emsp;&emsp;
### 추가 프로세스

> 소프트웨어를 개발하는데 그다지 도움이 되지 않으면서 팀에게 일만 추가하는 것

+ 설명
	특정 피처를 만들기 위한 기초 문서작업을 엄청나게 해놓고 고객에게 전달을 못하는 경우도 존재한다.
	
	가끔 팀이 임원의 지원을 받고 있음을 보여주기 위해 현황 보고 회의를 진행할 수도 있지만 결국 수많은 추가 프로세스만 만들어낸다.
	
	예를 들면 특별한 현황 보고서를 만들라고 하거나, 개발 중인 각 작업에 관한 정보를 정리하라고 요청하는 것 처럼 말이다.

&emsp;&emsp;
### 추가 피처

> 가끔 팀원 중 한명이 컨퍼런스에 참가했다가 정말 좋은 아이디어라고 생각하는 어느 피처를 들고 올 때가 있다.

+ 설명
	물론 이런 피처들이 검증되진 않았지만 우선 추가하자고 무작정 우길 수도 있다.
	
	그러나 이러한 기능들은 고객이 원하던 기능이 아닐 확률이 높고 이러한 새로운 피처를 만드는데에 시간을 빼앗기는 것이다.
	
	따라서 이런 아이디어는 검증되어야하며 옵션으로 제시될 필요가 있다.

&emsp;&emsp;
### 작업 전환

> 관리자들은 가끔 팀에게 요청한 요구사항의 수를 잊어버리곤 하며, 기대치를 조정하지 않고 추가 할 일을 주는 것은 비용에 들지 않는다고 착각한다.

+ 설명
	이러한 상황이 개발자들이 자신들의 상사나 팀원들에게 좋은 인상을 주기 위해 과도하게 몰입하고 싶어한다는 사실과 결합되면, 사람들이 모두 동시에 완료해야 하는 세 개, 네 개, 다섯 개, 또는 그 이상의 작업 사이에서 정신없이 허둥대는 모습을 보게된다.
	
	따라서 ==**작업 전환은 프로젝트에서 낭비 요소를 식별할 때 가장 유용한 개념이**==다. 
	
	**==일반적으로 소프트웨어 개발자는 두 개의 비슷한 우선순위에 대해 동시에 작업을 진행할 때 가장 많은 시간을 허비하기 때문이다.==**

&emsp;&emsp;
### 대기

+ 설명
	가끔 누가 명세서를 검토해주기를 기다려야하며, 검토가 끝날 때까지 일을 할 수 없는 경우들이 종종 존재한다.
	
	인프라팀에서 물리적인 하드웨어를 설치해주기 전까지 DBA가 데이터베이스를 제공하지 못하고 대기하는 경우도 있다.
	
	허나 이는 모두 낭비에 해당되므로 이를 전부 줄여야한다.

&emsp;&emsp;
### 동작

> 작업을 수행하는 동안 돌아다니면서 허비하는 모든 시간을 의미한다.

+ 설명
	예를 들면 화장실, 담배, 물 뜨러가는 시간, 누구를 찾으러 책상을 떠나 다른 책상으로 움직이는 시간 등등 전부 허비되는 시간이다.
	
	화장실이나 물은 그렇다고 해도 특히나 담배는 세어보면 1년에 한달가까이 담배 피러 밖에 나가는 시간이 존재한다고 한다.
	
	이런 것도 낭비에 해당한다.

&emsp;&emsp;
### 결함

> 결함은 테스트 프로세스를 거치면서 발견하는 것보다 그 결함을 만든 개발자가 고치게끔 하는 것이 더 좋다.

+ 설명
	타인이 버그를 고치는 것보단 직접 짠 사람이 코드를 보면 히스토리가 떠올라 어디에서 실수를 했는지 알기가 쉽다.
	
	거기에 코드 소유권을 공유하게 되면 결함을 수정하는데 걸리는 시간은 훨씬 더 줄어들게 된다.
	
	물론 난 이 책 내용을 공감하진 않는다.
	
	결함을 자주 만드는 팀원은 대체적으로 테스트 코드도 잘 못 만든다는 의견들도 많기 때문이다.

<br>

## 가치 흐름 맵

![[IMG_6F95FCE80497-1.jpeg]]

> 단순한 다이어그램이지만 프로젝트를 진행하면서 정확히 얼만큼 대기하며 시간을 낭비하는지 보여주며 
> 불 필요한 부분이 어디서 일의 진척을 느리게 하는지 보여주기 위해, 팀이 사용하는 프로세스를 타임라인에 그리는 것이다.
> 
> 팀의 시간이 고객을 위한 가치로 이어지지 않는 작업에 얼마나 허비되는지 잘 보여준다.

+ 설명
	+ 가치 흐름 맵은 시작부터 끝까지 특정 피처가 밟은 모든 단계를 보여준다.
		+ 각각 단게는 맵의 윗 부분 상자로 나타낸다.
		+ 이 내용은 팀이 계획한 워크플로와 상이할 수 있다.
	+ 가치 흐름 매핑의 목표는 작업 시간과 불필요한 시간 사이의 균형을 이해하는데 도움을 주는 것이다.
		+ 불필요한 부분을 제거하는 것이 중요하다.
	+ 일반적으로 가치 흐름을 백분율로 표현한다.
		+ 100 * 작업 시간 / 리드 시간 %
	+ 가치 흐름 맵은 가장 **최근 피처를 기준으로 잡아야한다.**



<br>

## 토요타 생산 시스템 , TPS

> TPS는 생산 시스템에 대한 새로운 사고방식이다.


### 낭비 요소의 세 가지 원천

&emsp;&emsp;
#### 무다

> 허망함, 소용 없음, 빈둥거림, 불필요함, 쓰레기, 낭비, 헛됨

&emsp;&emsp;
#### 무라

> 불공평함, 비주기적임, 통일성의 부재, 균일하지 않음, 불평등

&emsp;&emsp;
#### 무리

> 비이성적, 불가능, 본인 능력 이상 요구, 너무 어려움, 힘에 의한, 강제적인, 물리적으로, 필수적으로, 과다함, 무절제

<br>

### 제조현장의 7대 낭비 요소

&emsp;&emsp;
#### 운반


&emsp;&emsp;
#### 재고


&emsp;&emsp;
#### 과잉생산


&emsp;&emsp;
#### 동작


&emsp;&emsp;
#### 대기


&emsp;&emsp;
#### 결함


&emsp;&emsp;
#### 추가 프로세스


<br>

### 가치 흐름, 지속적인 향상, 품질의 기본 개념

&emsp;&emsp;
#### 지도카

> 문제 발견시 바로 해당 라인 생산을 중지하는 자동화된 방법

&emsp;&emsp;
#### 칸반

> 신호카드, 
> 
> TPS에서는 신호 카드는 프로세스의 어떤 단계가 더 많은 재고를 받아들일 준비가 됐음을 알리기 위해 사용

&emsp;&emsp;
#### 풀 시스템(모델)

> 각 단계에서 어떤 부품의 재고가 떨어지면 각 전 단계에게 더 많은 재고가 필요하다고 요청하는 방식
> 
> 이렇게 되면 '무다'를 방지한다.


&emsp;&emsp;
#### 근본 원인 분석

> 5 whys 기법으로 문제를 일으키는 원인을 분석한다. 5 번 정도 왜 그랬는지 되물어가며 원인을 찾는 것이다.

&emsp;&emsp;
#### 카이젠

> 지속적인 개선,
> 
> 매일 모든 기능을 개선하는 활동이 자리 잡으려면 팀 전체가 작업흐름에서 어떤 일이 일어나는지 관심을 갖고 개선할 방법에 대해 생각한다.

<br>

## 옵션 분석하기


&emsp;&emsp;
### 분석 과정

1. 목표를 정의하고 거기에 전념한다.
2. 목표를 달성하는 데 필요한 작업을 설정하되 작업 완료를 목표를 달성하기 위한 **하나의 옵션**으로 간주한다.
3. 작업을 시작한다.
4. 필요하면 계획을 변경한다.


<br>

## 시스템 싱킹

> 각자 개인의 임무가 더 큰 시스템의 일부라는 것을 인식하고 시스템을 바라보는 것을 **전체를 본다**고 표현한다.

+ 설명
	모든 사람들은 전체를 함께 보면 팀 전체를 함께 개선할 수 있다.
	
	지엽적인 최적화(remove local optimizations)를 제거하고 시스템을 다같이 최적화 해야한다.


<br>

## 개선 작업이 효과가 없는 경우

### 실패한 경험

> 이러한 실패한 경험들은 전부 시스템에 도움이 되는 좋은 경험들이니 주눅들지 말고 계속 나아가야 한다.


<br>

## 풀 시스템

> 전통적인 팀은 시스템에 작업을 밀어 넣지만 린 팀은 풀 시스템을 사용해 각 단계의 작업이 바로 전 단계의 작업을 이끌어내어 신속하게 피쳐를 마무리 짓는다.


### WIP 제한

> WIP(work inprogress)란 당장 진행중인 작업을 의미한다.

+ 설명
	풀 시스템은 WIP에 제한을 두어 시스템 내 각 단계별로 주어진 시간에 할 수 있는 작업 아이템의 수를 제한하여 제약의 위치를 골고루 분배해야한다.
	
	+ 예시
		한번에 4개씩 테스트만 할 수 있는 QA팀이 존재한다. 이때 개발팀은 WIP 제한을 한번에 4개씩만 피처를 개발하도록 제한한다.


<br>

## 칸반

> 프로세스를 개선하기 위한 방법
> 
> 데이비드 앤더슨이 마이크로소프트와 코비스에서 근무하던 시절, 린 아이디어를 처음으로 실험하면서 만들었다.

+ 특징
	+ 린 마인드셋을 기반으로한다.
	+ 어떻게 일해야하는지 알아야하는 역할이나 특정 프로젝트 관리, 개발 프랙티스를 규정하지 않는다.
	+ 시스템 내 작업 흐름을 파악하고 풀 시스템을 정의한다.
	+ 낭비 요소를 제거하는데 도움이 되도록 작은 변화와 함께 WIP 제한을 두는 실험을 하며 일하는 방식을 관찰한다.

&emsp;&emsp;
### 칸반 핵심 프랙티스

&emsp;&emsp;
#### 워크플로우 시각화하기

> 칸반 팀이 전체를 보기 위해 가장 먼저하는 일

+ 설명
	자신들이 현재 수행하는 작업 방식을 살펴보고 워크플로를 정확한 시각적 표식으로 만든다.

&emsp;&emsp;
#### WIP 제한하기

+ 설명
	대부분의 작업이 워크플로의 어느 부분에 있는지 팀이 제대로 파악하고 나면 WIP 제한이 팀을 더 집중하게 해주고 일을 완료하는데 도움이 되는지 WIP 제한을 실험해볼 수 있다.

&emsp;&emsp;
#### 흐름 관리하기

+ 설명
	팀이 프로세스를 통해 얼마나 신속하게 작업을 완료할 수 있는지에 고나심을 갖고 시스템의 흐름을 관리할 수 있다.


&emsp;&emsp;
#### 프로세스 정책을 명시적으로 만들기

+ 설명
	- 팀이 흐름을 가지고 일하는 방식을 배우고 작업하는데 도움이 될만한 정책을 팀이 직접 설정한다.
	- 칸반 팀은 그 정책에 대해 서로 이야기해야 한다는 점을 명확히 인지하고 필요하다면 그 정책을 평가하고 변경한다.

&emsp;&emsp;
#### 피드백 순환고리 구현하기

> 모든 정책과 개선사항에 대한 것

+ 설명
	팀이 효과를 측정하고 제대로 동작하는지 확인하기 위한 점검 사항들을 구현하는 것

&emsp;&emsp;
#### 협력적으로 개선하고 실험적으로 진화하기

> 명시적인 정책을 설정해 피드백 순환고리를 만든다.

+ 설명
	팀이 프로세스를 지속적으로 개선하기 위해 협업하고 그것을 더 효율적으롬 만들어주는 빌딩 블럭이 된다.



<br>

## 칸반보드 사용법


### 테스트 보드

![[IMG_B5E092BFD941-1.jpeg]]

+ 특징
	+ 보드의 모든 작업의 상태를 공유를 위해 나타낸다.
	+ 진척 상황을 추적하고 계획대로 진행되지 않을 경우 조정하는 데 사용할 수 있다.
	+ 스프린트나 프로젝트 증분 내의 작업을 팀에게 명확하고 투명하게 보여준다.
	+ 우선순위를 나타내고 팀원들이 자기조직하도록 지원한다.


<br>

### 칸반 보드

![[IMG_1F256E32A37D-1.jpeg]]

+ 특징
	+ 보드에 모든 피처의 상태를 나타낸다.
	+ WIP 제한을 명확히 제시하여 제한에 도달한 상태에서 새로운 작업이 들어가지 않게 한다.
	+ 팀이 정한 워크플로우 상태와 일치시킨다.
	+ 흐름을 보여주고, 프로세스에 작은 변화를 주면서 실험 할 수 있도록 팀을 도와준다.

&emsp;&emsp;
#### 칸반 주의점

팀이 프로세스 단계에 맞는 WIP 제한을 설정하기로 하면, 칸반 보드 제일 위 칸에 그 제한을 적어 해당 칸의 작업 아이템의 숫자가 절대로 제한을 넘지 않도록 한다.

<br>

## 칸반 프로세스 개선 과정

&emsp;&emsp;
1. 워크플로우 시각화하기
2. WIP 제한하기
3. 흐름 관리하기
4. 프로세스 정책을 명시적으로 만들기
5. 피드백 순환고리 구현하기
6. 협력적으로 개선하기


<br>

## WIP 제한 이유

새 피처를 계속해서 작업을 하다 보면 어느 상태에서 분명 작업들이 쌓이는 구간이 생기게 된다.

이렇게 되면 결국 완성된 피처보다 반쪽짜리 피처들로 산이 쌓이게 된다.

차라리 **한가지 작업에 최대한 집중해 확실하게 통과 시키기 위해** 이 WIP 제한을 거는 것이다.

<br>

## 워크플로

> **시각화**에 앞서 먼저 각 단계를 그림으로 그리기 위해 워크플로를 구성해야한다.


![[IMG_1F256E32A37D-1.jpeg]]

### 워크 플로 예시

&emsp;&emsp;
#### 정의

> PO가 유저로부터 피처에 대한 요구사항을 받고 스토리를 작성한다.

&emsp;&emsp;
#### 계획

> 팀은 다음 배포를 위한 피처를 결정한다.

&emsp;&emsp;
#### 빌드 및 테스트

> 팀은 피처를 구축하고 코드를 검토한다.

&emsp;&emsp;
#### 통합

> 팀은 통합된 피처를 테스트하고 버그를 수정한다.

&emsp;&emsp;
#### 사용자 인수 테스트

> 최종 사용자가 피처를 평가한다.

&emsp;&emsp;
#### 완료

> 피처를 그 다음 릴리즈에 포함하고 배포한다.

<br>

### 주의 할 점

칸반은 스크럼의 테스크 보드와는 성격이 다르다.

테스크 보드는 **피처를 추적**하기 위해 나타내는 것이고

칸반은 **워크플로의 상태를 이해하기 위해** 나타내는 것이다.

가장 좋은 방식은 스크럼에도 칸반을 같이 사용하는 것이다.

지라에서는 테스크 보드만 사용하지 않고 상태 워크플로를 같이 만드는 것도 방법이다.
<br>

## 누적흐름도, Cumulative Flow Diagram CFD

> 시스템에 의해 불필요한 일을 추가하고 흐름을 방해하는 요인을 알아내는 차트이다

+ 설명
	시간이 지남에 따라 각 상태에 있는 작업 아이템들의 개수를 차트로 만들고 차트를 이용해 팀의 작업량(throughput)에 영향을 미칠 수 있는 패턴을 찾는다.
	
	결론적으로 CFD를 사용하면 프로세스 및 정책 변경의 영향을 빠르게 파악할 수 있다.
	
	![[IMG_BEFC205EE098-1.jpeg]]

<br>

## 정책 수립

> 프로세스 단계를 정의하고 나면 정책이 필요하게 된다. 제대로 된 규칙이 없으면 팀은 금새 잘못된 방향으로 진행된다.

### 협의서, working agreement

+ 예시
	+ 오디언스 분석팀 협의서
		+ 모든 팀원은 추정에 참여하고 모두가 동의한 스토리 포인트 기준을 사용한다.
		+ 하나의 작업 아이템을 끝낸 팀원은 다음에 작업할 수 있는 백로그에서 가장 우선순위가 높은 아이템을 선택한다.
		+ 그 누구도 WIP 제한에 다다른 상태에서 작업 아이템을 추가하지 않는다.
		+ 모든 작업 아이템이 완료된 것으로 간주되기 위해서는 완료의 정의를 충족시켜야한다.
		+ 그 누구도 백로그에 없는 작업 아이템을 수행하지 않는다.

<br>

## 피드백 순환고리

> 칸반 팀은 자신들이 만드는 모든 변화의 영향을 측정할 피드백 순환 고리를 명시적으로 만들어야한다.

+ 설명
	+ 측정을 통해 피드백 순환고리를 만들고 측정을 통해 나온 데이터를 토대로 다시 자신 팀에 변화를 준다.
	+ 위 과정을 계속해서 반복적으로 지속하여 지속적인 개선 문화를 만들어야한다.
	+ 모든 사람들이 측정과 변경을 반복하다보면 자연스레 각 프로세스의 변화를 자체적인 실험으로 보기 시작한다.

&emsp;&emsp;
### 주의 할 점

리드 시간을 이용해 피드백 순환 고리를 만들어야한다.

예를 들면 매 주 목요일마다 각자 다른 프로젝트를 진행해보겠다고 한다.

그렇다면 두 번의 릴리즈 동안 새로운 이 시도를 도입해보고 그 정책을 도입하기 전과 후의 리드시간을 측정하여 영향을 파악한다.