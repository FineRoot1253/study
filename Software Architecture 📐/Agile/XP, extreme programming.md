# XP, extreme programming

![[2. Area 🔥/Software Architecture 📐/Agile/XP, extreme programming/Untitled.png]]

![[iteration.gif]]

![[development.gif]]

주로 스크럼과 함께 사용되는 프로그래밍 개발기법

소프트웨어 개발 및 프로그래밍에 중점을 둔 방법론

### 왜 XP인지?

BigDesignUpFront라는 일반적으로 코딩 및 테스트가 수행되기 전에 거대한 세부 설계가 생성되는 소프트웨어 개발 방법이 있다.

XP 지지자들은 이 설계과정은 의미가 없으며 대부분의 설계는 개발 프로세스 전반에 걸쳐 이루어져야 한다고 생각한다.

XP는 SystemMetaphor를 제외한 설계개념이 전무하다.

## 주요 구성

- 구성
    1. 반복적이고 점진적인 방법론으로 분기별 주기, quarterly cycle를 사용해 백로그를 계획하고
    주간 주기, weekly cycle라는 반복 작업으로 나눈다.
    2. 슬랙, slack이라는 프랙티스로 각 반복에 추가로 할 일을 추가한다.

### 요구사항 추적

스토리를 핵심 프랙티스로 사용하며 이를 활용해 요구사항을 추적한다.

스토리를 만들고 포인트를 추정하는 과정도 스크럼과 동일하다.

### 분기별 주기, quarterly cycle

XP에서는 분기별로 프랙티스를 수행한다.

이에 1년에 4번 계획 수립과 반영을 위한 회의를 진행한다.

- 구성
    1. 지난 분기에 무슨 일이 있었는지 회고한다.
    2. 큰 그림에 관해 이야기한다. 이때 회사가 집중하는 것은 무엇이고 팀이 거기에 어떻게 맞춰갈지 이야기한다.
    3. 장기 목표를 추적하기 위해 해당 분기에 맞는 테마,theme를 계획한다.
    이때 테마는 스토리를 그룹으로 묶는 데 사용하는 전형적인 목표이다.
    4. 다음 분기에 수행할 가치가 있는 스토리를 선택하기 위해 사용자 및 이해관계자와 함께 만나 해당 분기에 대한 백로그를 계획한다.
- 특징

    스크럼과의 스프린트 계획 수립 세션과 차이점은 주기와 테마의 존재이다.

    이 테마는 흐름을 놓치지 않기 위해 사용되며 스크럼의 스프린트 목표와도 같다.


### 주간 주기, weekly cycle

XP팀이 스토리를 정하고 작동하는 소프트웨어를 만들어 그 주의 마지막에 완료되는 일주일 단위 사이클이다.

각 주기는 작동하는 소프트웨어를 시연하고 달성할 목표를 계획한다.

- 구성
    1. 지금까지 진행 상황을 검토하고 정확히 지난 한 주간 작업한 데모를 시연한다.
    2. 고객과 함께 이번 주에 할 스토리를 선정한다.
    3. 스토리를 태스크로 분할한다.
- 특징
    1. 주간 주기를 계획할 때 개별 테스크를 할당하기도 하고
    테스크 더미를 만들어 놓고 각 팀원이 그 더미에서 다음에 할 테스크를 뽑는 자기조직을 만들기도 한다.
    2. 매주 같은 날, 주로 화요일이나 수요일에 시작하고
    (주말에 일해야 하는 부담을 느끼지 않기 위해 월요일은 피한다.)
    계획 수립 세션도 매주 같은 시간에 열린다.
    3. 고객이 회의에 참석해 XP팀이 스토리를 고르고 진행 상황을 통제하는 데 도움을 준다.

### 슬랙, slack

계획 수립 세션마다 일정에 뒤쳐지거나 제거할 수 있는 선택적이고 그다지 중요하지 않은 아이템,

이 아이템을 몇개 넣어 슬랙을 추가할 수 있다.

- 예시
    1. 있으면 좋은 스토리를 주간 주기에 포함시킨다.
    2. 특정 분기를 핵 데이, hack day 또는 괴짜 주간, geek week으로 막고 이것만 진행한다.
        이때는 프로젝트에 관련되지만 주로 지체되는 작업들을 수행하며
        어딘가 숨어있거나 슬랙으로 추가해놓고 잊고 있던 좋은 아이디어 아이템을 후속조치로 진행한다.

- 주의점
    이 슬랙은 1~2개 정도만 추가해야하며 많아도 주간 주기의 20% 이상을 차지하면 안된다.


### 이상적 프로그래밍 처리 시간, Ideal Programming Time

정확히 프로그래밍만 처리하는데 소요되는 시간을 의미한다.

### 부하 계수, LoadFactor

이 부하 계수란 이상적으로 처리하는 프로그래밍 시간에 곱연산을 해 실제 소요되는 작업시간을 계산하는 일종의 상수이다.

많은 선배개발자들이 과거에 1.3, 2.5, 3 등등 여러 상수를 주장하였는데

실제로 이 부하율을 통한 일정 산정은 실무에서도 자주 사용되지만 이는 사실 어처구니 없는 계수이다.

실제 프로젝트를 진행함에 있어서 불확실하게 요구사항이 변경되는 현실을 전혀 생각하지 않은 계수이다.

그저 한때 저명한 개발자나 PM들이 주장하는 상수에 불과하며

이는 스크럼의 스토리 포인트에 비하면 너무나 불확실성을 염두하지 않은 상수이다.

### 프로젝트 진척도, ProjectVelocity

이벤트 발생 빈도,

프로젝트의 생산성 측정 용도나 프로젝트의 실제 진행 속도를 측정하기 위해 사용된다.

이 측정을 제대로 한다면 프로젝트에서 큰 구멍을 발견할 수 있다.

스크럼의 진척도와 흡사하다.

### Chrysler Comprehensive Compensation

줄여서 C3라고 말하는 이 크라이슬러의 급여체계 자동화 시스템을 의미하며,

XP의 저자인 켄트백님이 XP를 탄생시킨 프로젝트로
수많은 개발자와 PM들에게 예시로써 영감을 주는 프로젝트이다.

## XP 마음 가짐

### 용기

> 팀원 개개인은 프로젝트를 위해 싸울 용기가 있어야한다.

예를 들면 절대 불가능한 기한을 맞추기 위해 가능하다고 거짓말하지 않고 불가능하다고 진실을 얘기하는 용기가 필요하다.

### 존중

> 팀원 개개인들은 서로 존중하고 서로 하는 업무에 대한 신뢰를 갖고 있다.

예를 들면 구현이 불가능해보이는 어처구니 없는 이야기를 팀원이 꺼내도 우선 그 의견을 경청하고 그에 대한 차선책을 고려해보는 것만 해도 존중의 첫 걸음이다.

### 의사소통

> XP는 팀원 간 의사 소통에 강하게 집중한다.

+ 특징
	+ XP는 정보 라이데이터라는 팀 공간에 정보를 공유하는 공간으로 만든다.
		한 화이트보드에 지금 진행죽인 작업을 모두에게 발산한다.
	+ XP는 삼투적 의사 소통을 활용한다.
		옆자리에 바로 앉아 있기 때문에 지금 당장 진행 중인 업무가 취소 되거나 당장 스파이크로 하나 새 기능을 만들어서 보여줘야하는 등 바로바로 알 수 있게 된다.
		우리 나라에서는 "어께너머로 들었다"라는 표현을 주로 쓰는 의사소통이라고 보면 된다.
		사실 이 상황에 코딩을 할 땐 두 귀를 막고 진행하는게 잘되서 두 귀를 막는 것을 막지 말라는 조언도 존재한다.


+ 코드 몽키의 오해
	혼자서 독방에 앉아 몇시간씩 코딩을 하는 것이 개발을 효율적으로 하는 것이라고 착각하는 개발자가 정말 많다.
	
	그러나 제대로 된 상호소통과 피드백이 없는 개발 진행은 다음주에 "다시해와요"라는 결과를 낳는 경우가 허다하다.
	
	

### 피드백

> 의사소통에 뒤따르는 피드백은 필수적이다.

피드백 없는 의견, 프로젝트는 가치가 없다.

+ 피드백의 유형
	+ 반복
	+ 코드 통합, CI
	+ 팀원 리뷰
	+ 유닛 테스트

+ 피드백 순환 고리
	+ 페어 프로그래밍
	+ 10분 빌드
	+ 지속적 통합
		이 지속적 통합은 단순히 빌드 서버에 코드를 통합하는 것이 아닌 내 로컬 소스에 매 순간 다른 동료가 **다른 피처를 머지할 때마다 바로바로 받아서 반영하는 것**을 말한다.
		소스에 업데이트가 일어나면 즉시 최신화를 하자는 의미이다.
	+ 테스트 주도 개발

+ 와이어프레임과 스파이크 솔루션
	+ 와이어프레임
		단순히 손으로 그린 UI를 의미한다. 
		일반적으로 종이에 그려 기존 UI에서 변화를 제시할때 사용되며 그렇기 때문에 부정확하다
		참고로 가장 사용자 인터페이스 피드백을 잘 받는 방법은 유저로 하여금 직접 UI를 사용하게끔 만드는 것이다.
		요즘엔 피그마가 있어서 참 피드백을 빨리 얻기 좋다.
	+ 스파이크 솔루션
		팀이 기술적 문제를 해결하는데 스파이크를 만들어 문제를 파악하기 위해 즉각적으로 만들어보는 코드를 말한다.
		일반적으로 이런 코드는 써본 뒤 버려진다.
		+ 아키텍처 스파이크
			일반적인 스파이크로 특정 기술적 접근법이 효과가 있는지 확인하는데 사용된다.
			예를 들면 특정 기술만 테스트 해보는 데모 프로그램이 대표적이다.
			특정 기술적 해법을 설계하는데 선택사항이 여러가지이거나 이 솔루션이 효과가 있는지 모르겠을 때 사용된다.
		+ 위험 기반 스파이크
			프로젝트가 가끔 궤도에서 벗어나 위험에 노출되는 순간에 사용된다.
			아키텍처 스파이크와 동일하게 제작되지만 위험을 제거하기 위함으로 사용된다.
		
		이러한 스파이크들은 실패를 하더라도 실패 할 것을 알았으니 성공으로 여긴다.


### 단순성

> 지금 현재 필요한 것만 수행하고 다른건 절대 더해서 하지 않는다.

+ 특징
	+ 코드를 더욱 단순하게 분할하고 냄새가 나면 여유가 있다면 즉시 리펙토링을 진행한다.
	+ **일반적으로 앞서 설명한 슬랙에 이 리펙토링을 진행하는 경우가 대다수이다.**
	+ 설계를 점진적으로 설계해야 단순성이 유지된다.
	+ 

# XP 12가지 프렉티스

## Fine scale feedback

### Pair Programming

2명의 엔지니어가 하나의 워크스테이션에서 하나의 개발에 참여하는 XP 프랙티스

- 특징
    1. 2명다 하나의 작업만을 수행하지 않고 동시에 다른 부분을 작업해야한다.
        예를 틀면 유닛 테스트를 만드는 동안 다른 한 사람은 이 유닛 테스트의 들어갈 mock클래스를 생각해낸다.
    2. 이때 한명은 시니어, 나머지 한명은 주니어인 경우가 좋으며 정확히 어떤 티켓의 작은 작업 단위에 대해 진행하는 것이 좋다.
    3. 경험 많은 개발자가 경험이 적은 개발자에게 가르칠 수 있는 효과적인 방법이다.
    물론 이는 쌍으로 번갈아 가며 코딩을 하고 그 과정에서 주니어가 배우는 것이다.
    4. 경험이 적은 개발자는 핵심을 벗어난 엉뚱한 얘기를 꺼내기도 하고 멍청한 솔루션을 제안할 수도 있다.
        이때 주니어의 성장에 중요한 것은 이런 내용이 나오면 다그치는 것이 아닌
        더 나은 솔루션을 제안하고 가르치는 것이 중요하다.
    5. 실제코딩 시간의 60%이상은 생각하는 시간이다. 페어 프로그래밍은 이 시간을 확실하게 줄여주는 프렉티스이다.
    6. 그래서 2명 다 하나의 작업을 수행하는 것이 아닌 다른 영역을 동시에 생각해서 코딩하는 것이며 서로서로 짠 코드를 확인하고 더 나은 방안을 제시하고 주니어는 성장하는 이런 과정이다.
- 장단점
    - 장점
        - 평균적으로 15% 더 적은 버그를 만들어낸다.
        - 한사람이 짜는 코드보다 2배 더 효율적인 코드를 만들어낸다.
        - 주니어의 빠른 성장에 큰 도움을 준다.
    - 단점
        - 굳이 페어링을 하지 않고도 코드리뷰로도 검증이 가능하다.
            솔로로 진행하면서 수시로 피드백을 받는 여건이 된다면 그냥 혼자해도 상관없다.
        - 주니어 혼자 코딩하고 시니어는 옆에서 지시만하는 일종의 드라이버 + 네비게이터의 관계가 된다면
            의미가 전혀없는 시간 낭비가 된다.
            보통 아래 2가지의 경우가 보편적이며 최악의 케이스라고 볼 수 있다.
            - 예시
                1. 주니어는 이해 1도 못했지만 그냥 시키는 대로 따라치고 시니어는 지시만 하는 경우
                2. 주니어가 바보같은 소리를 한다고 해서 구박과 함께 내가 할태니 나가보라며 면박을 주는 경우
- 주의점

    단점에 적어둔 LetTheJuniorDrive라는 안티패턴으로 전락할 가능성이 매우 크다.
    요즘은 그냥 코드 리뷰로도 충분히 케어가 가능하다.
    이 페어프로그래밍이 나온 시점엔 깃허브가 없던 시절이라는 점을 감안하고 XP를 공부해야한다.
    다만 주니어의 실력을 키우는 목적이라면 모든 경험자가 입을 모아 좋다고 추천하는 프랙티스이다.

<br>

### Planning Game

![[2. Area 🔥/Software Architecture 📐/Agile/XP, extreme programming/Untitled 1.png]]

계획 수립시 유저 스토리를 가지고 팀원들끼리 진행하는 게임

#### 특징
1. XP는 OOA의 산출물인 유스케이스를 사용하지 않고 유저스토리를 사용한다. 이것은 스크럼과 차이가 없다.
2. 플레이어는 기획(사업)팀과 개발팀으로 나뉜다.
3. 모든 플레이 세부 단계는 유저스토리로 진행되며 각 스토리는 인덱스카드에 기록한다.
4. 모든 스토리에는 벨류와 코스트가 존재하며 일부 벨류는 다른 스토리에 의존적인 형태를 띄기도 하며
개발을 진행하다보니 벨류와 코스트가 높아지거나 낮아질 수도 있다.
5. 목표는 게임이 진행되는 동안 가능한 최대 가치의 스토리를 개발해내는 것이다.

#### 진행 과정

- 탐색 단계
	1. 기획팀은 언제든 새 스토리를 작성한다.
	   이때 이 게임을 위해 스토리를 작성하는 것은
	   스토리 작성시밸류와 코스트를 함께 할당한다는 의미이며
	   이때 코스트는 개발에 충분한 경험을 겪어보고 정보가 많은 상태일때만 함께 할당이 가능하다.
	2. 개발팀은 모든 스토리를 가져와 이상적 프로그래밍 처리 시간을 기준으로
	 1, 2주 또는 3주의 코스트를 할당한다.
	
	 이때 추정치가 더 높다면 기획팀에서 더 스토리를 분할해 달라고 요청해야한다.
	   
	만약 추정치가 1주보다도 낮다면 최소 1주가 될때 까지 이러한 낮은 추정치의 스토리끼리 병합해 달라고 요청해야한다.
	 
	마지막으로 이상적 프로그래밍 처리시간으로 할당한 코스트에 각각 부하 계수로써 3을 곱한다.
	   
	그리고 이것을 최종 일정으로 지정한다.

- 전념(몰입 또는 헌신) 단계
	기획팀과 개발팀이 함께 협력하여 다음 릴리즈를 구성하는 스토리와 프로덕션에 투입할 준비가 되는 시기를 결정한다.
	전념을 추진하는 방법은 2가지 방법이 있다.
	- 스토리 중심 전념
		1. 기획팀은 다음 릴리즈를 위한 스토리를 테이블에 올리기 시작한다.
		2. 각 스토리를 소개하면 개발팀에서 릴리즈 날짜를 추정하고 다시 이 날짜를 소개한다.
		3. 기획팀이 테이블의 스토리가 다음 릴리즈에 적합하다고 판단할때까지 1과 2를 반복한다.
	- 날짜 기반 전념
		1. 기획팀에서 릴리즈 날짜를 선택한다.
		2. 개발팀은 현재와 릴리즈 날짜 사이 달성 가능한 스토리의 누적 코스트를 계산하고 전달한다.
		3. 기획팀은 코스트가 해당 숫자에 합산되는 스토리를 선택한다.
	이후 몰입(전념)할 범위를 선택한 뒤 조종 단계중 반복단계에 진입한다.

- 조종 단계
	- 반복 구간
		1. 기획팀은 구현할 스토리들을 픽한다.
		2. 개발팀은  플래닝 게임 반복한다.
			+ 기획팀이 새 스토리를 원하게 된다면 
				+ 스토리를 새로 만들고 탐색 단계의 2번 단계로 이동한다.
			+ 스토리 처리 수행 능력(가속도)을 측정해보니 예상보다 낮은 수준을 머무르는 경우
				+ 개발팀에서 스토리중 진행할 스토리만 고르고 나머지는 다시 탐색 단계의 2번 단계로 넘긴다.
			+ 추정치가 부정확한 경우
				+ 개발팀에서 다시 스토리의 추정치를 다시 측정한 다음 탐색 단계의 2번 단계로 넘긴다.
		3. 기능 테스트를 돌린다.
			테스트가 끝나면 산출물이 나온다.

- 기타 진행 행동들
    - 벨류와 위험 우선 처리
        개발팀은 스토리의 우선순위를 지정할 때 벨류와 리스크를 우선시한다.
        - 우선 순위 예시
            1. 만약 완전히 작동하지만 러프한 시스템은 몇 주 내로 즉시 완료시킨다.
            2. 더 가치가 잇는 스토리는 일정보다 일찍 이동시킨다.
            3. 더 위험하다고 판단되는 스토리는 일정보다 일찍 이동시킨다.
    - 과몰입 복구
        개발팀이 현재와 마감일 사이 150 정도의 스토리를 진행 가능하다고 예측했지만
        프로젝트 진척도를 기반으로 100 밖에 못하겠다는 사실을 발견한 즉시 발표한다.
        기획팀은 이때 우선완료시킬 100의 스토리를 선택하고 나머지는 향후 릴리즈로 연기한다.
    - 벨류 변화
        기획팀은 스토리의 가치가 때에 따라 변동된다면 보드에서 이를 변경시킨다.
        개발팀은 이에 따라 우선순위를 변경해야한다.
    - 새로운 스토리 소개
        기획팀은 새로운 스토리를 작성해야하고 개발팀은 이것을 다시 비용을 추정해야한다.
    - 스토리 분할
        기획팀은 스토리를 2개 이상으로 분할할 수 있고 그 다음 각각 벨류를 할당한다.
        분할 이후 개발팀은 코스트를 할당한다.
    - 스파이크
        스파이크란 스크럼의 워킹 스켈레톤의 기능을 갖춘 작동하는 소프트웨어와 같다.
        MVP라고 보면된다.
        XP에서 기획팀은 급한 불을 끄거나 핵심 유저스토리의 개념을 증명하기 위해
        일회용 스파이크를 수행하도록 프로젝트 자원을 전환할 수도 있다.
        우선 이 스파이크부터 당장 만들도록 우선순위를 뒤바꾸는 것이다.
        이 스파이크가 단순히 일시적인 수정 그 이상일 경우 기획팀은 이를 잘 설명하기 위해
        이를 위한 유저스토리를 만들고 이 스토리는 벨류와 위험 우선 처리의 워크플로를 따라 우선순위가 배정된다.
        일반적인 급한 불을 끄기 위한 스파이크는 부하 단계의 영향을 받는다.

- 재추정
	개발팀은 전념단계중 나머지 스토리를 다시 추정한다.
	허나 이는 과몰입 복구를 야기할 수 있어 조심해서 추정해야한다.

<br>

### Test Driven Development

단위 테스트는 가장 작은 기능을 테스트 해볼 수 있는 테스트 수단 

+ XP 단위 테스트 특징
	+ 단위 테스트 프레임워크를 사용하길 권장한다. (junit 등등)
	+ 시스템의 모든 클래스를 테스트한다. 
		이때, 간단한 getter, setter는 생략한다.
	+ 코드를 만들기 전에 먼저 동작하지 않더라도 테스트 먼저 만든다.
	+ 단위 테스트는 테스트 코드와 함께 코드 레포지터리에 배포한다. 
		이때, 테스트가 없는 코드는 배포하지 않아야한다.
	+ 단위 테스트가 누락된 것을 발견하면 그 즉시 만들어야한다.

+ 단위 테스트 작성의 장점
	1. 잘 자동화된 단위 테스트는 프로젝트 수명동안 자동화된 테스트를 통해 버그를 찾고 보호함으로써 프로젝트 생성 비용을 100배 절약 할 수 있다.
	2. 단위 테스트를 작성 난이도가 높으면 높을 수록 더 많은 비용을 절약 할 수 있다.

+ 단위 테스트의 오해
	1. 곧 스프린트 마감이 다가오는데 단위 테스트 작성에 너무 많은 시간을 할애 한다.
		+ 이에 대한 반박
			잘 자동화된 단위 테스트는 프로젝트 수명동안 자동화된 테스트를 통해 버그를 찾고 보호함으로써 프로젝트 생성 비용을 100배 절약 할 수 있다.
			
	2. 우선 기능부터 만들고 테스트는 나중에 시간이 남을때 만들면 된다.
		+ 이에 대한 반박
			**이미 만들어진 시스템에 대한 단위 테스트를 만들려면 나중에 시간이 남을 때 만들어낼 수가 전혀 없다.**
			**일단 한번 먼저 기능이 만들어져 시스템을 구축하게 되면 
			이에 대한 테스트 코드 작성은 구축한 시간보다 수 개월을 더 잡아먹기 때문에 테스트 자동화에 손을 놓게 된다.**

+ TDD의 단점
	
	+ **TDD는 Data Driven한 개발 환경에서만 최적의 효율을 뽑을 수 있다.**
		즉, 도메인이 Data 중심 프로세스로 돌아가는 환경이 아니면 단위 테스트를 코드로 표현하려는건 말이 안된다.
		가장 대표적인 TDD를 사용하지 않는 도메인은 게임과 임베디드인데 임베디드도 TDD로 진행하는 곳도 있다고 한다.
	
	+ 실무 99%의 버그는 사람이 휴먼에러로 창조해내며 테스트 코드 또한 같은 사람이 만드는 것이다.
		즉, 비즈니스 로직도 잘못 코딩하고 테스트 코드 또한 실수로 잘못 코딩하여 성공으로 통과해버릴 확률이 분명 존재하는데 XP 공홈의 단위 테스트에는 이에 대한 대처나 반박은 전혀없다.
		"이런 문제가 존재는 하지만 실제로는 거의 없다." "테스트가 문제가 있고 비즈니스 로직은 정상인 경우는 문제가 조사되고 수정될 때 나타나게 되어있다"는 식으로 유야무야 넘어가고 제대로 된 대처방안 프렉티스를 제공하지는 않는다.
		
		개인적으로 본 느낌으론 대체적으로 실무에서는 이를 PR 피드백으로 커버하려고 하는 움직임이 대부분 실무에서 대처방안으로 대비하는 것으로 보였다.

+ 개인적인 의견
	
	TDD는 책 도입부에 "정신나간 아이디어를 믿고 따라준 동료에게 감사를 전한다."는 감사 메시지를 전하면서 시작한다. 실제로 이를 믿고 밀어 붙여준 동료들이 있다는 것에 약간의 부러움도 있지만 나 또한 개인적으로 이 TDD는 Data driven한 환경이 아니면, DB의 데이터가 근간인 비즈니스가 아니면, 사실 이런 개발 방법의 도입은 굉장히 조심스러울 수 밖에 없지 않나 라는 생각을 가지고 있다.
	
	만약 이 글을 읽는 당신,(내가 될 수도 있고) Data가 중요한 플랫폼 서비스의 개발자가 되고 싶다면 TDD는 무조건 습관화 할 것을 추천한다.
	다만 이쪽에 관심 없는 사람이라면 TDD엔 관심을 끄는 것이 좋다고 생각한다.



### Whole Team

### Continuous process

### Continuous Integration

### Design Improvement

### Small Releases

### Shared understanding

### Coding Standards

모든 팀원이 코드를 쉽게 읽을 수 있고 시스템의 일부가 시스템의 다른 부분을 쉽게 참조 가능하도록 만들어주는 일종의 코드 작성 표준 관례안

- 구성
    - 네이밍 컨벤션
    -

### Collective Code Ownership

![[code.gif]]

XP에서 코드는 개별 엔지니어에게 속하는 것이 아니라 프로젝트에 속하는, 프로젝트에 의존되는 형태이여야한다.

- 특징
    1. 모든 개발자가 모든 코드에 수정하고 설계를 개선하고 리팩토링할 수 있다.
    2. 코드의 소유권은 모든 개발자에게 있기 때문에 흔히 있는 “거기 내가 짜는 파트 아냐”가 불가능한 구조이다.
    3. XP에서는 트럭넘버를 모든 맴버의 수로 유지할 것을 권장한다. 트럭 넘버란 누가 트럭에 치어죽어도 운영중인 서비스를 당장 중단하지 않아도 되는 핵심 맴버의 숫자를 의미한다.
       근데 대부분의 경우 특정 유저가 특정 로직을 제대로 이해하게끔 진행되는 경우가 대다수이며 이 정보의 차단을 권력으로 사용하는 경우가 대다수이다. 그래서 어쩔수 없이 대부분의 회사는 트럭넘버를 5정도로 유지하게끔 진행한다.


### Simple Design

> 최대한 설계는 가볍게 가져가야한다는 프렉티스이다.

+ 설명
	우리는 이러한 프로그래밍 기법으로 YAGNI라는 이름으로 들어보곤 한다.
	
	필요에 의해 구성된 스토리에 들어있는 기능만 정확히 추가하는 것이다.


### System Metaphor

> XP에서 아키텍처를 통합하고 네이밍 컨벤셩을 제공하기 위해 사용되는 용어

+ 설명
	시스템이 어떤 동작을 수행하는지에 대한 간단한 썰, 은유이다.
	
	일반적으로 구축중인 시스템의 핵심 흐름을 형성하는 소수의 클래스와 패턴을 포함한다.
	
	우리는 현대에 이것을 도메인이라고도 부르곤 한다.

### Programmer welfare

### Sustainable Pace

## 스크럼과 XP

### 프로젝트 관리 집중의 차이

- 스크럼

    프로젝트 관리에 집중,

    프로젝트를 관리하는 방법을 개선하는 경험적 프로세스 제어에 초점을 두었고
    프로그래밍 방식에는 거의 관여를 하지 않기 때문에 스크럼을 사용하는 비IT 직군 또한 많다.

- XP

    프로그래밍 팀이 일하는 방식을 개선하는데 도움을 주도록 최적화


### 같이 사용할 때의 강점

스크럼과 XP는 애자일 선언문 이념을 공유하는 공통적인 아이디어이며 XP 반복은 스크럼 처럼 작용하며 용기와 존중을 스크럼과 같이 공유한다.

많은 애자일 팀이 스크럼의 경험적 프로세스 제어 + XP의 팀 결속, 의사소통, 코드 품질, 프로그래밍을 조합해 함께 사용한다.

### 공통점과 차이점

- 공통점

    존중, 용기, 스토리, timeboxed 반복

- 차이점
    - 스크럼

        경험론, 회고, 제품 백로그, 초점, 전념(몰입 또는 헌신), 개방

    - XP

        분기별 주기, 주간주기, 테마, 슬랙

