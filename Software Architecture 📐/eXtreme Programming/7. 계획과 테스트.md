## 제약 이론

<br>

### 개요

> 제약 이론은 전체로서의 시스템 처리능력을 살펴보는 접근 방법이다.

+ 설명
	제약 이론이란 전체 시스템의 제약 지점이 한 개 이상 존재한다는 정의를 따르며 내부 상황에 따른 제약, 자원에 따른 제약, [시장](https://ko.wikipedia.org/wiki/%EC%8B%9C%EC%9E%A5 "시장")에 따른 제약, 방침에 따른 제약등으로 나뉜다
	
	즉, 모든 시스템 마다 존재하는 제약조건을 살펴보아 이를 해소하는 것이 중요한데 이를 보통 병목 현상으로 비유하곤 한다.
	
	+ 제약 지점 찾는 방법
		+ 전체 시스템에서 작업이 큐에 계속 쌓이는 부분을 찾는다.
	
	+ 핵심사항
		**제약 조건이론에 따르면 제약 지점은 절대 사라지지 않는다.**
		
		제약으로 인한 격차를 줄여줄 뿐 시간이 지나면 언젠가는 반드시 격차가 커지게 된다.
	
	 + 예시 Ⅰ
		 세탁: 45분
		 건조: 90분
		 옷 정리: 15분
		 이러한 프로세스를 가지는 시스템이 있다고 가정한다.
		+ 특징
			+ 마른 옷이 쌓이진 않고 젖은 옷이 쌓인다. 즉, 건조를 위한 건조 시작 지점이 제약 지점인 것이다.
			+ 이런 시스템의 작업은 밀어 넣어지는(push) 존재가 아닌 끌려다니는 존재(pull)이다. 마치 달의 인조력을 생각해보면 된다. 
				달에 의해 생기는 밀물과 썰물의 그 물 자체는 인조력에 끌려다니는 존재이지 본인이 밀어서 들어가는 존재는 아니다.
		+ 해결 방법
			+ 건조기의 성능을 높인다.
			+ 세탁기의 탈수 성능을 높인다.
			+ 건조기가 아닌 다른 건조 방법을 도입해 분산한다.
	
	
	+ 예시 Ⅱ
		명세화, 설계, 코딩, 테스트로 구성된 소프트웨어 개발 프로세스
		+ PUSH 모델
			+ 과정
				1. 명세화
					요구사항을 쌓는 단계이다.
				2. 설계
					구현할 설계를 쌓는다.
				3. 코딩
					코드를 구현하는 단계이다.
				4. 테스트
					통합적으로 테스트를 하는 단계이다.
			
			+ 정리
				대표적으로 폭포수 모델에서 사용되는 모델이 푸시 모델 이다.
		
		+ PULL 모델
			1. 명세
				요구사항(작업)을 쌓는 단계이다.
			2. 테스트
				명세에 따라 바로 테스트를 작성한다.
				이때 인터페이스는 이 테스트들의 필요에 의해 작성된다. 
				테스트할 때 필요 없는 인터페이스는 필요없는 인터페이스인 것이다.
				여기서 테스트 작성 후 설계나 코딩으로 넘어간다.
			3. 코딩
				인터페이스와 테스트들에 잘 맞도록 작성한다.
			4. 설계
				코드를 작성하는 동안 코드의 필요에 의해 다듬어진다.
				이 다듬는 과정은 다시 스토리 작성 이후 진행된다. 
				따라서 여기서 다시 명세로 넘어가며 설계에 의해 스토리도 선택된다.

+ 핵심 사항
	+ 변화를 가져오려면 전체 조직의 초점은 거시적 최적화가 아닌 전반적인 처리 능력 최대화에 맞춰야한다.
		즉, 최적화에만 초점을 두면 푸시모델에서 벗어나 풀 모델을 도입할 수 없다.
	+ 제약 이론은 조직내 병목 현상을 찾기 위한 지도(도구)에 불과하지 실제 개발(활동)을 의미하진 않는다.
		제약 이론을 통해 고안한 풀 모델을 적용할 때 생각보다 잘 적용이 되지 않는 원인이기도하다.
		직접 적용을 해보고 수정을 거듭해가며 완성해야한다.
	+ XP 자체를 임원의 후원 없이 도입하면 옆팀의 원성을 사 팀이 해체될 수도 있다.
		예를 들면 일주일 주기를 추가해서 도입했는데 마케팅 팀과 PO와 같은 결정권자들이 이 결정에 대해 매 주 마다 힘들어한다면 소리 소문없이 도입된 xp는 사라질수도 있다.

<br>

## 계획짜기: 범위 관리


<br>

### 개요

> XP에서 계획은 장보기와 같다.

+ 설명
	+ 핵심사항
		+ 스토리는 장을 볼 상품이고 예산은 시간이다.
		+ 계획은 모든 팀원이 달려들어서 진행해야한다.
		+ 스토리 구현 또는 선택시 쭉 나열해 놓고 여러 방식으로 배치해서 여러 관점에서 관찰해본 뒤 진행해야 뒤탈이 적다.
		+ 추정할 때는 처음엔 예측해서 넣고 매일 수정해야한다. 이것을 첫 주에 진행한 뒤 경험을 해본 다음 이 피드백으로 다음주에 제대로 적용한다.
		+ 정해진 시간이 200 페어 시간인데 장바구니에 든 스토리가 총 400이라면 200만큼 가치가 높은 스토리만 골라내서 덜어 내야한다.
			스크럼에서는 백로그중 우선순위가 높은 것만 담아서 넣는 작업이다.
		+ 완료 판정은 스크럼과 동일하게 모든 인원이 납득을 하여 프로덕션 배포 직전까지 완료한 상태를 의미한다.
		+ 정 스토리를 고르기 힘들면 고객에게 선택을 맡긴다.
	
	+ 프로젝트 관리의 4 가지 변수
		+ 프로젝트 관리자와 고객이 정하는 것
			+ 시간
			+ 비용
		+ 프로그래머가 정하는 것
			+ 품질
				+ 특징
					+ 품질은 낮춰봐야 일감이 줄진 않고 고객과의 관계만 훼손된다.
			+ 범위
				+ 특징
					+ 안전하게 적응시킬 길이 생긴다.
					+ 협상할 방법이 생긴다.
					+ 말도 안 되고 쓸모도 없는 요구를 제한할 수 있다.
	
	+ 계획짜기 과정
		1. 해야 할 일을 목록으로 작성
		2. 각 항목의 작업시간 추정
		3. 지금 계획 중인 주기를 위한 예산을 세움(토이 플젝이라면 일주일동안 쓸 수 있는 시간을 의미)
		4. 해야할 일 들을 예산 내 범위에서 합의한다.


<br>

## 테스트: 일찍, 자주, 자동화

&emsp;&emsp;
### 개요

> XP에서 테스트는 결함 문제를 직접 대응하는 기술적 활동이다.

+ 설명
	결함은 항상 존재하며 한달에 한번 나오는 결함을 1년에 한번 나오게끔 만드는 노력이 늘 필요하다.
	
	이것을 평균 실패 간격이라고 부른다.
	
	프로젝트에 따라 결함 납득 가능성은 다르다. 
	인공위성의 경우에는 한 세기에 한번 결함이 나오게끔 짜야하며 웹사이트는 일주일, 3일에 한번씩 나와도 괜찮다.
	
	+ 테스트 비용 효율을 위한 원칙
		+ 재확인, double-check
			적어도 두 번 이상 다른 방식으로 검증할 경우 결함이 없을 확률이 크다.
		+ 결함 비용 증가, Defect Cost Increase(이하 DCI)
			결함을 일찍 찾을 수록, 비용이 적게 든다.
	
	빈번한 자동화 된 테스트로 결함을 조기에 발견하고 고치는 것이다.
	
	테스트는 유닛 테스트, 인수 테스트로 이루워져야한다.
	
	유닛 테스트는 프로그래머가 단일 로직에 시도하는 테스트이며 인수테스트는 고객과 사용자 입장에서 작성한 테스트이다.
	
	스트레스 테스트와 부하 테스트는 작성이 완료되고 나서 시도되는 테스트이다. 이것 또한 개발 주기 안으로 집어넣어 시도해야한다.
	
	이 책이 나오던 시절에는 정적 분석기가 믿을 만 못했다지만 현재 정적분석기는 아주 쓸만하다.
	
	왠만한 컴파일 타임 오류를 다 잡아준다.
	
	+ XP의 문제점
		+ 결함을 저지르는 사람이 직접 테스트를 작성한다.
			내가 저지른 잘못을 스스로 잘 치우는 사람이 있긴 하지만 생각해보면 내가 저지른 결함은 내가 코드를 짠 당시에는 절대 발견 못한다.
			그 이유는 당연히 본인이 발견을 못했으니까 결함이 존재하는 상태로 병합을 시도하기 때문이다.
			그래서 XP는 페어 프로그래밍으로 방지하려 하지만 페어 프로그래밍은 현실성이 떨어진다.
			안그래도 몸값 비싼 개발자를 한 소스에 두 명씩 붙여서 개발하게 만들려는 임원은 거의 없다.
			현재 PR 코드 리뷰가 대부분 기업에서 채용한 결함 2차 방지 대책이다.
		
	