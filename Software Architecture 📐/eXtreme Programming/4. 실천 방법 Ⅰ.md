> xp팀에서 매일 실천해야하는 행동 양식


+ 특징
	+ 가치를 먼저 알고서 수행하지 않으면 의미가 없다. 이건 스크럼과 동일한 특징을 가진다.
	+ 상황에 따라 다른 실천방법을 적재적소로 적용해야한다. 그러지 않으면 헛짓이나 다름 없다.
		+ 만약 도메인이 보안이 중요하게 바뀌었다면 보안을 중요하게 생각하는 몇가지 원칙들을 추가해야만 한다.
	+ 실천방법이 무조건 시켜야하는 것은 아니다. 위에 적었듯 적재적소에 실천해야한다.
		+ 만약 겨우겨우 3달에 한번 배포를 하는 서비스를 운영하는데 매일 배포 실천방법을 적용해봐야 의미가 없다는 뜻이다.
		  이런 경우엔 좀 더 릴리즈 기간을 잘게 쪼개 나가는 것부터 시작을 해서 나중에 매일 배포 실천 방법을 적용해야 한다.
	+ 실천방법을 한꺼번에 적용할 필요는 절대 없다. 원칙에 이미 적었지만 베이비스텝이 중요하다.
	  한꺼번에 많은 변화를 단기간에 바라는건 바보같은 짓이며 하나씩 매주 적용해보고 차이를 회고해보는 것부터가 시작이다.


<br>

## 실천 방법 요약

+ 주요 실천방법
	+ 전체 팀
	+ 활기찬 업무
	+ 계획
		+ 여유
		+ 스토리
		+ 월 단위
		+ 주 단위
	+ 프로그래밍
		+ 테스트 우선 프로그래밍
		+ 점진적 설계
	+ 통합
		+ 십분 빌드
		+ 지속적 통합
+ 보조 실천방법
	+ 점진적 배포
	+ 비즈니스
		+ 범위 현상 계약
		+ 사용별 지급
		+ 매일 배포
	+ 프로그래밍
		+ 단일 코드 기반
		+ 코드 공유
		+ 코드와 테스트
	+ 팀
		+ 근본 원인 분석
		+ 실제 사용자(고객) 참여
		+ 팀 연속성
		+ 팀 축소


<br>

## 기본 실천 방법


<br>

### 함께 앉기

> 개발작업은 1인실을 쓰지말고 칸막이가 없는 곳에서 일을 해야한다는 실천방법이다.

+ 설명
	대부분 혁신을 추구하는 오피스들은 이런식으로 되어있는 곳이 많다.
	
	그 이유는 의사소통이 1분 1초사이에 수십번을 오가기 때문인데 이 과정에서 일을 본인들이 알아서 효율적인 해결착을 찾아서 해결해 나가기 때문이다.
	
	사실 이 책에서도 경고하는 것은 한번에 파티션을 빼지 말라는 것이다.
	이 책에서 강조하는 것은 팀 내부에서 소통하기 편한 공간을 만들라는거지 개인 사생활을 공개한다는 느낌을 줘서는 안됀다.
	
	처음 일주일에는 각 자리에 편안 여유분의 의자를 가져다 놓고 시작을 한다.
	여유분의 의자에 각자 의사소통이 필요하면 편하게 앉아서 같이 협업을 하면 된다.
	그 다음 일주일은 회의실에서 3~4시간 정도 다같이 개발을 진행해본다.
	마지막으로 일주일은 팀 내부끼리 안정적인 공간을 느끼는 위치를 배치해서 파티션을 제거한 채로 진행한다. 보편적으로 학익진 형태의 길고 둥근 테이블을 사용한다. 이런 테이블은 칸막이가 없고 바퀴 달린 사무용 의자만 옆으로 쓰윽 옮기면 3초만에 의사소통을 시작할 수있다.
	
	이런식으로 점진적으로 적응하는 시기를 주게끔 유도하는것이 중요하다.
	
	물론 과정에서는 불평 불만이 많을 것이다. 
	허나 변화를 원하지 않는 직원이 있다면 납득을 시키는게 스크럼 마스터의 의무이다.
	???: 메신저가 있는데 왜 파티션을 없애죠? 없앤다고 소통을 더 하나요? 소통을 한다고해서 일이 더 잘된다고 납득이 안되는데요?
	
	분명 처음에는 대다수의 직원들은 이런 반응을 내심 보일 것이다. 허나 멀쩡히 돌아가는 회사에는 결국 실시간 양방향 의사소통이 중요하며 설명을 시도했음에도 불구하고 팀을 따르지 않는다면 이 직원은 다른 파랑새를 찾아 떠나게끔 놓아주는 것이 맞다.
	
	이것 또한 스크럼에는 없는 실천방법이긴 하다. 소통방식은 알아서 하는게 스크럼을 고안한 개발자분의 입장이였는데 솔직히 나도 잘 모르겠다. 개인 경험상 과한 소통은 오히려 지나친 백로그 증가분을(필요도 없지만 디테일이니 뭐니 우선순위가 상대적으로 낮은 업무) 양산하는 느낌을 받았기 때문이다. 디테일하게 업무를 잡아가는게 품질을 올리는데 도움이 된다고 생각한다면 이 방식도 괜찮다고 생각한다. 
	근데 나는 새로 추가하고 싶은 기능은 새로 백로그로 추가하고 다음 스프린트에 진행하는게 맞다고 생각하는 사람이라 이건 알아서 생각해서 진행하면 될 것 같다.

<br>

### 전체 팀

> 프로젝트 성공에는 높은 상호작용을 하는 필요한 기술과 시야을 지닌 사람들이 포함된 전체 팀이 필요하다는 실천방법이다.

+ 설명
	이는 복합기능팀이라는 옛 개념을 물려받아 약간의 개념만 더한 것이다.
	
	여기서 서로간의 의사소통을 강화하고 상호작용을 더욱 부추기기 위해선 팀에 속한다는 느낌이 있어야한다.
	
	+ 전체 팀의 소속감
		+ 우리는 소속되어있다.
		+ 우리는 이 안에 함께 있다.
		+ 우리는 서로의 작업, 성장, 배움을 돕는다.
	
	팀의 규모는 12 ~ 150 명을 추천한다.
	
	스크럼과 달리 대규모로 적용이 가능한 것이 XP이지만 대부분 현대의 개발팀들은 스크럼방식으로 10명 이상의 팀원을 꾸리지 않는다.
	
	사람이 너무 많아지게 되면 업무 복잡도가 급증하게되며 업무 추적부터가 문제가 된다.
	
	대부분은 10명 단위로 쪼갠다고 보면 된다.

<br>

### 정보를 제공하는 작업 공간

> 프로젝트에 관심이 있는 관찰자라면 누구든지 팀이 사용하는 공간에 들어오면 15초 안에 프로젝트가 어떻게 진행되는지 감을 잡을 수 있을 만큼 깔끔하게 정보를 제공해야한다는 실천방법이다.

+ 설명
	간단하게 설명하자면 트렐로나, 노션 혹은 대표적으로 지라와 같은 작업 추적 도구를 이용해 회고를 하고, 어디까지 했는지 기록을 하며, 모든 팀원들이 한번에 내 작업에 대해 추적을 할 수 있도록 되어야한다.
	
	xp에서는 스크럼과 동일하게도 프로덕트 백로그를 스토리로써 요구사항을 작성한다. 작성할때는 페르소나을 쓴 채로 작성해야하는 것은 똑같이 필수다.
	
	책에서는 너무 옛날 방식인 화이트보드에 포스트잇으로 스토리를 붙여서 진행하는 방식을 알려주는데 사실 지라나 트렐로나 노션만 살짝 써보면 누구나 가능하다.
	
	완료, 이번주, 이번 릴리즈, 추정 대상, 미래 등등으로 업무를 쭉 나누고 화이트보드에 정리하는 것이다.

<br>

### 활기찬 작업

> 활기가 늘 넘치게 작업하려면 활기가 늘 넘칠 수 있는 시간대에만 근무를 하라는 실천방법이다.

+ 설명
	즉, 일찍 나와 일하고 일찍 퇴근을 하던 시간 대는 알아서 맞추되 늘 정시퇴근을 보장해야 결국 전체적인 생산성이 높아진다.
	
	아프고 지치면 빠르게 쉬는 것도 중요하며 일하는 시간중 코딩시간이 너무 부족하다는 생각이 들면 하루에 2~4시간은 무조건 코딩 시간으로 잡아버리는 것도 방법이다.
	
	이때는 사내 메신저, 카톡, 메일까지 싹 차단해버릴 수 있으면 좋다.
	
	단, 이런 경우에는 외부에서도 이 코딩시간을 알긴 알아야 한다.
<br>

### 페어 프로그래밍

> 제품으로 출시할 모든 프로그램을 두 사람이 한 컴퓨터에 앉아서 작성하라는 실천방법이다.

+ 설명
	+ 페어 프로그래밍의 특징
		+ 서로 일에 집중하도록 해준다.
		+ 시스템을 더 좋게 다듬기 위해 무엇을 할 수있을지 브레인스토밍이 된다.
		+ 서로 떠오른 생각을 서로가 다듬어줄 수 있다.
		+ 한 사람이 막힐 때 주도권을 다른 사람에게 넘김으로써, 짜증을 덜 나게 해준다.
		+ 팀에서 지키기로 한 실천방법을 서로 책임지고 지키도록 한다.
	
	놀랍게도 이 책에서는 이성과 페어프로그래밍을 하다가 성적관심이 생기면 즉시 관두라고도 경고도 해준다.
	(옷깃만 스쳐도 고백을 하는 '진짜'들은 어디에나 있는 모양이긴하다.)
	
	아무튼 이는 팀바이 팀으로 PR 리뷰로만 진행하는 팀도 있고(사실 이 경우가 베스트이다.) 실제로 드물지만 페어 프로그래밍을 하는 곳도 있는데
	
	xp 공홈에서 이야기하듯 이 짝꿍은 시니어와 주니어끼리 맞춰야 가장 시너지가 좋다.
	
	주니어는 직관력과 예측력, 분석과 설계 능력이 떨어지지만 타이핑하나는 빠르고 어차피 시니어에게서 많은 업무를 배워야한다.
	
	시니어는 반대로 직관력과 예측력, 분석과 설계능력까지 갖췄지만 슬슬 손이 따라와주지 않는 나이이다.
	시니어는 어차피 본인 업무는 빨리 끝내기 때문에 (자동사냥 모바일 게임이나 돌리고 있는 경우가 상당수이므로) 주니어에게 업무를 가르칠 겸 겸사겸사 페어프로그래밍을 진행하는 것이 좋다. 
	이래야 업무 진행에 방해도 되지 않아서 가장 이상적이라고 할 수 있다.
	
	다만 대부분의 경우 시니어들은 병풍코딩을 하면서 한 두가지 키워드만 던져주고 쫄래쫄래 나가서 "아 막내 케어 귀찮고 힘드네 내 짬에 이런걸 내가 해야해?" 하면서 담배나 뻑뻑 피우고 들어오는 경우가 많다. 
	
	놀랍게도 대부분의 경우가 이 케이스들이고 PR 리뷰를 통해 팀원 전체가 리뷰를 한가지씩 해주는 경우는 가장 아주 이상적인 실천방법이라고도 할 수 있다.
	
	물론 xp 공홈에서는 단순 병풍 코딩이 아닌 키보드와 마우스를 번갈아가며 사용하며 타이핑까지 해야한다고 했는데 요즘엔 코파일럿이라는 좋은 신 문물이 존재해 생산성면에서 좋다고 솔직히 말 하기에는 좀 그렇다...
	
	이젠 페어 프로그래밍은 오로지 주니어의 실력을 키우는 용도 이외에는 의미가 없다고 판단하는 사람들이 대부분이다. 이를 염두해 두고 도입하자.
<br>

### 스토리

> 고객이 볼 수 있는 기능을 단위로 해서 계획을 짜라는 실천방법이다.

+ 설명
	xp의 스토리는 스크럼의 유저스토리와 아주 흡사한데 유저 스토리보단 살짝 라이트하게 내용을 적는다.
	
	추정치와 기능 내용으로 구성되는데 
	
	특정 유저의 프로필(페르소나)을 미리 만들고 해당 유저가 어떤 행동을 통해 어떤 결과를 얻는지를 정확히 적는 스크럼과는 살짝 라이트하다.
	
	책에서는 이 스토리를 반드시 카드에 적어야 의미가 있지 아니면 의미가 없다고 강조를 거듭하는데 사실 이미 17년 후인 지금 대부분 it 회사는 지라나 트렐로로 충분히 잘만 사용하고 있다.
	
	이 스토리 추정이 사실 핵심이라고 할 수 있는데 이 스토리는 언제든 추가될 수 있고, 또한 변경해보니 너무 커져서 나눠서 둘 수도 있다.
	
	여튼 핵심은 초기에 이 걸리는 시간을 추정해서 시간 대비얻는 이득이 큰 스토리를 위주로 우선순위를 세울 수 있다는 점이다.
	
	하지만 문제는 여기서 발생한다. 내가 직접 개발해보지도 않았는데 어떻게 추정이 가능하다는 것일까? 책이나 xp 공식홈페이지에서는 load factor를 곱해야한다고도 말한다.
	즉, 부하율을 3으로 일반적으로 정하는데 만약 내가 생각하기에 1일 걸리는 일이라면 실제로 추정치를 적을 때는 3일로 적어야한다는 뜻이다.
	
	그러나 이런 추정치가 정말 정확할지는 아무도 모른다.
	
	그나마 시니어들은 가늠 정도는 할 수 있을 것이다.
	
	그렇기 때문에 스크럼에서는 이 추정치를 그냥 피보나치 수열 숫자로 배정만 하는 것이다.
	
	정확히 걸리는 시간은 개발자가 직접 해봐야하는 것들이 신입일수록 대부분일탠데 어떻게 정확히 추산하겠는가? 이는 애초에 애자일 마인드에 벗어나는 논제이다.
	
	그렇기 때문에 이 스토리에 대해 쭉 적은 다음 팀원들과 다같이 추정을 적고 플래닝 카드 게임으로 선정하는 것이 훨씬 안전하다고 할 수 있다.
	
	물론 PM또는 PO 입장에서 답답하겠지만 어찌 되었든 스크럼의 스프린트나 일주일별 주기동안 개발할 스토리는 모두가 알고 있으니 월요일 밋업에 정한 스토리들은 최소한 일주일 안에 개발이 된다고 인지만 할 뿐이다.
	
	차라리 이런식으로 정하는게 서로에게 훨씬 부담이 적고 개발 진행 주차를 거듭할 수록 추정도 정확해지는 방식이다.

<br>

### 일주일별 주기

> 매주 월요일마다 한주를 시작하는 회의를 열어 일주일 분량의 일을 계획하는 실천방법이다.

+ 설명
	+ 일주일별 주기 진행 과정
		1. 지금까지 진행된 상황을 검토하는데, 지난주의 실제 진행 정도가 예상 진행 정도를 달성했는지 역시 포함해 검토한다.
		2. 이번 주에 구현할 일주일 분의 스토리를 고객이 고르도록 한다.
		3. 스토리를 여러 과업으로 쪼갠다. 팀 구성원들은 자기가 할 과업에 서명을 하고, 얼마나 걸릴지 추정한다.
	
	스토리 완성시 곧바로 자동화 테스트를 구현하는 것으로 한 주를 시작한다.
	그리고 끝나면 남은 시간을 스토리들의 구현을 시작 하고 테스트를 통과할 수 있도록 만드는 데 쓴다.
	
	여기서 핵심은 일주일 안에 모든 테스트를 통과할 때까지 스토리 구현을 하는 것이다.
	만약 수요일에 아직 모든 테스트를 통과시키지 못했더라도 아직 시간이 남았기 때문에 일주일동안 구현해야하는 스토리들 중 가장 가치가 높은 스토리를 우선적으로 구현을 진행한다.
	
	초판에서는 사실 2주나 3주을 권장하기도 했었다. 근데 이 책에서는 일주일을 권장한다.
	
	난 개인적으로 고객과 함께 참여하는 스프린트 리뷰와 계획 수립 세션은 2주, 일주일별 주기는 일주일로 잡는게 좋다고 생각한다. 
	스프린트를 실제로 혼자서 진행해보면 내가 시간안에 다 진행이 가능한지 가늠조차 안오는 경우가 너무 많았고 진행해보니 좀 더 스토리를 잘게 쪼개야하는 스토리가 많았다. 
	이런 경우를 고치려면 우선순위를 세워서 중간 점검이 필요하다는 것이 많이 다가왔기 때문에 스프린트 중간에 이러한 주기를 잡는게 좋다고 생각하며, 대신 고객은 빼고 진행하는게 맞다고 생각한다.

<br>

### 분기별 주기

> 한 번에 한 분기 분량의 일을 계획하고 회고하자는 실천방법이다.

+ 설명
	분기별로 팀, 프로젝트, 프로젝트의 진행 정도, 더 높은 목표와 지금 프로젝트의 방향 일치 여부등을 숙고해 보도록해야한다.
	
	+ 한분기 계획에서 하는 일
		+ 병목, 특히 팀의 힘이 미치지 않는 외부에서 생기는 병목을 찾아본다.
		+ 수선 작업을 시작한다.
		+ 이번 분기의 주제(테마)들을 계획한다.
		+ 그 주제들을 다룰 한 분기 분량의 스토리들을 고른다.
		+ 프로젝트가 조직에서 차지하는 위치라는 큰 그림에 초점을 맞춘다.
	
	분기는 프로젝트의 시간을 조직하는데 사용되는 자연적이고 널리 공유되는 시간 단위인데 대부분 사업 기획에도 잘 맞아 떨어진다는 장점이 존재한다. 따라서 고객사나 외부 이해관계자와 소통에도 도움이 크게 되는 시간단위라고도 할 수 있다.
	
	참고로 주제와 스토리를 분리하는 이유는 이번 주의 스토리가 더 큰 그림에 어떤 위치를 차지하는지 고려하지 않고 지금 자신이 하는 일의 세부사항에만 초점을 맞추고 흥분하는 개발팀의 경향에 맞서기 위해서이다.
	
	주제는 마케팅 로드맵을 그리는 것 같은 더 큰 규모의 계획과도 잘 맞아떨어진다.
	
	분기는 반성이라는 원칙을 지키기에도 좋은 시간 간격이기 때문에 일의 진척을 막는 병목을 찾고 장기 실험들을 제안하고 평가하는데도 분기를 사용하기도 좋다.
	
	참고로 나도 이런 계획은 있으면 좋다고 생각한다.
	
	특히 유저 스토리 맵을 두고서 어떻게 언제까지 릴리즈를 할지 정하는, 이를 회고까지하는 아주 좋은 시간이라고 생각한다.
	지라같은 경우에는 로드맵이 존재하기 때문에 언제까지 릴리즈를 끝내야하는지도 한눈에 보기 쉽게 정리가 가능하다.

<br>

### 여유

> 슬랙이라고 부르는 비교적 덜 중요한 스토리들을 매주 일주일별 주기에 집어 넣는 실천행동을 의미한다.

+ 설명
	이 슬랙은 8주에 한번씩 긱스 윅스를 만들어 한 주에 예산이 20퍼센트를 프로그래머들이 직접 고른 스토리를 배당해 볼 수도 있다.
	
	다만 정말 여유가 있고, 20퍼센트의 예산만 사용이 가능한 선에서만 허가해야한다.
	
	다만 이게 성공한다면 고객들에게는 신뢰감을 얻는 기회가 될 수있다.
	
	만약 몇번의 개발 연기으로 고객들에게 신뢰를 잃었다면 이런 기회를 통해 잃어버린 신뢰도를 회복할 수도 있는 것이다.(혹은 이거 만들시간에 제때 개발이나 하라는 욕만 잔뜩 먹을 수도 있다. 따라서 알아서 잘 판단해서 진행해야한다.)

<br>

### 10분 빌드

> 10분만에 전체 시스템을 빌드하고 모든 테스트를 돌려야한다는 실천방법이다.

+ 설명
	참고로 딱 10분이 걸릴지는 아무도 모르지만 이 프로세스가 적어도 10분이 넘어서진 않게끔 하한으로 정해야한다는 것이다.
	
	이는 하나의 이상적인 빌드타임이기 때문에 사실 더 짧을 수록 일의 흐름이 끊기지 않아서 좋다.
	
	요즘에는 이 과정을 개발 프로세스 무조건 집어넣기 때문에 수동 빌드 배포를 할 생각은 접는게 좋다. (테스트 코드를 관리할 인력이 없으니 그런건 없어야 된다고 우기는 사람들도 있다. 이런 사람들이 연차까지 높다면 그냥 도망칠 준비를 하자. 당신의 말은 무조건 반사로 무시할 가능성이 높다.)

<br>

### 지속적 통합, CI

> 변경한 것은 2 ~ 3시간 만에 통합하고 테스트해야한다는 실천방법이다.

+ 설명
	이는 깃허브가 이미 존재하기 때문에 책에 나와있는 설명들이 별 의미가 없다.
	
	애초에 요즘엔 개발 프로세스 자체가 지속적으로 테스트 작성, 개발, 테스트 통과시 전체 테스트, 전체 테스트 통과 후 곳바로 푸시 후 Pull Request를 보내는데 CI를 2 ~ 3시간 만에 통합한다는건 요즘에는 좀 바보같은 소리이다.
	
	이 책의 저자인 캔트백은 동기식으로 차례대로 통합해서 페어 프로그래밍을 이어가도록 권장하는데 깃허브가 있고 깃플로우 방식을 이용하면 이렇게 개발할 필요가 1도 없다.
	
	이 책에 저자는 중간중간에 비는 시간(동기식이니 통합을 대기하는 시간 혹은 빌드시간)마다 짝과 반성의 시간을 가질 수 있어서 좋다고 하지만 그냥 그건 둘이 커피 한잔 하러 나가서 해도 되는 이야기들이고 어차피 매일 퇴근 전에 미리미리 적어두면 되는 회고 목록 아이템으로 남겨두면 되는 것들이다.
	
	참고로 이 CI의 결과는 곧바로 CD, 지속적 배포로 바로 이어져야한다.
	
	웹사이트의 경우 바로 배포가 완료되서 내부 인하우스 테스트 팀이 테스트 해볼 수 있게 슬랙 메일까지 보내도록 세팅을 하던가, 핫픽스 패치나 릴리즈 CI 였다면 곧바로 고객사가 확인할 수 있게 구성을 해야한다.

<br>

### 테스트 우선 프로그래밍

> 코드 작성 전에 반드시 실패 테스트 코드를 우선 작성하라는 실천 방법이다.

+ 설명
	이 테스트 우선 프로그래밍은 그 유명한 TDD 기법을 의미한다.
	
	진행 방식은 간단하다. 우선 스토리에 적힌 구현 요소들을 전부 테스트 코드에 시나리오대로 작성한다. 당연히 정적분석기가 없는 클래스 생성부터 시작해서 메서드 호출까지하니 빨간색 밑줄을 쭉쭉 그어 경고를 할 것이다. 컴파일도 물론 안될것이고 말이다.
	
	이 상태에서 필요한 객체를 하나씩 만들어 코드작성을 하며 빨간 줄을 하나씩 지워 나가는 것이다.
	
	이것이 바로 TDD이다. 별거 없지 않은가?
	
	그러나 유닛테스트, 통합테스트, 테스트 스위트 구축, 환경에 맞는 테스트 구축 방법등등 이젠 여러가지 테스트 기법들을 확인해가며 테스트 스위트를 구축해야하는 시대가 왔다.
	
	이러한 내용은 추후에 책을 3권을 더 정리해서 공부할 예정이다.
	
	+ TDD가 해결해주는 문제들
		+ 슬금슬금 늘어나는 범위
			이는 '확장성'을 빌미로 쓸때 없는 코드를 추가로 작성하는 것을 의미한다.
			예를 들면 비밀번호는 8~20자로만 요구를 했는데 혹시 나중에 대소문자, 특수문자 추가할 수도 있으니, 그리고 혹시 암호화 까지 추가를 할 수 있으니 이를 미연에 방지에 먼저 구현을 한다고 하면 이것을 두고 슬금슬금 늘어나는 범위라고 부른다.
			요구사항에 있지도 않는 구현을 굳이 추가한 것이며 만약 테스트 계정은 로그인하기 편하게 그냥 통과시켜달라고 했으면 어떻게 구현할 것인가? 즉, 여러가지를 굳이 염두에 두고 구현할 필요는 없다. 
			이것은 TDD에서는 무조건 테스트를 먼저 작성하며 시나리오를 제한해버리기 때문에 해결해준다는 의미이다.
		+ 결합도와 응집도
			기존의 있던 코드와 함께 신규 코드가 사용되어야 하고 이에 테스트를 작성해야한다고 하자. 
			근데 만약 이때 테스트를 작성하기 쉽지가 않다면, 기존 코드의 결합도가 높고 응집도가 낮아 설계에 문제가 있다는 것을 바로 알려주게 된다.
			반대로 결합도가 낮고 응집도가 높았으면 테스트 코드는 쉽게 작성될 것이다.
		+ 신뢰
			작동하지 않는 코드를 작성한 사람을 신뢰하기는 힘들다.
			깨끗히 작동하는 코드를 테스트 코드로 증명하므로써 신뢰를 얻는 것이다.
			근데 이건 MSG 개뻥이라는 건 예전에 내가 설명을 했었다.
			애초에 작동하지 않는 코드를 작성하는 사람은 테스트코드도 멀쩡히 못짜는 사람일 확률이 높다.
		+ 리듬
			예전에는 스토리를 화이트보드에 적던 시절에는 코딩을 몇시간씩 하다보면 원래 뭘할려고 했는지 기억이 안나는 경우가 정말 많았다고한다.
			요즘은 지라나 트렐로가 있어서 솔직히 이런경우는 매우 드물지만 말이다.
			아무튼 테스트 코드를 먼저 작성하게 되면 이런 일이 발생하지 않는다
			그리고 이는 테스트, 코드, 리팩터링, 테스트, 코드, 리팩터링, ... 이 3박자의 리듬으로 이어진다는 의미이다.
	
	아주 옛날에는 정적분석기가 없던 시절엔 이 코드가 컴파일 오류를 낼지 안낼지를 직접 컴파일을 돌려봐야 판단이 가능했다.
	
	지금은 입력버퍼가 하나만 들어가면 바로 바로 정적분석기가 판단후 에러인지 아닌지를 알려준다. 아무튼 이것을 지속적 테스팅이라고 부른다는데 어찌되었든 이 방식은 모든 대기업에서 애용하는 개발기법이기 때문에 반드시 습득을 해놓고 체화해야한다.

<br>

### 점진적 설계

> 매일매일 설계를 점진적으로 진행을 해야한다는 실천방법이다.

+ 설명
	1960년 배리 보엠의 방위산업 연구에서 시간이 지날 수록 결함을 고치는 비용이 기하급수적으로 늘어나는 것을 증명했다.
	
	따라서 굵직한 기능들은 먼저 초기에 결정을 내리고 나머지 기능들은 나중에 결정을 내리는 것이 가장 경제적이다.
	
	그러나 시간에 따른 변경 비용의 상승 가설이 충분히 맞는 사실인지 충분한 조사가 없었다.
	변경을 한다고 해도 실제로 변경 비용의 상승하는 것인지 우리는 알 수가 없다.
	
	그러기 때문에 마지막 책임 지점까지 설계 투자를 미뤄야하는 것이 옳은 이유는 변경비용을 낮추기 위함이라고 할 수 있다.
	설계에 가장 기초적이고 최소한의 노력만을 기울이고, 그 상황에서 만들 수 있는 최대한의 스토리를 작성하라는 의미이다.
	
	반대로 스토리 작성은 미루고 설계에 많은 노력을 기울인다면 실질적으로 개발할 수 있는 시간은 거의 존재하지 않으며 이게 멀쩡히 동작하는지 조차 테스트할 시간도 없다.
	
	그러므로 설계는 최대한 베이비스텝으로 진행하고 개선은 중복을 제거하는 식으로 진행하면 된다.
	
	최대한 중복을 제거하다보면 한 코드때문에 전체 코드를 일일히 수정해야하는 설계상 오류, 즉 결합도가 지나치게 높은 문제를 해결 할 수 있다.
	
	물론 이러한 점진적인 설계 개선은 경험이 없으면 불가능한 것이 아니다.
	
	그리고 가장 핵심은 점진적으로 설계를 개선한 경우에 리팩터링을 하는 것과 한번에 설계후 리팩터링을 진행하는 경우에 난이도가 하늘과 땅차이이다.
	
	이미 틀이 고정형으로 잡힌 상태에서 뭘 고치려고하면 정말 난이도가 높다. 심지어 이것을 어뎁터 패턴으로 어거지로 해결해놓고 도망가는 경우도 대다수이다.
	
	**리펙터링, 기능 수정등은 어느 단계, 어느 순간에서나 무조건 일어난다.**

<br>

### 나머지

> 나머지 실천방법들은 다음장에서 보자.