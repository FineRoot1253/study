10
<br>

## 그래프의 이해와 구현

<br>

### 그래프의 역사와 이야깃거리

+ 최초의 그래프 알고리즘은 수학자 오일러에 의해 고안되었음
	쾨니히스베르크 다리문제를 풀기 위해 그래프 이론을 도입함

<br>

+ 쾨니히스베르크 다리 문제
	![[스크린샷 2023-05-11 오후 4.36.56.png]]
	
	간선은 다리, 정점은 땅을 의미한다.
	
	간선의 총 갯수는 7이므로 애초에 모든 다리를 한번씩만 건너서 출발한 장소로 돌아올 수 없다.

<br>

### 그래프의 이해와 종류

+ 무방향 그래프
	![[스크린샷 2023-05-11 오후 10.50.09.png]]
	
	정점(vertex)은 연결의 대상이 되는 개체 또는 위치를 의미한다.
	간선(edge)은 정점 사이의 연결을 의미한다.
	이런 연결관계에 방향성이 없는 그래프를 무방향 그래프(undirected graph)라고 부른다.

<br>

+ 방향 그래프
	![[스크린샷 2023-05-11 오후 10.50.15.png]]
	
	간선에 방향정보가 포함된 그래프를 방향 그래프(directed graph)또는 다이그래프(digraph)라고 부른다.


<br>

+ 완전 그래프
	![[스크린샷 2023-05-11 오후 10.50.39 1.png]]
	
	![[스크린샷 2023-05-11 오후 10.50.45 1.png]]
	
	각각의 정점에서 다른 모든 정점을 연결한 그래프를 완전 그래프라고 부른다.
	
	이때 **방향이 있는 완전 그래프는 무방향 완전 그래프에 비해 간선의 수가 2배 더 많다.**
<br>

### 가중치 그래프(Weight Graph)와 부분 그래프(Sub Graph)

+ 가중치 그래프
	![[스크린샷 2023-05-12 오후 5.00.23.png]]
	
	![[스크린샷 2023-05-12 오후 5.00.34.png]]
	
	정점 사이의 거리 또는 이동시간등 정보를 추가할 수 있다.
	예를 들면 예시의 무방향 가중치 그래프를 보면 A -> C로 가는데 바로 가는 것보다 정점 B를 거치는 것이 더 빠르다.
	
	이러한 개념은 각 배열로도 표현할 수도 있는데 그건 아래의 인접행렬에서 찾아보자

<br>

+ 부분 그래프
	![[스크린샷 2023-05-11 오후 11.06.16.png]]
	
	![[스크린샷 2023-05-13 오전 9.30.16.png]]
	
	부분 집합과 비슷한 개념의 그래프이며 위의 가중치 그래프의 일부 부분만 표현한 그래프이다.
	
	원 그래프의 일부 원소로 이루어진 집합인 것처럼 말이다.

<br>

### 그래프의 집합 표현

+ 무방향 그래프의 집합 표현 예시
	+ 집합 G1
		![[스크린샷 2023-05-11 오후 11.07.08.png]]
	
	+ 집합 G2
		![[스크린샷 2023-05-11 오후 11.07.14.png]]
	
	정점 집합을 V, 간선 집합을 E라고 하였을때 각 집합의 표현은 다음과 같다.
	
	+ G1
		V = {A, B, C, D}
		E = {{A, B}, {A, C}, {A, D}, {B, C}, {C, D}}
	
	+ G2
		V = {A, B, C, D}
		E = {{A, C}, {A, D}, {B, C}}

<br>

+ 방향 그래프의 집합 표현 예시
	+ 집합 G3
		![[스크린샷 2023-05-11 오후 11.07.22.png]]
	
	+ 집합 G4
		![[스크린샷 2023-05-13 오전 9.31.56.png]]
	
	정점 집합을 V, 간선 집합을 E라고 하고
	정점 A가 정점 C를 가리키는 간선은 <A, C>라고 표현할 때
	을때 각 집합의 표현은 다음과 같다.
	
	+ G3
		V = {A, B, C, D}
		E = {<A, B>, <A, C>, <A, D>, <B, C>, <C, D>}
	
	+ G4
		V = {A, B, C, D}
		E = {<A, C>, <A, D>, <B, C>}


<br>

### 그래프의 ADT

+ 기존 Operation
	+ void GraphInit(UALGraph\* pg, int nv);
		+ 그래프 초기화 진행한다.
		+ 두 번째 인자로 정점의 수를 전달한다.
	+ void GraphDestroy(UALGraph\* pg);
		+ 그래프 초기화 과정에서 할당한 리소스를 반환한다.
	+ void AddEdge(UALGraph\* pg, int fromV, int toV);
		+ 매개변수 fromV와 toV로 전달된 정점을 연결하는 간선을 그래프에 추가한다.
	+ void ShowGraphEdgeInfo(UALGraph\* pg);
		+ 그래프의 간선정보를 출력한다.

<br>

+ 내 Operation
	+ void addEdge(int fromV, int toV);
		+ 매개변수 fromV와 toV로 전달된 정점을 연결하는 간선을 그래프에 추가한다.

<br>

+ 팁
	enum을 사용하면 정점 추가시 의미있는 상수로 표현할 수 있다.
	
	근데 개인적으로는 그냥 string이나 char로 하면 문제될건 없다고 생각한다.


<br>

### 그래프를 표현하는 두 가지 방법

+ 인접 행렬(adjuacent matrix) 기반 그래프
	정방 행렬을 활용하는 방법
	
	+ 무방향 그래프의 인접 행렬 예시
		![[스크린샷 2023-05-13 오전 9.55.14.png]]
	
	+ 방향 그래프의 인접 행렬 예시
		![[스크린샷 2023-05-13 오전 9.51.01.png]]

<br>

+ 인접 리스트(adjuacent list) 기반 그래프
	연결리스트를 활용하는 방법
	
	+ 무방향 그래프의 인접 리스트 예시
		![[스크린샷 2023-05-13 오전 9.51.18.png]]
		위 그림은 null 표현 예시이다.
		
		![[스크린샷 2023-05-13 오전 9.58.25.png]]
	
	+ 무방향 그래프의 인접리스트 표현
		  ![[스크린샷 2023-05-13 오전 9.58.32.png]]

<br>

## 인접 리스트 기반의 그래프 구현

인접 행렬 기반으로 구현을 하면 동적으로 간선을 늘리고 줄이는 것은 상당히 까다로워진다.
상대적으로 쉬운 인접리스트 기반의 그래프를 구현해보도록 하겠다.

<br>

### 예제

``` cpp
#ifndef FIRSTCPP_ALGRAPH _H  
#define FIRSTCPP_ALGRAPH _H  
  
#include <iostream>  
  
#include "enthusiasm/linked_list/DLinkedList.h"  
  
using namespace Collection;  
  
  
namespace Collection {  
    namespace Graph {  
  
        enum class GraphVertexAlphabets : int{  
            A = 0,  
            B,  
            C,  
            D,  
            E  
        };  
  
        class ALGraph {  
        private:  
            int vertexNumber;  
            int edgeNumber;  
            DLinkedList<int> **adjacentList;  
  
        public:  
            ALGraph();  
  
            explicit ALGraph(const int &vertexNumber);  
  
            ALGraph(const ALGraph &ref);  
  
            ALGraph(ALGraph &&ref) noexcept;  
  
            ALGraph &operator=(const ALGraph &ref);  
  
            ALGraph &operator=(ALGraph &&ref) noexcept;  
  
            ~ALGraph();  
  
            friend std::ostream &operator<<(std::ostream &output, const ALGraph &ref);  
  
        public:  
            void addEdge(const int &fromV, const int &toV);  
        };  
  
        ALGraph::ALGraph()  
                : vertexNumber(0)  
                  , edgeNumber(0)  
                  , adjacentList(nullptr) {  
        }  
  
        ALGraph::ALGraph(const int &vertexNumber)  
                : vertexNumber(vertexNumber)  
                , edgeNumber(0){  
            adjacentList = new DLinkedList<int>*[vertexNumber];  
            for (int i = 0; i < vertexNumber; ++i) {  
                adjacentList[i] = new DLinkedList<int>();  
                adjacentList[i]->setSortRule(whichIsPrecede);  
            }  
        }  
  
        ALGraph::ALGraph(const ALGraph &ref)  
                : vertexNumber(ref.vertexNumber)  
                  , edgeNumber(ref.edgeNumber)  
                  , adjacentList(ref.adjacentList) {  
        }  
  
        ALGraph::ALGraph(ALGraph &&ref) noexcept  
                : vertexNumber(ref.vertexNumber)  
                  , edgeNumber(ref.edgeNumber)  
                  , adjacentList(ref.adjacentList) {  
            ref.adjacentList = nullptr;  
        }  
  
        ALGraph &ALGraph::operator=(const ALGraph &ref) {  
            vertexNumber = ref.vertexNumber;  
            edgeNumber = ref.edgeNumber;  
            adjacentList = new DLinkedList<int>*[vertexNumber];  
            for (int i = 0; i < vertexNumber; ++i) {  
                adjacentList[i] = new DLinkedList<int>(*ref.adjacentList[i]);  
            }  
            return *this;  
        }  
  
        ALGraph &ALGraph::operator=(ALGraph &&ref) noexcept {  
            vertexNumber = ref.vertexNumber;  
            edgeNumber = ref.edgeNumber;  
            adjacentList = ref.adjacentList;  
            ref.adjacentList = nullptr;  
            return *this;  
        }  
  
        ALGraph::~ALGraph() {  
            for (int i = 0; i < vertexNumber; ++i) {  
                delete adjacentList[i];  
            }  
            delete[] adjacentList;  
        }  
  
        void ALGraph::addEdge(const int &fromV, const int &toV) {  
            adjacentList[fromV]->insert(toV);  
            adjacentList[toV]->insert(fromV);  
            ++edgeNumber;  
        }  
  
        std::ostream &operator<<(std::ostream &output, const ALGraph &ref) {  
            for (int i = 0; i < ref.vertexNumber; ++i) {  
                output << static_cast<char>(i + 65) << "와 연결된 정점: ";  
                for (ref.adjacentList[i]->first(); !ref.adjacentList[i]->isDone(); ref.adjacentList[i]->next()) {  
                    if (!ref.adjacentList[i]->current().isError()) {  
                        output << static_cast<char>(ref.adjacentList[i]->current().getData() + 65) << " ";  
                    }  
                }  
                output << std::endl;  
            }  
            return output;  
        }  
  
    }  
}  
  
#endif // FIRSTCPP_ALGRAPH _H

#include "enthusiasm/graph/ALGraph.h"  
  
using namespace Collection::Graph;  
using Vertex = GraphVertexAlphabets;  
  
int vertexToIntegerCast(const Vertex& vertex){  
    return static_cast<int>(vertex);  
}  
  
int main(){  
    ALGraph graph = ALGraph(5);  
  
    graph.addEdge(vertexToIntegerCast(Vertex::A), vertexToIntegerCast(Vertex::B));  
    graph.addEdge(vertexToIntegerCast(Vertex::A), vertexToIntegerCast(Vertex::D));  
    graph.addEdge(vertexToIntegerCast(Vertex::B), vertexToIntegerCast(Vertex::C));  
    graph.addEdge(vertexToIntegerCast(Vertex::C), vertexToIntegerCast(Vertex::D));  
    graph.addEdge(vertexToIntegerCast(Vertex::D), vertexToIntegerCast(Vertex::E));  
    graph.addEdge(vertexToIntegerCast(Vertex::E), vertexToIntegerCast(Vertex::A));  
  
    std::cout<<graph;  
    return 0;  
}
```

+ 설명
	enum을 안쓰려했지만 배보다 배꼽이 더 커지는 여러 변환 연산들을 집어넣어야해서 그냥 enum으로 구현했다.
	
	예시와는 달리 포인터 객체 배열을 사용했는데 그 이유는 생성자에서 스택으로 DLinkedList()로 초기화하면 지역스택이기 때문에 스택이 끝나면 바로 소멸해버리는 문제가 있다.
	
	결국 저 소멸된 스택객체는 접근하는 순간 런타임 에러가 발생하므로 그냥 힙으로 올려서 리스트의 생체주기를 늘려주었다.

<br>

## 그래프의 탐색

> 그래프의 탐색이야말로 그래프의 꽃이라고 할 수 있다.
> 
> 그래프의 구현은 생각보다 어렵진 않다. 
> 
> 그러나 그래프의 탐색은 정말 여러가지의 알고리즘들이 존재한다.
> 
> 다익스트라, 크루스칼, 프림, DFS, BFS등등... 다 알아둬야 코테를 능히 통과 할 수 있다.
> 
> 특히 프로그래머스 3레벨로 넘어가는 순간 이러한 알고리즘을 2번 적용해야 해결이 가능한 문제들이 상당수 존재하기 때문에 이는 여러 코테 문제 풀이 경험을 통해 문제를 분석해낼 수 있어야한다.
<br>

### 깊이 우선 탐색 (DFS)

> 깊이 우선 탐색(Depth First Search)이란 가능한 한 길을 깊이 파고들어 탐색한 뒤, 이전 노드로 돌아와 다시 가능한 깊게 파고드는 알고리즘이다.
<br>

+ 깊이 우선 탐색 과정
	
	1. ![[스크린샷 2023-05-13 오후 2.51.31.png]] 
		다음과 같은 그래프에서 A부터 시작해 다시 A까지의 모든 노드를 탐색한다.
		이때 각 정점에서 다른 정점으로 단 한 정점으로만 이동한다는 생각으로 탐색한다.
		따라서 A -> C -> D -> F -> E 순으로 탐색한다.
		   
		이때, D에서 E나 B를 먼저가도 문제는 없지만 우선순위는 개발자인 내가 정해야한다.
	   
	2. ![[스크린샷 2023-05-13 오후 2.51.39.png]]
		E는 이미 본인과 연결된 모든 정점과 탐색을 마쳤고, F또한 마찬가지이다.
		E에서 왔던 간선을 따라 F으로 이동하고 
		F에서 왔던 간선을 따라 D로 이동한다.
		그리고 D에서 안가본 정점으로 B가 존재하므로 B로 이동한다.
	
	3. ![[스크린샷 2023-05-13 오후 2.51.53.png]]
		2에서 모든 정점에 탐색을 완료하였지만 다시 탐색 시작 정점인 A로 돌아와야 비로소 탐색이 완료하였다고 할 수 있다.
		
		따라서 B부터 왔었던 예전 간선을 따라서 뒤로 돌아가게 된다.
		B에서는 D, D에서는 C, C에서는 A로 뒤로 돌아가는 로직을 타게된다.
		
		즉, 재귀를 탈출하는 구조로 스택을 나온다고 보면된다.
		
		따라서 실제 DFS 구현에는 스택이 필수적으로 필요하다고 할 수 있다.


+ 추가 문제
	위의 예시 사진에서 만약 E로 시작해서 노드를 DFS로 탐색한다면 탐색순서는?
	
	+ 사전조건
		알파벳 순서로 탐색 우선순위를 정한다.
	
	+ 답
		1. E -> D -> B -> A -> C
			알파벳 순서이니 우선 D를 먼저 탐색한다.
			그 다음 우선순위가 더 높은 B를 탐색한다.
		2. C -> A -> B -> D -> F
			C에서 더 이상 가볼 수 있는 정점은 없으므로 왔던 간선을 따라서 경로를 빠져나온 뒤 D에서 더 경로가 있는지 찾아본다.
			이때 F는 탐색해보지 않았으므로 F로 이동한다.
		3. F -> D -> E
			F에서 시작 정점을 제외하고 모든 정점을 탐색 했으므로 다시 왔던 간선을 따라서 D, E순으로 빠져나온다.
	
	+ 결론
		E -> D -> B -> A -> C -> A -> B -> D -> F -> D -> E
<br>

### 너비 우선 탐색 (BFS)

> 너비 우선 탐색(Breath First Search)이란 한 정점을 토대로 연결된 모든 정점들을 탐색하는 알고리즘이다.

<br>

+ 너비 우선 탐색 과정
	+ 사전 조건
		![[스크린샷 2023-05-13 오후 3.18.29.png]]
		다음과 같은 그래프가 있고 탐색 시작정점은 B이다.
	
	1. ![[스크린샷 2023-05-13 오후 3.18.35.png]]
		B에서 탐색 가능한 정점은 A, D이다.
		이때 순서는 상관 없긴 하지만 알파벳 순으로 탐색한다고 하자
	
	2. ![[스크린샷 2023-05-13 오후 3.18.44.png]]
	    A가 먼저 C를 탐색한다. 그리고 C가 아닌 원래 순서인 D가 E, F를 탐색한다.
	    알파벳 순서이니 E를 먼저 탐색한 뒤 F를 탐색한다.
	
	3. ![[스크린샷 2023-05-13 오후 3.18.53.png]]
		이제 C와 E, F에서 탐색을 시도해야한다.
		F를 제외한 각 정점의 주변 정점은 탐색을 완료했으므로 F에서 G로 탐색을 시도한다.
	
	4. 마지막으로 G에서 탐색 시도를 한 뒤 탐색을 시도할 정점이 없다는 것이 판정되면 비로소 모든 정점을 탐색했다고 판단한다.
		   
		이 너비 우선 탐색은 깊이 우선 탐색과 달리 탐색을 시도해야할 정점의 순서를 중요하게 여긴다. 
		
		즉, 탐색 우선 순서가 중요하므로 큐를 이용해야한다.
		
		따라서 BFS 구현에는 큐가 가장 중요하다고 할 수 있다. 

<br>

### 깊이 우선 탐색의 구현 모델

> 깊이 우선 탐색은 스택을 활용한 재귀 구조로 구성하는 것이 중요하다.

+ DFS 동작 구조
	+ 사전 조건
		1. 위의 DFS 설명의 동작 과정을 따른다.
		2. 방문 정보인 boolean 배열과 방문 순서를 담을 스택을 준비한다.
	1. 시작 노드인 A부터 탐색이 가능한 정점을 탐색하기 시작한다. boolean 배열에 A에 해당하는 인덱스를 true로 바꾼다. 
		그리고 이동이 가능한 정점이 있는지 검사한다.
		존재 한다면 스택에 A를 담는다.
		+ 현재 스택 현황
			 | A | 
		+ 현재 배열 현황
			| A   | B   | C   | D   | E   | F   |
			| :---: | :---: | :---: | :---: | :---: | :---: |
			| true    |  false   |  false   |  false   |  false   |   false  |
	2. 그 다음 순서인 B에서 탐색한다. boolean 배열에 B에 해당하는 인덱스를 true로 바꾼다.
		그리고 이동이 가능한 정점이 있는지 검사한다.
		존재 한다면 스택에 B를 담는다.
		+ 현재 스택 현황
			 | A | B |
		+ 현재 배열 현황
			| A   | B   | C   | D   | E   | F   |
			| :---: | :---: | :---: | :---: | :---: | :---: |
			| true    |  true   |  false   |  false   |  false   |   false  |
	3. 그 다음 순서인 D를 탐색한다. boolean 배열에 D에 해당하는 인덱스를 true로 바꾼다.
		그리고 이동이 가능한 노드가 있는지 검사한다.
		존재한다면 스택에 D를 담는다.
		+ 현재 스택 현황
			 | A | B | D |
		+ 현재 배열 현황
			| A   | B   | C   | D   | E   | F   |
			| :---: | :---: | :---: | :---: | :---: | :---: |
			| true    |  true   |  false   |  true   |  false   |   false  |
	3. 그 다음 순서인 C를 탐색한다. boolean 배열에 C에 해당하는 인덱스를 true로 바꾼다.
		그리고 이동이 가능한 노드가 있는지 검사한다.
		존재하지 않기 때문에 스택에서 D를 꺼내고 D로 이동한다.
		+ 현재 스택 현황
			 | A | B |
		+ 현재 배열 현황
			| A   | B   | C   | D   | E   | F   |
			| :---: | :---: | :---: | :---: | :---: | :---: |
			| true    |  true   |  true   |  true   |  false   |   false  |
	4. C에서 D로 이동한 뒤 다시 탐색 가능한 정점이 있는지 검사한다.
		   이때, E 또는 F가 이동가능한데 알파벳 순으로 E로 이동한다.
		   이동이 가능한 정점이 있으므로 스택에 다시 뺏던 D를 넣고 E로 이동한다.
		+ 현재 스택 현황
			 | A | B | D |
		+ 현재 배열 현황
			| A   | B   | C   | D   | E   | F   |
			| :---: | :---: | :---: | :---: | :---: | :---: |
			| true    |  true   |  true   |  true   |  false   |   false  |
	5. 그 다음 순서인 E에서 탐색을 시작한다. boolean 배열에 E에 해당하는 인덱스를 true로 바꾼다.
		   그리고 이동이 가능한 정점이 있는지 검사한다.
		   존재한다면 스택에 E를 담는다.
		+ 현재 스택 현황
			 | A | B | D | E |
		+ 현재 배열 현황
			| A   | B   | C   | D   | E   | F   |
			| :---: | :---: | :---: | :---: | :---: | :---: |
			| true    |  true   |  true   |  true   |  true   |   false  |
	1. 그 다음 순서인 F에서 탐색을 시작한다. boolean 배열에 F에 해당하는 인덱스를 true로 바꾼다.
		   그리고 이동이 가능한 정점이 있는지 검사한다.
		   존재하지 않기 때문에 스택에서 E를 꺼내고 E로 이동한다.
		+ 현재 스택 현황
			 | A | B | D | 
		+ 현재 배열 현황
			| A   | B   | C   | D   | E   | F   |
			| :---: | :---: | :---: | :---: | :---: | :---: |
			| true    |  true   |  true   |  true   |  true   |   true  |
	1. F에서 E로 이동한 뒤 E에서 탐색을 시작한다. boolean 배열에 E에 해당하는 인덱스를 true로 바꾼다.
		   그리고 이동이 가능한 정점이 있는지 검사한다.
		   존재하지 않기 때문에 스택에서 D를 꺼내고 D로 이동한다.
		+ 현재 스택 현황
			 | A | B | 
		+ 현재 배열 현황
			| A   | B   | C   | D   | E   | F   |
			| :---: | :---: | :---: | :---: | :---: | :---: |
			| true    |  true   |  true   |  true   |  true   |   true  |
	1. E에서 D로 이동한 뒤 D에서 탐색을 시작한다. boolean 배열에 D에 해당하는 인덱스를 true로 바꾼다.
		   그리고 이동이 가능한 정점이 있는지 검사한다.
		   존재하지 않기 때문에 스택에서 B를 꺼내고 B로 이동한다.
		+ 현재 스택 현황
			 | A |
		+ 현재 배열 현황
			| A   | B   | C   | D   | E   | F   |
			| :---: | :---: | :---: | :---: | :---: | :---: |
			| true    |  true   |  true   |  true   |  true   |   true  |
	1. D에서 B로 이동한 뒤 B에서 탐색을 시작한다. boolean 배열에 B에 해당하는 인덱스를 true로 바꾼다.
		   그리고 이동이 가능한 정점이 있는지 검사한다.
		   존재하지 않기 때문에 스택에서 A를 꺼내고 A로 이동한다.
		+ 현재 스택 현황
			||
		+ 현재 배열 현황
			| A   | B   | C   | D   | E   | F   |
			| :---: | :---: | :---: | :---: | :---: | :---: |
			| true    |  true   |  true   |  true   |  true   |   true  |
	1. D에서 B로 이동한 뒤 B에서 탐색을 시작한다. boolean 배열에 B에 해당하는 인덱스를 true로 바꾼다.
		   그리고 이동이 가능한 정점이 있는지 검사한다.
		   존재하지 않기 때문에 스택에서 정점을 꺼내야하는데 없으므로 재귀에서 탈출한다.
		+ 현재 스택 현황
			||
		+ 현재 배열 현황
			| A   | B   | C   | D   | E   | F   |
			| :---: | :---: | :---: | :---: | :---: | :---: |
			| true    |  true   |  true   |  true   |  true   |   true  |

<br>

### 깊이 우선 탐색의 실제 구현

<br>

### 예제

``` cpp
#ifndef FIRSTCPP_ALGRAPH _H  
#define FIRSTCPP_ALGRAPH _H  
  
#include <iostream>  
  
#include "enthusiasm/linked_list/DLinkedList.h"  
  
using namespace Collection;  
  
  
namespace Collection {  
    namespace Graph {  
  
        enum class GraphVertexAlphabets : int{  
            A = 0,  
            B,  
            C,  
            D,  
            E,  
            F,  
            G,  
            H,  
            I,  
            J,  
            K  
        };  
  
        class ALGraph {  
        private:  
            int vertexNumber;  
            int edgeNumber;  
            DLinkedList<int> **adjacentList;  
  
        public:  
            ALGraph();  
  
            explicit ALGraph(const int &vertexNumber);  
  
            ALGraph(const ALGraph &ref);  
  
            ALGraph(ALGraph &&ref) noexcept;  
  
            ALGraph &operator=(const ALGraph &ref);  
  
            ALGraph &operator=(ALGraph &&ref) noexcept;  
  
            ~ALGraph();  
  
            friend std::ostream &operator<<(std::ostream &output, const ALGraph &ref);  
  
        public:  
            void addEdge(const int &fromV, const int &toV);  
            DLinkedList<int> getAdjacentList(const int& vertex) const;  
        };  
  
        ALGraph::ALGraph()  
                : vertexNumber(0)  
                  , edgeNumber(0)  
                  , adjacentList(nullptr) {  
        }  
  
        ALGraph::ALGraph(const int &vertexNumber)  
                : vertexNumber(vertexNumber)  
                , edgeNumber(0){  
            adjacentList = new DLinkedList<int>*[vertexNumber];  
            for (int i = 0; i < vertexNumber; ++i) {  
                adjacentList[i] = new DLinkedList<int>();  
                adjacentList[i]->setSortRule(whichIsPrecede);  
            }  
        }  
  
        ALGraph::ALGraph(const ALGraph &ref)  
                : vertexNumber(ref.vertexNumber)  
                  , edgeNumber(ref.edgeNumber){  
            adjacentList = new DLinkedList<int> *[vertexNumber];  
            for (int i = 0; i < vertexNumber; ++i) {  
                adjacentList[i] = new DLinkedList<int>(*ref.adjacentList[i]);  
            }  
  
        }  
  
        ALGraph::ALGraph(ALGraph &&ref) noexcept  
                : vertexNumber(ref.vertexNumber)  
                  , edgeNumber(ref.edgeNumber)  
                  , adjacentList(ref.adjacentList) {  
            ref.adjacentList = nullptr;  
        }  
  
        ALGraph &ALGraph::operator=(const ALGraph &ref) {  
            if(this != &ref){  
                for (int i = 0; i < vertexNumber; ++i) {  
                    delete adjacentList[i];  
                }  
                delete[] adjacentList;  
                vertexNumber = ref.vertexNumber;  
                edgeNumber = ref.edgeNumber;  
                adjacentList = new DLinkedList<int>*[vertexNumber];  
                for (int i = 0; i < vertexNumber; ++i) {  
                    adjacentList[i] = new DLinkedList<int>(*ref.adjacentList[i]);  
                }  
            }  
            return *this;  
        }  
  
        ALGraph &ALGraph::operator=(ALGraph &&ref) noexcept {  
            vertexNumber = ref.vertexNumber;  
            edgeNumber = ref.edgeNumber;  
            adjacentList = ref.adjacentList;  
            ref.adjacentList = nullptr;  
            return *this;  
        }  
  
        ALGraph::~ALGraph() {  
            for (int i = 0; i < vertexNumber; ++i) {  
                delete adjacentList[i];  
            }  
            delete[] adjacentList;  
        }  
  
        void ALGraph::addEdge(const int &fromV, const int &toV) {  
            adjacentList[fromV]->insert(toV);  
            adjacentList[toV]->insert(fromV);  
            ++edgeNumber;  
        }  
  
        std::ostream &operator<<(std::ostream &output, const ALGraph &ref) {  
            for (int i = 0; i < ref.vertexNumber; ++i) {  
                output << static_cast<char>(i + 65) << "와 연결된 정점: ";  
                for (ref.adjacentList[i]->first(); !ref.adjacentList[i]->isDone(); ref.adjacentList[i]->next()) {  
                    if (!ref.adjacentList[i]->current().isError()) {  
                        output << static_cast<char>(ref.adjacentList[i]->current().getData() + 65) << " ";  
                    }  
                }  
                output << std::endl;  
            }  
            return output;  
        }  
  
        DLinkedList<int> ALGraph::getAdjacentList(const int &vertex) const{  
            if(vertexNumber < vertex+1){  
                return DLinkedList<int>();  
            }  
            return *adjacentList[vertex];  
        }  
  
    }  
}  
  
#endif // FIRSTCPP_ALGRAPH _H

#ifndef FIRSTCPP_ALGRAPHDFS _H  
#define FIRSTCPP_ALGRAPHDFS _H  
  
#include <iostream>  
#include "enthusiasm/graph/ALGraph.h"  
#include "enthusiasm/stack/ListBaseStack.h"  
  
using namespace Collection::Graph;  
  
namespace Enthusiasm {  
    namespace Graph {  
        namespace Search {  
            class DFS {  
            private:  
                ALGraph *graph;  
                bool *visitInfoArray;  
                ListBaseStack<int> stack;  
  
            private:  
                bool visitVertex(const int &vertex);  
  
            public:  
                DFS(const int &vertexNumber, ALGraph *graph);  
                DFS(const DFS &ref);  
                DFS(DFS &&ref) noexcept;  
                DFS &operator=(const DFS &ref);  
                DFS &operator=(DFS &&ref) noexcept;  
  
                ~DFS() {  
                    delete[] visitInfoArray;  
                };  
  
            public:  
                void showDFSTraverse(const int &startVertex);  
            };  
  
            DFS::DFS(const int &vertexNumber, ALGraph *graph)  
                    : graph(graph)  
                      , visitInfoArray(new bool[vertexNumber])  
                      , stack(ListBaseStack<int>()) {  
            }  
  
            DFS::DFS(const DFS &ref)  
                    : graph(ref.graph)  
                      , visitInfoArray(new bool[sizeof(ref.visitInfoArray) / sizeof(bool)])  
                      , stack(ListBaseStack<int>()) {  
                for (int i = 0; i < sizeof(ref.visitInfoArray) / sizeof(bool); ++i) {  
                    visitInfoArray[i] = ref.visitInfoArray[i];  
                }  
            }  
  
            DFS::DFS(DFS &&ref) noexcept  
                    : graph(ref.graph)  
                      , visitInfoArray(nullptr)  
                      , stack(ListBaseStack<int>()) {  
                std::swap(visitInfoArray, ref.visitInfoArray);  
                ref.visitInfoArray = nullptr;  
            }  
  
            DFS &DFS::operator=(const DFS &ref) {  
                if(this != &ref){  
                    graph = ref.graph;  
                    stack = ListBaseStack<int>();  
  
                    delete[] visitInfoArray;  
                    visitInfoArray = new bool[sizeof(ref.visitInfoArray) / sizeof(bool)];  
                    for (int i = 0; i < sizeof(ref.visitInfoArray) / sizeof(bool); ++i) {  
                        visitInfoArray[i] = ref.visitInfoArray[i];  
                    }  
                }  
                return *this;  
            }  
  
            DFS &DFS::operator=(DFS &&ref) noexcept {  
                graph = ref.graph;  
                stack = ListBaseStack<int>();  
                std::swap(visitInfoArray, ref.visitInfoArray);  
                ref.visitInfoArray = nullptr;  
                return *this;  
            }  
  
            bool DFS::visitVertex(const int &vertex) {  
                if (!visitInfoArray[vertex]) {  
                    visitInfoArray[vertex] = true;  
                    std::cout << static_cast<char>(vertex + 65);  
                    return true;                }  
                return false;  
            }  
  
            void DFS::showDFSTraverse(const int &startVertex) {  
                DLinkedList<int> list = graph->getAdjacentList(startVertex); // 2, 4, 3  
                int beforeVertex = startVertex;  
                // 방문 처리  
                visitVertex(startVertex);  
  
                for (list.first(); !list.isDone(); list.next()) {  
                    // 방문 검사 후 통과시 현재 시작 정점 스택에 추가  
                    if (!visitInfoArray[list.current().getData()]) {  
                        std::cout << list.current().getData() << std::endl;  
                        stack.push(startVertex);  
                        showDFSTraverse(list.current().getData());  
                    }  
                }  
                if(!stack.isEmpty()){  
                    stack.pop();  
                }  
            }  
        }  
    }  
}  
#endif // FIRSTCPP_ALGRAPHDFS _H

#include "enthusiasm/graph/ALGraphDFS.h"  
using namespace Collection::Graph;  
using namespace Enthusiasm::Graph::Search;  
using Vertex = GraphVertexAlphabets;  
  
int vertexToIntegerCast(const Vertex& vertex){  
    return static_cast<int>(vertex);  
}  
int main(){  
    ALGraph* graph = new ALGraph(6);  
    DFS dfs = DFS(6,graph);  
  
    graph->addEdge(vertexToIntegerCast(Vertex::A), vertexToIntegerCast(Vertex::B));  
    graph->addEdge(vertexToIntegerCast(Vertex::A), vertexToIntegerCast(Vertex::C));  
    graph->addEdge(vertexToIntegerCast(Vertex::B), vertexToIntegerCast(Vertex::D));  
    graph->addEdge(vertexToIntegerCast(Vertex::C), vertexToIntegerCast(Vertex::A));  
    graph->addEdge(vertexToIntegerCast(Vertex::C), vertexToIntegerCast(Vertex::D));  
    graph->addEdge(vertexToIntegerCast(Vertex::D), vertexToIntegerCast(Vertex::E));  
    graph->addEdge(vertexToIntegerCast(Vertex::D), vertexToIntegerCast(Vertex::F));  
    graph->addEdge(vertexToIntegerCast(Vertex::E), vertexToIntegerCast(Vertex::F));  
    graph->addEdge(vertexToIntegerCast(Vertex::F), vertexToIntegerCast(Vertex::E));  
  
    std::cout<<*graph;  
  
    dfs.showDFSTraverse(vertexToIntegerCast(Vertex::A));  
  
    return 0;  
}

```

+ 설명
	2중 할당 해제 문제 때문에 따로 heap 할당을 추가하였다.
	
	showDFSTraverse() 내부에서 list를 할당해제하면서 동시에 내부에 모든 포인터 변수가 할당해제가 되서 문제를 겪었는데 
	그래서 graph를 책의 의도와는 달리 heap할당하게끔 수정했다.
	
	이렇게 구현하면 사실 스택 자료구조는 의미가 없다.
	그냥 콜스택을 활용했기 때문이다.
	만약 스택을 활용해서 구현하고 싶다면 포문으로 구현하면된다.
	다만 포문으로 구현하면 그게 더 이해하기 버겁다.
	기존 책에있는 예제는 포문으로 구현이 되어있는데 코드도 3배 더 길고 확실히 이해하기 힘들다.

<br>

### 너비 우선 탐색의 구현 모델

> 탐색을 누가 먼저 할 것인지 순서를 지키는 것이 중요하기 때문에 큐를 활용하는 것이 중요하다.

+ BFS 탐색 구조
	+    사전 조건
	    1.  위의 DFS 설명의 동작 과정을 따른다.
	    2.  방문 정보인 boolean 배열과 방문 순서를 담을 스택을 준비한다.
	1.  시작 정점인 B부터 탐색이 가능한 정점을 탐색하기 시작한다. boolean 배열에 B에 해당하는 인덱스를 true로 바꾼다.  
	    그리고 이동이 가능한 정점이 있는지 검사한다.  
	    -   현재 큐 현황  
		||
	    -   현재 배열 현황 
		|  A  |  B  |  C  |  D  |  E  |  F  |  G  |
		|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
		|  false   |  true   |  false   |  false   |  false   |  false   |  false   |
	2. B에서 이동가능 한 정점(boolean 배열에 false 인 정점)인 A, D를 큐에 넣는다. 이때, 정점은 연결리스트에 insert된 순서대로 넣는다.
	   그리고 boolean 배열에 A, D를 true로 바꾼다.
	    -   현재 큐 현황  
		|D|A|
	    -   현재 배열 현황 
		|  A  |  B  |  C  |  D  |  E  |  F  |  G  |
		|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
		|  true   |  true   |  false   |  true   |  false   |  false   |  false   |
	3. 큐에서 A를 꺼낸 뒤 이동 가능한 정점을 찾아 다시 큐에 넣는다.
		   이때 이동 가능한 정점은 C이므로 C를 큐에 넣고 boolean 배열도 true로 바꾼다.
	    -   현재 큐 현황  
		|C|D|
	    -   현재 배열 현황 
		|  A  |  B  |  C  |  D  |  E  |  F  |  G  |
		|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
		|  true   |  true   |  true   |  true   |  false   |  false   |  false   |
	4. 큐에서 D를 꺼낸 뒤 이동 가능한 정점을 찾아 다시 큐에 넣는다.
		이때 이동 가능한 정점은 E, F이므로 E, F를 큐에 넣고 boolean 배열도 true로 바꾼다.
	    -   현재 큐 현황  
		|F|E|C|
	    -   현재 배열 현황 
		|  A  |  B  |  C  |  D  |  E  |  F  |  G  |
		|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
		|  true   |  true   |  true   |  true   |  true   |  true   |  false   |
	5. 큐에서 C를 꺼낸 뒤 이동 가능한 정점을 찾아 다시 큐에 넣는다.
		   이때 이동가능한 정점은 없으므로 넘어간다.
	    -   현재 큐 현황  
		|F|E|
	    -   현재 배열 현황 
		|  A  |  B  |  C  |  D  |  E  |  F  |  G  |
		|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
		|  true   |  true   |  true   |  true   |  true   |  true   |  false   |
	6. 큐에서 E를 꺼낸 뒤 이동가능한 정점을 찾아 다시 큐에 넣는다.
		이때 이동가능한 정점은 없으므로 넘어간다.
	    -   현재 큐 현황  
		|F|
	    -   현재 배열 현황 
		|  A  |  B  |  C  |  D  |  E  |  F  |  G  |
		|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
		|  true   |  true   |  true   |  true   |  true   |  true   |  false   |
	7. 큐에서 F를 꺼낸 뒤 이동 가능한 정점을  찾아 다시 큐에 넣는다.
		이때 이동 가능한 정점은 G이므로 G를 큐에 넣고 boolean 배열도 true로 바꾼다.
	    -   현재 큐 현황  
		|G|
	    -   현재 배열 현황 
		|  A  |  B  |  C  |  D  |  E  |  F  |  G  |
		|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
		|  true   |  true   |  true   |  true   |  true   |  true   |  true   |
	8. 큐에서 G를 꺼낸 뒤 이동 가능한 정점을 찾아 다시 큐에 넣는다.
		이때 이동 가능한 정점은 없으므로 넘어간다.
	    -   현재 큐 현황  
		||
	    -   현재 배열 현황 
		|  A  |  B  |  C  |  D  |  E  |  F  |  G  |
		|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
		|  true   |  true   |  true   |  true   |  true   |  true   |  true   |


<br>

### 너비 우선 탐색의 실제 구현

<br>

### 예제

``` cpp
#ifndef FIRSTCPP_ALGRAPHBFS _H  
#define FIRSTCPP_ALGRAPHBFS _H  
  
#include <iostream>  
#include "enthusiasm/graph/ALGraph.h"  
#include "enthusiasm/queue/ListBaseQueue.h"  
  
using namespace Collection::Graph;  
using namespace Collection::Queue;  
  
namespace Enthusiasm {  
    namespace Graph {  
        namespace Search {  
            class BFS {  
            private:  
                ALGraph *graph;  
                bool *visitInfoArray;  
                ListBaseQueue<int> queue;  
  
            private:  
                bool visitVertex(const int &vertex);  
  
            public:  
                BFS(const int &vertexNumber, ALGraph *graph);  
                BFS(const BFS &ref);  
                BFS(BFS &&ref) noexcept;  
                BFS &operator=(const BFS &ref);  
                BFS &operator=(BFS &&ref) noexcept;  
  
                ~BFS() {  
                    delete[] visitInfoArray;  
                };  
  
            public:  
                void showBFSTraverse(const int &startVertex);  
            };  
  
            BFS::BFS(const int &vertexNumber, ALGraph *graph)  
                    : graph(graph)  
                      , visitInfoArray(new bool[vertexNumber])  
                      , queue(ListBaseQueue<int>()) {  
            }  
  
            BFS::BFS(const BFS &ref)  
                    : graph(ref.graph)  
                      , visitInfoArray(new bool[sizeof(ref.visitInfoArray) / sizeof(bool)])  
                      , queue(ListBaseQueue<int>()) {  
                for (int i = 0; i < sizeof(ref.visitInfoArray) / sizeof(bool); ++i) {  
                    visitInfoArray[i] = ref.visitInfoArray[i];  
                }  
            }  
  
            BFS::BFS(BFS &&ref) noexcept  
                    : graph(ref.graph)  
                      , visitInfoArray(nullptr)  
                      , queue(ListBaseQueue<int>()) {  
                std::swap(visitInfoArray, ref.visitInfoArray);  
                ref.visitInfoArray = nullptr;  
            }  
  
            BFS &BFS::operator=(const BFS &ref) {  
                if(this != &ref){  
                    graph = ref.graph;  
                    queue = ListBaseQueue<int>();  
  
                    delete[] visitInfoArray;  
                    visitInfoArray = new bool[sizeof(ref.visitInfoArray) / sizeof(bool)];  
                    for (int i = 0; i < sizeof(ref.visitInfoArray) / sizeof(bool); ++i) {  
                        visitInfoArray[i] = ref.visitInfoArray[i];  
                    }  
                }  
                return *this;  
            }  
  
            BFS &BFS::operator=(BFS &&ref) noexcept {  
                graph = ref.graph;  
                queue = ListBaseQueue<int>();  
                std::swap(visitInfoArray, ref.visitInfoArray);  
                ref.visitInfoArray = nullptr;  
                return *this;  
            }  
  
            bool BFS::visitVertex(const int &vertex) {  
                if (!visitInfoArray[vertex]) {  
                    visitInfoArray[vertex] = true;  
                    std::cout << static_cast<char>(vertex + 65)<<" ";  
                    return true;                }  
                return false;  
            }  
  
            void BFS::showBFSTraverse(const int &startVertex) {  
                DLinkedList<int> list = graph->getAdjacentList(startVertex); // 2, 4, 3  
                int beforeVertex = startVertex;  
                bool isDone = false;  
                // 초기 시작 정점 방문 처리  
                visitVertex(startVertex);  
                                while(!isDone){  
                    // 이동 가능한 정점 검사 후 하나씩 큐에 삽입 처리  
                    for (list.first(); !list.isDone(); list.next()) {  
                        // 방문 검사 후 통과시 현재 시작 정점 큐에 추가  
                        if (visitVertex(list.current().getData())) {  
                            queue.enqueue(list.current().getData());  
                        }  
                    }  
                    if(!queue.isEmpty()){  
                        int vertex = queue.dequeue();  
                        list = graph->getAdjacentList(vertex);  
                    }else{  
                        // 큐가 텅 비면 끝,  
                        // 만약 간선이 없는 정점으로 시작하면 큐가 당연히 텅 비므로 무조건 탈출한다. 주의할 것  
                        isDone = true;  
                    }  
                }  
                std::fill(visitInfoArray, visitInfoArray + (sizeof(visitInfoArray)/sizeof(bool)), false);  
            }  
        }  
    }  
}  
#endif // FIRSTCPP_ALGRAPHBFS _H

#include "enthusiasm/graph/ALGraphBFS.h"  
  
using namespace Enthusiasm::Graph::Search;  
using Vertex = GraphVertexAlphabets;  
  
int vertexToIntegerCast(const Vertex& vertex){  
    return static_cast<int>(vertex);  
}  
int main(){  
    ALGraph* graph = new ALGraph(7);  
    BFS bfs = BFS(7,graph);  
  
    graph->addEdge(vertexToIntegerCast(Vertex::A), vertexToIntegerCast(Vertex::B));  
    graph->addEdge(vertexToIntegerCast(Vertex::A), vertexToIntegerCast(Vertex::D));  
    graph->addEdge(vertexToIntegerCast(Vertex::B), vertexToIntegerCast(Vertex::C));  
    graph->addEdge(vertexToIntegerCast(Vertex::D), vertexToIntegerCast(Vertex::C));  
    graph->addEdge(vertexToIntegerCast(Vertex::D), vertexToIntegerCast(Vertex::E));  
    graph->addEdge(vertexToIntegerCast(Vertex::E), vertexToIntegerCast(Vertex::F));  
    graph->addEdge(vertexToIntegerCast(Vertex::E), vertexToIntegerCast(Vertex::G));  
  
    std::cout<<*graph;  
  
    bfs.showBFSTraverse(vertexToIntegerCast(Vertex::A));  
    std::cout<<std::endl;  
    bfs.showBFSTraverse(vertexToIntegerCast(Vertex::C));  
    std::cout<<std::endl;  
    bfs.showBFSTraverse(vertexToIntegerCast(Vertex::E));  
    std::cout<<std::endl;  
    bfs.showBFSTraverse(vertexToIntegerCast(Vertex::G));  
    std::cout<<std::endl;  
    return 0;  
}
```

+ 설명
	operation은 DFS와 동일하다. 단순히 순회하는 로직, stack대신 queue를 넣은 점이 다르다.
	
	이 순회 탐색 과정을 보면 BFS보다 단순하다.
	
	재귀를 이용하지 않아도 된다는 점이 이해하기 더 단순하게 만들어주며 queue를 이용해 탐색 순서만 잡아주면되니 간단하다.

<br>

## 최소 비용 신장 트리

<br>

### 사이클을 형성하지 않는 그래프

![[스크린샷 2023-05-11 오후 11.07.08.png]]

위의 그래프중 B -> D로 이어지는 경로는 다음과 같다.
+ B - A - D
+ B - C - D
+ B - A - C - D
+ B - C - A - D

위와 같은 경로는 특정 간선을 중복해서 순회하지 않으므로 단순 경로(simple path)라고 부른다.

![[스크린샷 2023-05-17 오후 4.03.07.png]]

이런 단순 경로를 모아서 그중 사이클이 없는 경로는 위와 같은 트리와 같다.

우리는 이런 트리를 신장 트리(spanning tree)라고 부른다.

<br>

### 최소 비용 신장 트리의 이해와 적용

+ 신장 트리의 특징
	+ 그래프의 모든 정점이 간선에 의해서 하나로 연결되어 있다.
	+ 그래프 내에서 사이클을 형성하지 않는다.

<br>

+ 최소 비용 신장 트리
	+ 예시
		![[스크린샷 2023-05-17 오후 4.03.21.png]]
		![[스크린샷 2023-05-17 오후 4.03.31.png]]
	
	위의 예시처럼 가중치 무방향 그래프를 기준으로도 신장 트리 구성이 가능하다.
	
	그리고 위의 두 번째 사진처럼 모든 간선의 합이 최소인 그래프를 가리켜 최소 비용 신장 트리(minimum cost spanning tree), 또는 최소 신장 트리(minnimum spanning tree, 이하 MST)라고 한다.

<br>

#### 예시

![[스크린샷 2023-05-17 오후 4.03.38 1.png]]
위와 같은 무방향 그래프가 있을 때 가중치를 추가한 가중치 무방향 그래프는 다음과 같다.
![[스크린샷 2023-05-17 오후 4.03.46.png]]
이 가중치 무방향 그래프를 MST로 만들면 다음과 같다.
![[스크린샷 2023-05-17 오후 4.05.50.png]]

<br>

### 최소 비용 신장 트리의 구성을 위한 크루스칼 알고리즘 1

+ 대표적인 MST 탐색 알고리즘
	+ 크루스칼 알고리즘
	+ 프림 알고리즘
	
	참고로 유명한 다익스트라 알고리즘은 최단 경로 탐색 알고리즘이지 MST 탐색 알고리즘은 아니다.

<br>

+ 대표적인 최단 경로 탐색 알고리즘
	+ 다익스트라 알고리즘
	+ 벨만-포드 알고리즘

<br>

위의 알고리즘들의 특징은 벨만-포드를 제외하고 그리디 접근법을 가지고 있다.
벨만 - 포드는 DP 접근법으로 모든 간선을 순회하면서 최단 거리를 기록, 갱신하는 방식이다.

<br>

#### 크루스칼 알고리즘 오름차순 정렬 예시

+ 예시
	![[스크린샷 2023-05-17 오후 4.06.56.png]]
	
	이 예시를 기준으로 MST를 찾아보자.
	
	우선 각 가중치를 오름차순으로 배열에 정렬한다.
	+ 현재 배열
		|||||||||||

<br>

![[스크린샷 2023-05-17 오후 4.07.10.png]]
+ 현재 배열
	|2||||||||||

MST인지 검사한다.
MST면 탈출한다.
우선 가중치가 제일 낮은 2를 선택한다.
선택 할 때마다 선택 이후 사이클이 형성되었는지 확인한다.
2은 문제가 없으므로 2을 선택한다.

<br>

![[스크린샷 2023-05-17 오후 4.07.27.png]]
+ 현재 배열
	|2|3|4|6|||||||

MST인지 검사한다.
MST면 탈출한다.
가중치가 제일 낮은 3를 선택한다.
선택 할 때마다 선택 이후 사이클이 형성되었는지 확인한다.
3은 문제가 없으므로 3을 선택한다.

MST인지 검사한다.
MST면 탈출한다.
가중치가 제일 낮은 4를 선택한다.
선택 할 때마다 선택 이후 사이클이 형성되었는지 확인한다.
4은 문제가 없으므로 4을 선택한다.

MST인지 검사한다.
MST면 탈출한다.
가중치가 제일 낮은 6를 선택한다.
선택 할 때마다 선택 이후 사이클이 형성되었는지 확인한다.
6은 문제가 없으므로 6을 선택한다.

<br>

![[스크린샷 2023-05-17 오후 4.07.36.png]]
+ 현재 배열
	|2|3|4|6||8|||||

MST인지 검사한다.
MST면 탈출한다.
가중치가 제일 낮은 7를 선택한다. 
선택 할 때마다 선택 이후 사이클이 형성되었는지 확인한다.
7를 택할 경우 사이클이 형성 되므로 넘어간다.

MST인지 검사한다.
MST면 탈출한다.
가중치가 제일 낮은 8를 선택한다.
선택 할 때마다 선택 이후 사이클이 형성되었는지 확인한다.
8은 문제가 없으므로 8을 선택한다.

MST인지 검사한다.
비로서 이제 모든 정점이 연결되었으므로 탐색을 종료한다.

<br>

### 최소 비용 신장 트리의 구성을 위한 크루스칼 알고리즘 2

+ 예시
	![[스크린샷 2023-05-17 오후 4.06.56.png]]
	
	이 예시를 기준으로 MST를 내림차순으로 찾아보자.
	
	내림차순의 경우 배열에서 하나씩 소거해야한다.
	
	+ 현재 배열
		|13|12|11|9|8|7|6|4|3|2|

<br>

![[스크린샷 2023-05-17 오후 4.07.47.png]]
+ 현재 배열
	||12|11|9|8|7|6|4|3|2|

MST인지 검사한다.
MST면 탈출한다.
13을 소거하면 간선이 없는 정점이 존재하는지 검사한다.
아니므로 13을 소거하고 다음으로 넘어간다.

<br>

![[스크린샷 2023-05-17 오후 4.07.55.png]]
+ 현재 배열
	|||11|9|8|7|6|4|3|2|

MST인지 검사한다.
MST면 탈출한다.
12을 소거하면 간선이 없는 정점이 존재하는지 검사한다.
아니므로 12을 소거하고 다음으로 넘어간다.

<br>

![[스크린샷 2023-05-17 오후 4.08.03.png]]
+ 현재 배열
	||||9|8|7|6|4|3|2|

MST인지 검사한다.
MST면 탈출한다.
11을 소거하면 간선이 없는 정점이 존재하는지 검사한다.
아니므로 11을 소거하고 다음으로 넘어간다.

<br>

![[스크린샷 2023-05-17 오후 4.08.16.png]]
+ 현재 배열
	|||||8|7|6|4|3|2|

MST인지 검사한다.
MST면 탈출한다.
9을 소거하면 간선이 없는 정점이 존재하는지 검사한다.
아니므로 9을 소거하고 다음으로 넘어간다.

<br>

![[스크린샷 2023-05-17 오후 4.08.25.png]]
+ 현재 배열
	|||||8||6|4|3|2|

MST인지 검사한다.
MST면 탈출한다.
8을 소거하면 간선이 없는 정점이 존재하는지 검사한다.
8을 소거하면 정점 A에는 정점이 존재하지 않으므로 소거하지 않고 넘어간다.

MST인지 검사한다.
MST면 탈출한다.
7을 소거하면 간선이 없는 정점이 존재하는지 검사한다.
아니므로 7을 소거하고 다음으로 넘어간다.

MST인지 검사한다.
MST이므로 탈출한다.

<br>

### 크루스칼 알고리즘의 구현을 위한 계획

내림차순을 소거하는 방식이 좀 더 구현이 간단하다.

그 이유는 정점끼리의 간선들이 사이클을 형성하는지 검증하는 것이 꽤 까다롭기 때문이다.

그리고 가중치가 추가된 정점 클래스가 필요하다.

그리고 DFS를 이용해 간선의 유무를 파악할 예정이다.


<br>

### 크루스칼 알고리즘을 담은 함수의 정의

<br>

### 크루스칼 알고리즘을 완성하는 함수들의 정의

<br>

### 예제

``` cpp
#ifndef FIRSTCPP_ALGRAPHKRUSKAL _H  
#define FIRSTCPP_ALGRAPHKRUSKAL _H  
  
#include <utility>  
  
#include "enthusiasm/linked_list/DLinkedList.h"  
#include "enthusiasm/priority_queue/PriorityQueue.h"  
#include "enthusiasm/stack/ListBaseStack.h"  
#include "enthusiasm/graph/ALEdge.h"  
  
using namespace Collection::Queue;  
  
namespace Collection{  
    namespace Graph{  
        enum class GraphVertexAlphabets : int{  
            A = 0,  
            B,  
            C,  
            D,  
            E,  
            F,  
            G,  
            H,  
            I,  
            J,  
            K  
        };  
        Priority weightCompare(const WeightedEdge& edge1, const WeightedEdge& edge2){  
            if(edge1.getWeight() > edge2.getWeight()){  
                return Priority::RIGHT_GT;  
            }else if(edge1.getWeight() < edge2.getWeight()){  
                return Priority::LEFT_GT;  
            }else{  
                return Priority::EQUAL;  
            }  
        }  
  
        class WeightedALGraph{  
        private:  
            int vertexNumber;  
            int edgeNumber;  
            DLinkedList<int> **adjacentList;  
  
  
        private:  
  
        public:  
            WeightedALGraph();  
            WeightedALGraph(const int& vertexNumber);  
            WeightedALGraph(const WeightedALGraph& ref);  
            WeightedALGraph(WeightedALGraph&& ref) noexcept;  
            WeightedALGraph& operator=(const WeightedALGraph& ref);  
            WeightedALGraph& operator=(WeightedALGraph&& ref) noexcept;  
            ~WeightedALGraph();  
  
            friend std::ostream &operator<<(std::ostream &output, const WeightedALGraph &ref);  
  
        public:  
            void removeEdge(const int& vertex1, const int& vertex2);  
            void removeWayEdge(const int& vertex1, const int& vertex2);  
            void recoverEdge(const int& vertex1, const int& vertex2, const int& weight);  
            void addEdge(const int &fromVertex, const int &toVertex, const int& weight);  
  
            DLinkedList<int> getAdjacentList(const int &vertex) const;  
            const int getVertexNumber() const;  
            const int getEdgeNumber() const;  
        };  
  
        WeightedALGraph::WeightedALGraph()  
        : vertexNumber(0)  
          , edgeNumber(0)  
          , adjacentList(nullptr){  
        }  
  
        WeightedALGraph::WeightedALGraph(const int& vertexNumber)  
        : vertexNumber(vertexNumber)  
        , edgeNumber(0)  
        , adjacentList(new DLinkedList<int> * [vertexNumber]){  
            for (int i = 0; i < vertexNumber; ++i) {  
                adjacentList[i] = new DLinkedList<int>();  
                adjacentList[i]->setSortRule(whichIsPrecede);  
            }  
        }  
  
        WeightedALGraph::WeightedALGraph(const WeightedALGraph& ref)  
        : vertexNumber(ref.vertexNumber)  
        , edgeNumber(0)  
        , adjacentList(new DLinkedList<int> * [vertexNumber]){  
            adjacentList = new DLinkedList<int> *[vertexNumber];  
            for (int i = 0; i < vertexNumber; ++i) {  
                adjacentList[i] = new DLinkedList<int>(*ref.adjacentList[i]);  
            }  
        }  
  
        WeightedALGraph::WeightedALGraph(WeightedALGraph&& ref) noexcept  
        : vertexNumber(ref.vertexNumber)  
        , edgeNumber(ref.edgeNumber)  
        , adjacentList(new DLinkedList<int> * [vertexNumber]){  
            ref.adjacentList = nullptr;  
        }  
  
        WeightedALGraph& WeightedALGraph::operator=(const WeightedALGraph& ref){  
            if(this != &ref){  
                for (int i = 0; i < vertexNumber; ++i) {  
                    delete adjacentList[i];  
                }  
                delete[] adjacentList;  
                vertexNumber = ref.vertexNumber;  
                edgeNumber = ref.edgeNumber;  
                adjacentList = new DLinkedList<int>*[vertexNumber];  
                for (int i = 0; i < vertexNumber; ++i) {  
                    adjacentList[i] = new DLinkedList<int>(*ref.adjacentList[i]);  
                }  
            }  
        }  
  
        WeightedALGraph& WeightedALGraph::operator=(WeightedALGraph&& ref) noexcept{  
            vertexNumber = ref.vertexNumber;  
            edgeNumber = ref.edgeNumber;  
            adjacentList = ref.adjacentList;  
            ref.adjacentList = nullptr;  
            return *this;  
        }  
  
        WeightedALGraph::~WeightedALGraph(){  
             for (int i = 0; i < vertexNumber; ++i) {  
                delete adjacentList[i];  
            }  
            delete[] adjacentList;  
        }  
  
        void WeightedALGraph::addEdge(const int &fromVertex, const int &toVertex, const int& weight) {  
            adjacentList[fromVertex]->insert(toVertex);  
            adjacentList[toVertex]->insert(fromVertex);  
            ++edgeNumber;  
        }  
  
        std::ostream &operator<<(std::ostream &output, const WeightedALGraph &ref) {  
            for (int i = 0; i < ref.vertexNumber; ++i) {  
                output << static_cast<char>(i + 65) << "와 연결된 정점: ";  
                for (ref.adjacentList[i]->first(); !ref.adjacentList[i]->isDone(); ref.adjacentList[i]->next()) {  
                    if (!ref.adjacentList[i]->current().isError()) {  
                        output << static_cast<char>(ref.adjacentList[i]->current().getData() + 65) << " ";  
                    }  
                }  
                output << std::endl;  
            }  
            return output;  
        }  
  
        void WeightedALGraph::removeEdge(const int &vertex1, const int &vertex2) {  
            removeWayEdge(vertex1, vertex2);  
            removeWayEdge(vertex2, vertex1);  
            --edgeNumber;  
        }  
  
        void WeightedALGraph::removeWayEdge(const int &vertex1, const int &vertex2) {  
            for (adjacentList[vertex1]->first(); !adjacentList[vertex1]->isDone(); adjacentList[vertex1]->next()) {  
                if(adjacentList[vertex1]->current().getData() == vertex2){  
                    adjacentList[vertex1]->remove();  
                    return;                }  
            }  
        }  
  
        void WeightedALGraph::recoverEdge(const int &vertex1, const int &vertex2, const int &weight) {  
            adjacentList[vertex1]->insert(vertex2);  
            adjacentList[vertex2]->insert(vertex1);  
            ++edgeNumber;  
        }  
  
        DLinkedList<int> WeightedALGraph::getAdjacentList(const int &vertex) const{  
            if(vertexNumber < vertex+1){  
                return DLinkedList<int>();  
            }  
            return *adjacentList[vertex];  
        }  
  
        const int WeightedALGraph::getVertexNumber() const {  
            return vertexNumber;  
        }  
  
        const int WeightedALGraph::getEdgeNumber() const {  
            return edgeNumber;  
        }  
  
        class ALGraphKruskal{  
        private:  
            WeightedALGraph *graph;  
            bool *visitInfoArray;  
            PriorityQueue<WeightedEdge> priorityQueue;  
            ListBaseStack<int> stack;  
  
        public:  
            ALGraphKruskal(WeightedALGraph* graph, const int& vertexNumber);  
            ALGraphKruskal(const ALGraphKruskal& ref);  
            ALGraphKruskal(ALGraphKruskal&& ref) noexcept;  
            ALGraphKruskal& operator=(const ALGraphKruskal& ref);  
            ALGraphKruskal& operator=(ALGraphKruskal&& ref) noexcept;  
            ~ALGraphKruskal();  
  
        public:  
            void showGraphDFSTraverse(const int& startVertex);  
            void showGraphWeightInfo() const;  
            bool isVertexConnected(const int& vertex1, const int& vertex2);  
            void addEdge(const int &fromVertex, const int &toVertex, const int& weight);  
  
  
            void changeToMSTByKruskal();  
        };  
  
        ALGraphKruskal::ALGraphKruskal(WeightedALGraph* graph, const int& vertexNumber)  
        : graph(graph)  
        , visitInfoArray(new bool[vertexNumber])  
        , stack(ListBaseStack<int>())  
        , priorityQueue((PriorityQueue<WeightedEdge>(weightCompare))){  
        }  
  
        ALGraphKruskal::ALGraphKruskal(const Collection::Graph::ALGraphKruskal &ref)  
        : graph(ref.graph)  
        , visitInfoArray(new bool[sizeof(ref.visitInfoArray) / sizeof(bool)])  
        , stack(ListBaseStack<int>())  
        , priorityQueue((PriorityQueue<WeightedEdge>(weightCompare))){  
  
        }  
  
        ALGraphKruskal::ALGraphKruskal(Collection::Graph::ALGraphKruskal &&ref) noexcept  
        : graph(ref.graph)  
        , visitInfoArray(new bool[sizeof(ref.visitInfoArray) / sizeof(bool)])  
        , stack(ListBaseStack<int>())  
        , priorityQueue((PriorityQueue<WeightedEdge>(weightCompare))){  
            std::swap(visitInfoArray, ref.visitInfoArray);  
            ref.visitInfoArray = nullptr;  
        }  
  
        ALGraphKruskal &ALGraphKruskal::operator=(const Collection::Graph::ALGraphKruskal &ref) {  
            if(this != &ref){  
                graph = ref.graph;  
                stack = ListBaseStack<int>();  
                priorityQueue = PriorityQueue<WeightedEdge>(weightCompare);  
  
                delete[] visitInfoArray;  
                visitInfoArray = new bool[sizeof(ref.visitInfoArray) / sizeof(bool)];  
                for (int i = 0; i < sizeof(ref.visitInfoArray) / sizeof(bool); ++i) {  
                    visitInfoArray[i] = ref.visitInfoArray[i];  
                }  
            }  
            return *this;  
        }  
  
        ALGraphKruskal &ALGraphKruskal::operator=(Collection::Graph::ALGraphKruskal &&ref) noexcept {  
            graph = ref.graph;  
            stack = ListBaseStack<int>();  
            priorityQueue = PriorityQueue<WeightedEdge>(weightCompare);  
            std::swap(visitInfoArray, ref.visitInfoArray);  
            ref.visitInfoArray = nullptr;  
            return *this;  
        }  
  
        ALGraphKruskal::~ALGraphKruskal() {  
            delete graph;  
            delete []visitInfoArray;  
        }  
  
        void ALGraphKruskal::showGraphDFSTraverse(const int& startVertex) {  
            DLinkedList<int> list = graph->getAdjacentList(startVertex); // 2, 4, 3  
  
            // 방문 처리  
            if(!visitInfoArray[startVertex]){  
                visitInfoArray[startVertex] = true;  
            }  
  
            for (list.first(); !list.isDone(); list.next()) {  
                // 방문 검사 후 통과시 현재 시작 정점 스택에 추가  
                if (!visitInfoArray[list.current().getData()]) {  
                    stack.push(startVertex);  
                    showGraphDFSTraverse(list.current().getData());  
                }  
            }  
  
            if(!stack.isEmpty()){  
                stack.pop();  
            }else{  
                for (int i = 0; i < sizeof(visitInfoArray) / sizeof(bool); ++i) {  
                    visitInfoArray[i] = false;  
                }  
            }  
        }  
  
        void ALGraphKruskal::showGraphWeightInfo() const {  
            PriorityQueue<WeightedEdge> tempQueue = priorityQueue;  
            WeightedEdge tempEdge;  
  
            while(!tempQueue.isEmpty()){  
                tempEdge = tempQueue.dequeue();  
               std::cout<<"("<<static_cast<char>(tempEdge.getVertex1()+65)<<"-"<<static_cast<char>(tempEdge.getVertex2()+65)<<"), weight: "<<tempEdge.getWeight()<<std::endl;  
            }  
        }  
  
        bool ALGraphKruskal::isVertexConnected(const int &vertex1, const int &vertex2) {  
  
  
            DLinkedList<int> list = graph->getAdjacentList(vertex1); // 2, 4, 3  
  
            // 방문 처리  
            if(!visitInfoArray[vertex1]){  
                visitInfoArray[vertex1] = true;  
            }  
  
            // 타겟에 도달 가능한지 검사  
            for (list.first(); !list.isDone(); list.next()) {  
                if(list.current().getData() == vertex2){  
                    for (int i = 0; i < sizeof(visitInfoArray) / sizeof(bool); ++i) {  
                        visitInfoArray[i] = false;  
                    }  
                    return true;  
                }  
            }  
  
            for (list.first(); !list.isDone(); list.next()) {  
                // 방문 검사 후 통과시 현재 시작 정점 스택에 추가  
                if (!visitInfoArray[list.current().getData()]) {  
                    stack.push(vertex1);  
                    return isVertexConnected(list.current().getData(), vertex2);  
                }  
            }  
  
            if(!stack.isEmpty()){  
                stack.pop();  
            }else{  
                for (int i = 0; i < sizeof(visitInfoArray) / sizeof(bool); ++i) {  
                    visitInfoArray[i] = false;  
                }  
            }  
            return false;  
        }  
  
        void _dfsTraverse(const int &startVertex, const int &target, bool* isFound){  
            *isFound = true;  
        }  
  
        void ALGraphKruskal::changeToMSTByKruskal() {  
            WeightedEdge reserveEdge[20];  
            WeightedEdge tempEdge;  
            int edgeIndex = 0;  
  
            for (int i = 0; graph->getEdgeNumber() + 1 > graph->getVertexNumber(); ++i) {  
                tempEdge = priorityQueue.dequeue();  
                graph->removeEdge(tempEdge.getVertex1(), tempEdge.getVertex2());  
  
                if(!isVertexConnected(tempEdge.getVertex1(), tempEdge.getVertex2())){  
                    graph->recoverEdge(tempEdge.getVertex1(), tempEdge.getVertex2(), tempEdge.getWeight());  
                    reserveEdge[edgeIndex++] = tempEdge;  
                }  
            }  
  
            for (int i = 0; i < edgeIndex; ++i) {  
                priorityQueue.enqueue(reserveEdge[i]);  
            }  
        }  
  
        void ALGraphKruskal::addEdge(const int &fromVertex, const int &toVertex, const int &weight) {  
            graph->addEdge(fromVertex, toVertex, weight);  
            priorityQueue.enqueue(WeightedEdge(fromVertex, toVertex, weight));  
        }  
  
  
    }  
}  
  
#endif // FIRSTCPP_ALGRAPHKRUSKAL _H

#include "enthusiasm/graph/ALGraphKruskal.h"  
using namespace Collection::Graph;  
using Vertex = GraphVertexAlphabets;  
  
int vertexToIntegerCast(const Vertex& vertex){  
    return static_cast<int>(vertex);  
}  
int main(){  
    WeightedALGraph *graph = new WeightedALGraph(6);  
    ALGraphKruskal graphKruskal = ALGraphKruskal(graph, 6);  
  
    graphKruskal.addEdge(vertexToIntegerCast(Vertex::A), vertexToIntegerCast(Vertex::B), 9);  
    graphKruskal.addEdge(vertexToIntegerCast(Vertex::B), vertexToIntegerCast(Vertex::C), 2);  
    graphKruskal.addEdge(vertexToIntegerCast(Vertex::A), vertexToIntegerCast(Vertex::C), 12);  
    graphKruskal.addEdge(vertexToIntegerCast(Vertex::A), vertexToIntegerCast(Vertex::D), 8);  
    graphKruskal.addEdge(vertexToIntegerCast(Vertex::D), vertexToIntegerCast(Vertex::C), 6);  
    graphKruskal.addEdge(vertexToIntegerCast(Vertex::A), vertexToIntegerCast(Vertex::F), 11);  
    graphKruskal.addEdge(vertexToIntegerCast(Vertex::F), vertexToIntegerCast(Vertex::D), 4);  
    graphKruskal.addEdge(vertexToIntegerCast(Vertex::D), vertexToIntegerCast(Vertex::E), 3);  
    graphKruskal.addEdge(vertexToIntegerCast(Vertex::E), vertexToIntegerCast(Vertex::C), 7);  
    graphKruskal.addEdge(vertexToIntegerCast(Vertex::F), vertexToIntegerCast(Vertex::E), 13);  
  
    graphKruskal.changeToMSTByKruskal();  
    std::cout<<*graph<<std::endl;  
    graphKruskal.showGraphWeightInfo();  
    return 0;  
}
```

+ 설명
	기존 자료구조와는 달리 stack, priority_queue 두 가지를 더해 구현한 자료구조이다.
	
	stack은 DFS 순회시 사용하며 priority_queue는 오름차순 또는 내림차순으로 정렬하여 간선을 추가 또는 제거하여 딱 원하는 mst 간선만 남겨놓기 위함이다.
	
	이 changeToMSTByKruskal()를 사용하면 지금 그래프에서 MST를 구현한다.
	
	MST를 구성하기 위한 필요없는 간선은 전부 제거하는 작업을 수행한다. 
	
	이때 필요한 것은 추가 제거 가능 간선 유무를 파악하기 위한 DFS 순회를 하는데 이때를 위해 stack이 필요하다.
	
	참고로, 이번 구현를 하며 단순 연결리스트, 노드 제거 기능을 추가한 UsefulHeap 자료구조에 각각 버그가 있는 것을 발견하였다.
	
	수정한 버전은 귀찮아서 나중에 study 버전만 따로 올려둔 깃헙 링크를 통해 공개해보겠다.
