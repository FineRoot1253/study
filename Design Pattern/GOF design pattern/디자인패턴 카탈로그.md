# 디자인패턴 카탈로그

### 생성(Creational Patterns)

구체 클래스에서 인스턴스를 생성 → 인터페이스 관점으로 작성

- 클래스
    - 인스턴스로 만들 클래스를 다양하게 만들기 위한 용도로 상속을 사용
- 객체
    - 인스턴스화 작업을 다른 객체로 떠넘길 수도 있다
- Abstract Factory - Kit

    다른 객체를 생성하는 책임만 있는 객체를 만들어낸다.

    - 의도
        - 상세화된 서브클래스를 정의하지 않고도 서로 관련이 있고 독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공한다.
    - 사용 시기
        - 객체 생성시
        - 구성 + 표현되는 방식과 무관하게 시스템을 독립적으로 만들고자 할때
        - 여러 제품군 중 하나를 선택해서 시스템을 설정해야하고 한번 구성한 제품을 다른 것으로 대체할 수 있을 때
        - 관련된 제품 객체들이 함께 사용되도록 설계되었고, 이 부분에 대한 제약이 외부에도 지켜지도록 하고 싶을 때
        - 제품에 대한 클래스 라이브러리를 제공하고, 그들의 구현이 아닌 인터페이스를 노출시키고 싶을 때
    - 구성

        [[Gof_Design_Patterns-2.jpg]]

        - AbstractFactory(WidgetFactory)
            - 객체를 생성하는 인터페이스를 정의
        - ConcreteFactory(MotifWidgetFactory, PMWidgetFactory)
            - 구체적인 제품에 대한 객체를 생성하는 연산을 구현
        - AbstractProduct(Window, ScrollBar)
            - 개념적 제품 객체에 대한 인터페이스를 정의
        - ConcreteProduct(MotifWindow, MotifScrollBar)
            - 구체적으로 팩토리가 생성할 객체를 정의하며 AbstractProduct가 정의하는 인터페이스를 구현
        - Client
            - AbstractFactory와 AbstractProduct 클래스에 선언된 인터페이스를 사용
    - 시나리오
        1. ConcreteFactory 클래스의 인스턴스 한개를 런타임에 생성
            1. 이 국체 팩토리는 어떤 특정 구현을 갖는 제품 객체를 생성
            2. 서로 다른 제품 객체 생성시 사용자는 서로 다른 구체 팩토리를 사용해야 함
        2. AbstractFactory는 필요한 제품 객체를 생성하는 책임을 구체 팩토리 서브 클래스에 위임한다.
    - 구현 절차
        1. 팩토리를 단일체로 정의

            어떤 제품을 생성할 것인지는 하나면 된다.

        2. 제품을 생성

            AbstractFactory는 인터페이스만 선언하는 책임을 지녔고

            생성을 하는 책임은 ConcreteProduct가 지니고 있다.

            AbstractFactory는 각 제품 생성을 위한 팩토리 메서드를 재정의 해 각 제품의 인스턴스를 만든다.

            **제품군이 약간 다르다면 각 제품군을 위한 새로운 구체 팩토리 서브클래스가 필요**하다.

            많은 제품군들은,  특히 **구체 팩토리는 프로토타입 패턴**으로 구현 가능

            1) 구체 팩토리가 한 군내의 각 제품 원행 인스턴스로 초기화

            2) 원형의 복사를 통해 인스턴스 생성

            이렇게 하면 새 제품군을 만들때 새 구체 펙토리를 만들 필요가 없다

            단 **1급 객체로 클래스를 다루는 언어**에서만 사용이 가능하다.

        3. 확장 가능한 팩토리들을 정의

            추상클래스에는 서로 다른 연산을 정의

            새 제품 추가시 새 연산도 추가해준다.

            만약 너무 많아진다면 **생성할 객체를 매개변수로 넘겨버려서 한 연산으로 처리**해버려도된다.다만, 동적 타입 기준에서 적용이 쉽다. 정적 타입 언어에서는 강제로 타입을 변환해주어야한다.


- Builder

    다른 객체를 생성하는 책임만 있는 객체를 만들어낸다.

    - 의도
        - 복잡한 객체를 **생성하는 방법**과 **표현하는 방법**을 정의하는 클래스를 별도로 분리하여 서로 다른 표현이라도 이를 생성 할 수 있는 동일한 절차를 제공한다.
    - 동기및 사용 시기
        - 한 클래스가 다른 클래스의 기능도 함께 사용할 필요가 있을 때
        - 복합 객체의 생성 알고리즘이 이를 합성하는 요소 객체들이 무엇인지 이들의 조립 방법에 독립적일 때
        - 합성할 객체들의 표현(인터페이스)이 서로 다르더라도 생성 절차에서 이를 지원해야 할 때
    - 구성

        [[Gof_Design_Patterns-3.jpg]]

        - Builder(TextConverter)
            - 객체의 일부 요소들을 생성하기 위한 추상 인터페이스를 정의
        - ConcreteBuilder(ASCIIConverter, TeXConverter, TextWidgetConverter):
            - Builder 클래스에 정의된 인터페이스를 구현하며 제품의 부품들을 모아 빌더를 복합한다.
            - 생성한 요소의 표현을 정의하고 관리한다.
            - 제품을 검색하는데 필요한 인터페이스 제공한다.
        - Director(RTFReader)
            - 인터페이스를 사용하는 객체를 합성한다.
        - Product(ASCIIText, TexText, TextWidget)
            - 생성할 복합 객체를 표현한다.
            - ConcreteBuilder는 제품의 내표 표현을 구축하고 복합 객체가 어떻게 구성되는지에 관한 절차를 정의한다.
    - 시나리오
        1. 사용자는 **Director 객체를 생성**하고 **생성한 객체를 자신이 원하는 Builder 객체로 합성**한다.
        2. 제품의 일부가 구축 될 때마다 Director는  Builder에 통보한다.
        3. Builder는 Director의 요청을 처리하여 제품에 부품을 추가한다.
        4. 사용자는 Builder에서 제품을 검색한다.
    - 구현 절차
        - 조합과 구축에 필요한 인터페이스를 정의

            빌더는 단계 별로 제품들을 생성한다. 모든 종류의 제품을 생성하는 데 필요한 일반화된 연산들을 정의한다.

            - 구축해 달라고 하는 요청이 오면 요소를 제품에 단순하게 추가하는 식으로 모델을 구축한다.
            - 파스트리와 같은 트리구조는 자식노드를 모아 부모노드를 만드는데 빌더는 디렉터에게 자식노드를 반환하고 다른빌더에 이들 자식 노드를 반환해서 부모노드들을 복합한다.(트리구조를 상향식으로 구성하는 그림, 이미 구축된 빌더의 제품에 접근이 필요한 경우를 서술한 것)
        - 제품에 대한 추상 클래스는 필요 없다. 디렉터에 적절한 빌더의 서브클래스를 제공하자.
        - 빌더(Builder, 상위 클래스)에 있는 메서드에 대해 구현을 제공하지 않는게 일반적이다.  하위 클래스에서 필요한 메서드만 오버라이드로 구현해주자.
- Factory Method - Virtual Constructor(가상생성자)
    - 의도

        객체를 생성하기 위해 인터페이스를 정의 하지만 어떤 클래스의 인스턴스를 생성할 지에 대한 결정은 서브클래스가 내리도록 한다.

    - 동기및 사용 시기
        - 어떤 클래스가 자신이 생성해야하는 객체의 클래스를 예측 할수 없을 때
        - 생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때
        - 객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고 , 어떤 서브클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때
    - 구성

        [[Gof_Design_Patterns-5.jpg]]

        - Product(Document)

            팩토리 메서드가 생성하는 객체의 인터페이스를 정의한다.

        - ConcreteProduct(MyDocument)

            Product 클래스에 정의된 인터페이스를 실제로 구현한다.

        - Creator(Application)

            Product 타입의 객체를 반환하는 팩토리 메서드를 선언한다.

            이때, ConcreteProduct 객체를 반환하며 Product 객체의 생성을 위해 팩토리메서드를 호출한다.

        - ConcreteCreator(MyApplication)

            팩토리 메서드를 재정의 하여 ConcreteProduct의 인스턴스를 반환한다.

    - 결과
        - 서브클래스에 대한 훅 메서드 제공
            - 팩토리 메서드로 클래스 내부서 객체를 생성하는 것이 객체를 직접 생성하는 것보다 응용성이 높다.(훅메서드는 하위 클래스에서 선택적으로 오버라이드 하여 재정의 하기위한 비어있는 메서드등을 의미한다.)
        - 병렬적인 클래스 계통을 연결하는 역할을 담당한다.
    - 구현 방식
        - 기본 구현 방식
            - Creator 클래스를 추상 클래스로 정의하고 정의한 팩토리 메서드에 대한 구현은 제공하지 않는 경우
                1. 구현을 제공한 서브클래스를 반드시 정의해야한다.

                    해당 서브 클래스의 설계자는 부모 클래스가 인스턴스를 만드는 객체의 클래스를 변경 할수도 있어 주의해야한다.

            - Creator 클래스를 구체 클래스로 정의하고 팩토리 메서드에 대한 구현도 제공하는 경우
                1. Creator가 팩토리 메서드를 사용해 유연성을 보장한다.
        - 팩토리 메서드를 매개변수화하는 방식.
            - 구현할 클래스의 식별자를 매개변수로 넘겨주는 방식(주로 내가 쓰던 방식)
            - 동적 타입 언어에서는 런타입에서 그냥 지정을 해주면 되지만 정적 타입 언어에서는 먼저 임의 타입으로 초기화를 해준 뒤 지정해줘야 한다.(Lazy Initialization이라고 한다.)

                <aside>
                ⚠️ 언어마다 구현방식이 다 다르다. 자바스크립트는 추상 팩토리는 불가능하며(비슷하게는 되지만) 팩토리 메서드만 가능하고 팩토리 키워드가 따로있는 다트나 따로 없이 알아서 내부 클래스로 처리가 가능한 자바등등 다 다르다. 즉, 직접 구현해 보는 것이 좋다.(전부 해보는 것이 좋긴 하다...)

                </aside>

                이에, 템플릿을 활용 해 볼수가 있다. 맨 첫 구현 방식은 하나 추가할때마다 서브클래싱을 해주어야하는 단점을 해결해 볼수 있다. (자바에서는 제네릭이다 앞에서 서술 했지만 언어마다 여러가지가 다르다) 생성자 클래스를 상속 받으며 팩토리 메서드를 구현하는 클래스를 제네릭으로 제한하며 정의를 한다. 말이 어려운데 다시 말하면 생성을 하는 Creator클래스를 생성 타겟 클래스인 Product클래스로 타입을 제한하면 Product의 하위 클래스로 서브클래싱을 생성 클래스도 해줄 필요가 없다는 뜻이다.

                > [https://copynull.tistory.com/129](https://copynull.tistory.com/129)
                >
- Prototype
    - 의도

        원형이 되는 인스턴스를 사용해 생성할 객체의 종류를 명시, 이 인스턴스를 샘플로써 계속 복사하여 사용한다.(자바 스크립트가 이런 방식을 사랑한다 1급 객체의 언어는 죄다 이방식이다.)

    - 동기 및 사용 시기
        - 인스턴스화할 클래스를 런타임에 지정할 때 (동적 로딩)
        - 제품 클래스 계통과 병렬적으로 만드는 팩토리 클래스를 피하고 싶을 때
        - 클래스의 인스턴스들이 서로 다른 상태 조합 중에 어느 하나일 때
        - 주로 자주 인스턴스화를 해 메모리를 자주 잡아먹는 녀석이나 DB조회에 데이터 클래스를 담당하는 클래스에 원형 패턴을 적용해주면 좋다.(특히 쿼리가 복잡하다거나 할때... 별 의미 없는 연산일 경우 써주자)
    - 구성

        [[Gof_Design_Patterns-4.jpg]]

        - Prototype(Graphic)
            - 자신을 복제하는 데 필요한 인터페이스를 정의한다.
        - ConcretePrototype(Staff, WholeNote, HalfNote)
            - 자신을 복제하는 연산을 구현한다.
        - Client(GraphicTool)
            - 원형에 자기 사진의 복제를 요청하여 새로운 객체를 생성한다.
    - 결과
        - 런타임에 직접 새로운 제품 추가, 삭제 가능
        - 값들을 다양화하여 새로운 객체 명세 가능
        - 구조를 다양화함으로써 새로운 객체 명세 가능
        - 서브클래스의 수를 축소
            - 그러나 동적 타입언어에서는 그다지 혜택을 보기 힘들다. 이미 클래스 객체는 원형의 역할을 하기 때문이다.
        - 동적으로 클래스에 따라 응용프로그램을 설정할 수 있음

        <aside>
        ⚠️ Clone() 연산 구현시 환형 참조가 없는 객체를 포함하거나 복사를 지원을 하지 않을 수도 있기 때문에 이럴 경우에는 주의해야한다.

        </aside>

    - 구현 절차
        1. 프로토타입 관리자를 사용한다.
            1. 프로토타입의 수가 아직 정해지지 않았을 땐 가능한 프로토타입이 등록된 레지스트리를 관리한다.
            2. 사용자는 프로토타입을 다루지 않고 단지 레지스트리에서 프로토타입을 검색하고 그것을 레지스트리에 저장한다. 다만 사용자는 프로토타입을 복제하기 전 레지스트리에 프로토타입이 있는지 조회한다. 이 레지스트리를 프로토타입 매니저라고 부른다.
        2. Clone()연산을 구현한다.
            1. 보통 대다수의 언어는 Clone 메서드를 지원해준다.  implement로 오버라이드를 하던 해서 사용을 하지만 문제는 대다수의 언어는 깊은 복사까진 지원을 해주지 않는다.
            2. 예를 들면  c++의 복사 생성자는 포인터 변수는 그냥 그대로 주소값을 들고온다. 이러면 원본과 사본이 같아져버린다.(문제발생!)
            3. 이를 방지하기 위해 복잡한 구조인 프로토타입은 대개 깊은 복사를 필요로한다. 사본과 원본은 언제나 독립적이여야 하기 때문이다.
            4. 복잡한 객체구조에서는 클론을 할때 한번 더 클론을 해버리자!
- Singleton
    - 의도

        오직 한 개의 클래스 인스턴스만을 갖도록 보장하고, 이에 대한 전역적인 접근점을 제공한다.

    - 동기및 사용 시기
        - 클래스의 인스턴스가 오직 하나여야 함을 보장하고, 잘 정의된 접근점으로 모든 사용자가 접근 할 수 있도록 해야 할 때
        - 유일한 인스턴스가 서브클래싱으로 확장되어야 하며, 사용자는 코드의 수정없이 서브 클래스의 인스턴스를 사용 할 수 있어야 할 때
        - 주로 api 클래스나 단일 i/o를 담당하거나 서비스에 계속 살아서 통신을 해야하는 인스턴스를 이렇게 사용한다.
    - 구성

        [[Gof_Design_Patterns-6.jpg]]

        - Singleton
            - Instance() 연산 정의 및 유일한 인스턴스로 접근할 수 있도록 만들어준다. (스태틱으로 만들어준다.)
    - 결과
        - 유일하게 존재하는 인스턴스로의 접근을 통제합니다. 언제 어디서 쓰일지 제어할 수 있습니다.
        - 전역변수 보다 좋습니다.
        - 연산 및 표현의 정제를 허용합니다. 서브클래싱을 통해 새 인스턴스를 만들수 있습니다.
        - 인스턴스의 개수를 변경하기가 자유롭습니다.
    - 구현
        - 인스턴스가 유일해야 함을 보장합니다.
        - Singleton클래스를 서브클래싱합니다.
            - 유연하게 싱글톤 서브클레스를 늘려가는 방법은 해당 레지스트리의 레지스트리를 필드로 추가하고 Register 연산과 name을 파라미터로 추가하고  Lookup(name)메서드를 추가한다.(특정 인스턴스 탐색)

### 구조(Structural Patterns)

- 구조 클래스 패턴(클래스 추출하기)
    - 다중 상속으로 둘 이상의 중복된 문맥을 하나로 만든다
    - 한 인터페이스가 다른 인터페이스를 따르게 만들어 서로 다른 인터페이스들의 공통된 추상을 만든다
- 구조 객체 패턴
    - 객체를 합성하는 방법을 제공한다
- Adapter - Wrapper(래퍼)
    - 의도

        클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 적응(변환)시킨다.

        서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작시킨다.

    - 동기 및 사용시기
        - 기존 사용하던 클래스의 인터페이스가 적용하지 알맞지 않고 다른 클래스의 인터페이스가 더 나을 때(규합이 필요한 경우)
            - 기존 인터페이스와 다른 클래스를 모두 상속받아 서브클래스 만들기(클래스 버전)
            - 더 낫다는 클래스의 인스턴스를 서브클래스에 포함시키고 해당 인스턴스의 인터페이스를 통해 구현 하기 (객체 버전)
        - 이미 만든 클래스를 재사용하고자 하나 수정이 불가한 상황일 경우
        - [객체 적응자만 해당] 이미 존재하는 여러개의 서브클래스를 사용해야하는데 이 서브클래스들의 상속을 통해서 이들의 인터페이스를 다 개조하는 것이 현실성이 없을 때, 즉 객체 적응자를 부모 클래스에 포함 시켜 부모 클래스의 인터페이스를 개조하는 것이 더 좋은 상황인 경우
    - 구성
        - Target(Shape)
            - 사용자가 사용할 응용 분야에 종속적인 인터페이스를 정의하는 클래스
        - Client(DrawingEditor)
            - Target 인터페이스를 만족하는 객체
        - Adaptee(TextView)
            - 인터페이스의 적응이 필요한 기존 인터페이스를 정의하는 클래스 적응 대상자로 부른다
        - Adapter(TextShape)
            - Target 인터페이스에 Adaptee 인터페이스를 적응 시키는 클래스
    - 시나리오
        1. 사용자는 적응자에 해당하는 클래스의 인스턴스에게 연산을 호출한다
        2. 적응자는 해당 요청을 수행하기 위해 적응 대상자의 연산을 호출한다
    - 장단점
        - 클래스 적응자
            - 하나의 클래스와 이 클래스의 모든 서브클래스를 개조하는 것은 불가능하다
            - Adapter는 Adaptee 클래스를 상속 받는 구조이기 때문에 Adaptee 클래스에 정의된 행동들을 재정의 가능하다.
            - 한 개의 Adapter만 사용가능하나 포인터 재간섭을 배제 할 수 있다.
        - 객체 적응자
            -
- Bridge
- Composite

    분석 모델과 물리적 대응 관계를 갖지 않지만 객체를 동일하게 다루게 해 주는 새로운 추상적 개념

    component 클래스

    공통의 인터페이스를 정의

    composite 클래스

    공통의 구현을 정의

- Decorator

    장식되는 객체와 동일한 인터페이스를 갖도록 장식자 객체의 인터페이스를 요청

- Facade

    서브시스템을 어떻게 객체로 표현할 수 있는지 설명

- Flyweight

    규모는 작지만 개수는 많은 객체를 다루는 방법을 설명

- Proxy

    중재되는 객체와 동일한 인터페이스를 갖도록 프록시 객체의 인터페이스를 요청

    → 프록시 객체의 인터페이스는 자신이 대리하는 다른 객체의 인터페이스와 동일하다


### 행동(Behavioral Patterns)

- Chain of Respnsibility

    이 객체들은 반드시 서로 동일한 타입을 가져야하지만, 구현을 공유할 부분은 없다.

- Command

    요청을 자신이 아닌 다른 객체나 객체 집합이 요청을 처리하여 구현하도록 책임지는 객체를 만든다.

    추상클래스 사용

- Visitor

    위임 일부 사용

    요청을 자신이 아닌 다른 객체나 객체 집합이 요청을 처리하여 구현하도록 책임지는 객체를 만든다.

    방문자 인터페이스는 방문자 객체가 방문하는 객체들의 클래스 인터페이스를 그 방문자 인터페이스에 모두 반영하도록 한다.

- Interpreter
- Iterator
- Meditaor

    위임 전적으로 사용

- Memento

    객체의 내부 상태를 어떻게 저장하고 캡슐화해야 하는지를 정의함

    → 나중에 그 상태로 복구할 수 있는 방법을 알려준다.

    내부 구조 : 2개의 인터페이스

    1. 사용자가 상태를 저장하고 복사할 수 있게 해주는 인터페이스
    2. 원본 객체가 그 메멘토에서 상태를 저장하고 검색하기 위해 사용하는 인터페이스
- Observer

    추상클래스 사용

- State

    대상들의 각 상태를 객체로 표현

    추상클래스 사용

    위임 일부 사용

- Strategy

    상호교환이 가능한 알고리즘군을 어떻게 구현할지를 설명

    추상클래스 사용

    위임 일부 사용

- Template Method
