# GOF design pattern

## 디자인패턴 카탈로그

[[디자인패턴 카탈로그]]

- 초심을 잃은 기분이 들때

    ## 패턴의 공통점

    <aside>
    💡 ***"디자인 패턴은 특정한 전후 관계에서 일반적 설계 문제를 해결하기 위해 상호 교류하는 수정 가능한 객체와 클래스들에 대한 설명"***

    </aside>

    - **패턴의 이름**

        설계의 의도 표현 방식

    - **문제**

        언제 사용되는지 서술

    - **해법**

        사용방법

    - **결과**

        얻는 결과와 장단점


    ## 패턴 기술 방법

    - **패턴의 이름과 분류**

        좋은 이름은 패턴의 생명, 패턴 구성 방식(링크)

    - **의도**

        무엇을 하는 패턴인지, 의도와 논리적인 근거, 어느 문제나 이슈를 해결하기 위함인지

    - **다른 이름(별칭)**

        다른 이름이 있으면 적기

    - **동기**

        패턴 안에서 클래스나 객체 구조가 어떻게 문제를 해결해 주는지 알려주는 일종의 시나리오, 왜 사용하는 지 등등

    - **활용성**

        어떤 상황에 적용 가능 한지, 잘못된 설계의 예는 무엇인지, 어떻게 이 상황을 파악하는지

    - **구조**

        객체 모델링 기법에 기반을 둔 표기법을 이용, 시각적으로 표현 할 것, 객체간 요청과 협력 관계의 순차 표현을 위해 상호작용 다이어그램도 사용,

    - **참여자**

        패턴을 구성하고 책임을 수행하는 클래스나 객체들을 설명

    - **협력방법**

        참여자들이 작업을 수행하기 위한 참여자들 간의 협력 관계를 정의

    - **결과**

        이 패턴이 내 목표에 얼마나 도움이 될지, 결과는 무엇이고 장단점은 무엇인지, 시스템 구조의 어떤 파트를 독립적으로 다양화 할수 있을지

    - **구현**

        구현시 주의 사항, 힌트, 기법등, 혹은 특정 언어에 대한 특이 사항

    - **예제 코드**

        주어진 패턴을 실제로 코드로 어떻게 구현하는지

    - **잘 알려진 사용예**

        실제 시스템에서 적용된 사용 예시,

    - **관련 패턴**

        밀접하게 관련된 다른 패턴들


    ## 카탈로그 조직화

    ### 분류의 기준

    - **목적**

        생성

        객체를 생성하는 책임의 일부를 서브클래스가 담당(클래스)

        객체를 생성하는 책임의 일부를 다른 객체에 위임(객체)

        구조

        상속을 이용해 클래스를 복합(클래스)

        객체를 합성하는 방법을 정의(객체)

        행동

        상속을 이용해 알고리즘과 제어 흐름을 기술(클래스)

        하나의 작업을 수행하기 위해 객체 집합이 어떻게 협력하는지 기술(객체)

    - **범위**

        클래스(컴파일 타임)

        클래스와 서브클래스 간의 관련성을 다룬다.(상속)

        객체(런타임)

        객체간 관련성을 다루는 패턴(객체 합성,  제네릭)

    - 패턴을 조직하는 또 다른 방법


        함께 사용해야 하는 패턴들

        복합체 패턴

        반복자 패턴 + 방문자 패턴

        상호 간 대안이 되는 패턴들

        원형 패턴

        ↔ 장식자 패턴

        결과적으로 유사한 설계 구조를 가지는 패턴들

        복합체 패턴

        & 장식자 패턴


    ## 디자인 패턴을 이용해 문제를 해결하는 방법

    - **디자인패턴의 특성**
        - 정의해야할 중요 요소  + 어떤 종류의 데이터를 주고 받아야하는지 식별하도록 인터페이스 정의를 도와준다.
        - 인터페이스에 넣지 말아야 할 것을 알려준다.
        - 인터페이스간 관련성도 정의 해준다.
            - 클래스 간에 유사한 인터페이스를 정의
            - 클래스의 인터페이스에 여러 가지 제약을 정의

    ### 적당한 객체 찾기

    객체 =  여러 개의 프로시저,

    프로시저 =  메서드, 연산

    객체는 요청이나 메시지를 받으면 연산을 수행,

    연산은 객체의 내부 데이터 상태를 변경하는 유일한 방법

    접근이 제한된 상태로 만드는 것 = 캡슐화

    객체 외부에서 객체 내부 데이터 직접 접근 불가능

    내부의 데이터 표현 방법(데이터 타입 등)을 알 수 없음

    객체 지향 설계의 가장 어려운 점

    시스템을 구성할 객체의 분할을 결정하는 것

    객체 분할 요인

    캡슐화

    크기 정하기

    종속성

    유연성

    성능

    진화(발전 가능성)

    재사용성

    문제 접근 방법

    1. 문제 기술서 작성 후 명사와 동사 추출, 각각을 클래스와 연산으로 만드는 방법
    2. 시스템의 협력 관계나 책임성을 중심으로 설계하는 방법
    3. 실세계를 모델로 만들고 이를 분석해 설계로 전이 하는 과정에서 객체로 바꾸는 방법

    분석 모델의 객체는 실세계 객체들이지만, 설계 모델의 객체에는 배열, 리스트처럼 구현에 가까운 클래스들도 있다

    **실세계를 그대로 반영하는 모델링을 강조하게 되면 현재의 실세계를 반영할 뿐, 미래의 실세계를 반영하는 것은 아니다**.

    ### 객체의 크기 결정

    이 결정은 디자인 패턴 카탈로그에서 찾아 보자

    ### 객체 인터페이스의 명세

    **시그니처**

    객체가 선언한 모든 연산(메서드)들이 나타내는(명세하는) 이름, 반환 값, 파리미터

    **인터페이스**

    객체가 정의하는 연산의 모든 시그니처들

    객체지향 시스템에서 가장 기본이 되는 개념

    개념 1)

    외부에서 객체를 알 수 있는 유일한 방법, 이를 통해서만 요청 처리를 한다.

    개념 2)

    객체의 인터페이스는 구현에 대해 절때 공개하지 않는다.

    **특정 객체의 인터페이스**

    객체가 받아서 처리할 수 있는 연산의 집합

    만약 여기에 정의된 시그니처와 일치하는 어떤 요청이 객체에 전달되면, 객체는 연산을 수행해 해당 요청을 처리한다.

    **타입**

    특정 인터페이스를 나타낼 때 사용하는 이름

    만약 특정 객체가 'Window'라는 타입을 가진다면, 'Window'라는 인터페이스에 정의된 연산 모두를 처리 할 수 있다는 것을 의미한다.

    객체는 여러 타입을 가질 수 있고, 서로 다른 객체가 하나의 타입을 공유할 수도 있다.

    객체의 인터페이스에 정의된 연산들 중 일부는 A타입이 정의하는 연산이고, 다른 일부는 B타입이 정의한 연산일 수 도 있다. 같은 타입의 두 객체는 인터페이스의 일부를 공유해야한다.

    **서브타입**

    인터페이스가 다른 인터페이스를 부분집합으로 포함하는 경우, 다른 인터페이스를 포함하는 인터페이스

    **슈퍼타입**

    인터페이스가 다른 인터페이스를 부분집합으로 포함하는 경우, 다른 인터페이스에 포함되는 인터페이스

    **상속**

    서브타입과 슈퍼타입의 관계

    **동적 바인딩**

    어떤 **요청**과 **그 요청을 처리할 객체**를 프로그램 **실행중인 런타임에 연결** 짓는 것

    동일한 요청이라도 처리하는 객체들이 다른 객체라면, 이 요청에 대한 구현에 따라 다른 결과가 나올 수도 있다.

    요청이 어떻게 구현되어 어떤 결과를 만들어 낼지 **런타임에 결정할 수 있음**을 의미

    **다형성**

    프로그램이 기대하는 객체를 동일한 인터페이스를 갖는 다른 객체로 대체 수 있게 해주는 성질

    객체지향 시스템의 핵심 개념

    개념 1)

    사용자의 정의를 단순화

    개념 2)

    객체 간의 결합도 제거

    개념 3)

    런타임중 상호 간의 관련성을 다양화

    사용자는 어떤 **특정 인터페이스를 제공하는 객체에게 요청을 보낸 것**으로 프로그래밍 하지만, 런타임에 그 객체를 **동일한 인터페이스를 제공**하는 다른 객체로 대체 가능하다.

    → **런타임에 대체한 객체와 새로운 관련성이 수립**

    ### 객체 구현 명세

    - **클래스**

        어떤 객체의 구현 위치, 클래스에서 정의 된다.

        객체 내부 데이터와 표현 방법을 명세 & 수행할 연산을 정의.

    - **객체**

        **클래스의 인스턴스**, 클래스를 인스턴스로 만듦으로써 생성



        클래스의 인스턴스화 과정

        1. 객체의 내부 데이터[인스턴스 변수]에 대한 공간을 할당
        2. 데이터들을 연산과 연결
    - **상속**

        서브클래스가 부모클래스를 상속하면 부모 클래스가 갖는 모든 데이터와 연산을 서브클래스가 갖게됨

        서브클래스의 인스턴스

        부모 클래스가 정의한 모든 데이터를 가진다.

        부모 클래스가 정의한 연산을 모두 수행 할 수 있다.

    - **추상 클래스**

        모든 서브 클래스 사이의 공통되는 인터페이스를 정의

        **인스턴스 생성 불가**

        추상연산

        정의만 하고 구현은 하지 않는 연산, 명세시 기타사항등을 언급하고 싶다면 쪽지 모양박스에 적는다.

        구체 클래스

        추상 클래스가 아닌 다른 클래스들

    - **믹스인 클래스**

        다른 클래스들에게 선택적인 인터페이스 혹은 기능을 제공하려는 목적을 가진 클래스

        **다중 상속 필요**

        **인스턴스 생성 불가**

        추상연산만 가능

    - **클래스 상속 vs 인터페이스 상속**

        **클래스**

        객체 내부 상태와 그 객체의 연산에 대한 구현 방법을 정의

        **객체의 타입**

        그 객체의 인터페이스, 객체가 응답할 수 있는 요청의 집합을 정의

        **객체의 구현은 다를지라도 인터페이스는 같을 수 있다.**

        A 클래스의 객체

        A클래스가 정의한 인터페이스를 지원한다는 뜻


    - **구현을 따르지 않고 인터페이스를 따르는 프로그래밍**

        동일한 인터페이스를 갖는 객체군을 정의하는 것이 상속의 가장 중요한 특징

        이것으로 **다형성**을 이끌어낼 수 있다.

        → **부모 클래스에 정의된 요청**이 **서브클래스에게 전달**되어도 서브클래스가 **처리할 수 있다**는 의미

        - **이 프로그래밍 방식을 따를 경우 얻는 장점**
            1. 사용자가 사용하는 객체의 타입을 알 필요가 없다.(원하는 인터페이스가 다 들어있을 경우)
            2. 사용자는 이 객체들을 구현하는 클래스를 알 필요가 없고, 인터페이스를 정의하는 추상클래스만 알면된다.

            → **서브시스템 간 구현 종속성 제거**

            → **변수를 구체 클래스의 인스턴스로 선언하는 일을 없애야 한다.**

            → **추상 클래스의 인터페이스를 따르는 인스턴스 변수를 정의 할 것**


    ### 재사용을 실현 가능하게 만들기

    - **상속 vs 합성**

        **상속,** **White-Box Reuse(Reuse By Subclassing)**

        상속을 받으면 부모 클래스의 내부가 서브클래스에 공개되기  때문에 내부를 볼 수 있다는 의미

        **컴파일 시점에 정적으로 정의**

        - **단점**
            1. 런타임 시점에 상속받은 부모 클래스의 구현 변경 불가
            2. 부모 클래스가 정의한 물리적 표현들을 전부 또는 일부만 상속

                → 부모 클래스의 구현이 외부에 노출됨

                → 캡슐화파괴 현상 발생 ex)자바의 스택

            3. 부모 클래스의 종속적인 구조

                → ‼️ 부모 클래스 구현 변경시 서브 클래스도 변경 대상이 된다.

                생성자가 없는 추상 클래스를 이용하면 해결되긴한다.


         **객체 합성,** **Black-Box Reuse**

        한 객체가 다른 객체에 대한 참조자를 얻는 방식

        → **런타임 시점에 동적으로 정의**

        다른 객체 여러 개 붙여서 새로운 기능 혹은 객체를 구성하는 것

        합성을 위해선, 합성에 들어가는 객체의 인터페이스를 명확하게 정의해 두어야한다.

        - **주의점**
            1. 객체가 다른 객체의 인터페이스 만을 바라보게 만듬
            2. 인터페이스 정의에 신경을 써야함
            3. 동일한 타입을 가질시 다른 객체로 런타임에 대체 가능

                → 객체가 인터페이스에 맞춰 구현되므로 구현 사이의 종속성이 사라짐

        - **장점**
            1. 클래스의 캡슐화 유지
            2. 각 클래스 한 가지작업에 집중 가능
            3. 클래스간 계층이 낮아짐 → 시스템 소규모화
            4. 시스템의 행동 풍부화 가능

        **클래스 합성보다 객체 합성이 더 나은 방법이다.**

        **단, 상속도 적절히 섞어줘야 완벽한 재사용이 가능하다.**

    - **위임 ([[링크]])**

        두 객체가 하나의 요청을 처리하게 만드는 합성

        - **장점**
            1. 런타임 시점에 행동을 복합 시킬 수 있다.
            2. 복합하는 방식도 변경가능하게 해준다.
        - **단점**
            1. 객체 합성방식이라 동일하게 동적임
            2. 동적인 코드는 이해하기 까다로움

        **고도로 표준화 된 패턴에서 사용하는 것이 가장 좋음**

    - **상속 vs 매개변수화된 타입(제네릭)**

        C++에서는 템플릿, 자바에서는 제네릭이라 불린다.

        타입정의시 타입이 사용하는 다른 모든 타입을 다 지정하지 않은 채 정의,

        지정되지 않은 타입은 매개변수로 제공

         OOP내부 행동 복합 방법

        1. 서브클래스에 의해 연산을 구현 [상속]
        2. 정렬 루틴으로 전달된 객체(Strategy) [합성]
        3. C++ 템플릿이나 JAVA, Dart의 제네릭으로 정의한 클래스의 인자로 원소를 비교할 함수 이름을 명시 [매개변수화]

        **런타임시 클래스가 사용하는 타입을 변경하게 하는 것, 주의해서 사용할 것**


    ### 런타임 및 컴파일 타임의 구조를 관계짓기

    컴파일 시점, 런타임 시점 두 가지에 따라 실행 구조가 결정되기 때문에 종종 코드 구조와 일치 하지 않는다.

    컴파일 시점엔 고정된 상속 클래스 관계들이 포함

    런타임 시점엔 교류하는 객체들에 따라  구조가 달라진다.

    **두 구조는 전혀 다른 독립성을 지닌다**.

    객체 관계

    acquaintance(association) > aggregation > composition

    aggregation과 association은 코드 구현상 구분이 거의 불가능함

    ```dart
    class ClassA{
    	A a; // association
    	B b; // aggregation
    	final C c; // Composition
    	ClassA(C c){
    		c= C();
    	}
    }
    ```

    ```dart
    class Person{
    	Tool *pen // association
    	DepartMent *departMent // aggregation
    	final Heart *heart; // Composition
    	Person(Heart heart)
    }
    ```

    코드 구현상 association과 aggregation은 별차이가 없지만 이름만 바꾸면 의미가 완전히 달라진다.

    **association**

    Person이 무슨 Tool 지니던 그냥 지닌거나 다름 없다. 관계만 가진 것,

    [know of / using]

    **aggregation**

    Department는 현제 사람이 어느 건물에 사는지, 소속 되어 있는지에 대한 관계를 지닌다.

    주로 컬렉션과 같이 쓰인다.

    [having / part of]

    **composition**

    Person은 heart없이 살수 없다 생존 주기 자체가 같이 살고 같이 죽는다.

    ownership 개념이 추가 된 것,

    [own]

    객체의 제한 상황에 따라 구분 지어 진다고 보면된다.

    그림으로 보면

    [[Study/Design Pattern/GOF design pattern/Untitled.png]]

    [[Study/Design Pattern/GOF design pattern/Untitled 1.png]]

    ### 변화의 대비한 설계

    **문제들과 문제 해결 패턴들**

    - **특정 클래스에서 객체 생성**

        객체 생성시 클래스 이름을 명시하면 인터페이스가 아닌 구현에 종속되게 된다.

        이를 방지 하기 위해선 객체를 직접 생성하는 행동을 막아야한다.

        - **디자인 패턴 : Abstract Factory, Factory Method, Prototype**
    - 특**정 연산에 대한 의존성**

        특정 연산을 사용하는 행동 자체가 요청을 만족하는 한가지 방법에만 얽매이게 되는 현상이다.

        요청의 처리 방법을 직접 코딩하는 것을 방지하면 컴파일 타임, 런타임 둘다 동시에 만족 시켜줄 수 있다.

        - **디자인 패턴 : Chain Of Responsibility, Command**
    - **하드웨어와 소프트웨어 플랫폼에 대한 의존성**

        특정 플랫폼에 종속되어 있는 현상이다.

        이 종속성을 제거하는 것은 매우 중요하다.

        - **디자인 패턴 : Abstract Factory, Bridge**
    - **객체의 표현이나 구현에 대한 의존성**

        사용자가 객체의 표현, 저장, 구현, 존재의 위치에 대한 모든 방법을 알게 되는 현상이다.

        이땐 객체 변경시 사용자도 변경해줘야하는 수고가 생긴다.

        이런 정보들은 사용자에게 감춤으로써 변화의 파급을 방지해야한다.

        - **디자인 패턴 : Abstract Factory, Bridge, Memento, Proxy**
    - **알고리즘 의존성**

        알고리즘 자체를 확장, 최적화, 대체할 시 이 알고리즘에 종속된 객체라면 변경할때마다 같이 변경시켜야한다.

        변경이 가능한 알고리즘은 분리해야한다.

        - **디자인 패턴 : Builder, Iterator, Strategy, Template Method, Visitor**
    - **높은 결합도**

        높은 결합도 = 독립적 재사용 힘듬 = 커다란 시스템 을 의미한다.

        추상클래스 수준에서 결합도를 정의하거나, 계층화시키는 방법으로 디자인 패턴에 낮은 결합도를 줘야한다.

        - **디자인 패턴 : Abstract Factory, Bridge, Chain Of Responsibility, Command, Facade, Mediator, Observer**
    - **지나친 서브클래싱을 통한 기능 확장**

        서브클래싱의 단점 = 새 클래스마다 초기화, 소멸 등 구현 오버헤드를 지님

        서브클래스를 정의 = 최상위부터 직속 부모 클래스까지 모든 것을 이해해야함

        단순한 확장의 의미로 사용할 경우 = 클래스의 수를 엄청나게 증가

        **객체 합성과 위임은 행동 조합을 위한 상속보다 훨씬 유연한 방법**,

        기존 객체들을 새로운 방식으로 조합하면 서브클래스 정의 없이 응용프로그램에 기능성이 추가된다.

        **역으로 많이 쓰면 이해가 힘들어 진다.**

        이미 많은 디자인 패턴이 도입된 프로그램에는 서브클래스 정의 후 다른 인스턴스와 새로 정의한 클래스의 인스턴스를 합성해 기능을 재정의 해야한다.

        - **디자인 패턴 : Bridge, Chain Of Responsibility, Decorator, Visitor, Strategy**
    - **클래스 변경이 힘든 상황**
        - **디자인 패턴 : Adapter, Decorator, Visitor**
- 사례 연구

    워드 프로세서 개발 사례에 대한 연구

    - **문서 구조**
        - **필요 조건**

            문서의 물리적 구조 유지 기능 : 문자, 그래픽, 행, 열, 테이블 등등

            문서를 시각적으로 생성, 표현하는 부분

            내부 표현 영역의 요소들과 화면에 표시된 요소들을 똑같이 표현하는 부분

        - **제약 사항**

            문자와 그래픽을 동일하게 적용

            단일 요소와 그룹 요소를 구분해서 구현 금지

            단, 텍스트 철자법 검사는 필요함


        **재귀적 합성**

        계층적으로 구조화된 정보를 보여주는 가장 보편적인 방법

        단순한 것 → 복잡한 것 점진적 개발 가능

        **글리프**

        화면에 표시되는 구성요소를 포괄적으로 일컫는 개념

        문서 구조에서 나타낼 수 있는 모든 객체를 위한 추상 클래스

        **책임**

        어떻게 자기 자신을 그리는지

        차지하는 영역이 얼마나 되는지

        자신의 자식들과 부모가 누구인지를 가리키거나 참조

        **Window**

        스크린의 윈도우에 텍스트와 기본 도형을 표현하기 위한 그래픽 연산 정의

        ex

        Glyph

        Rectangle

        Character

        Row // Row 내부 필드로 글리프를 저장해둔 컬렉션이 있다. 리스트등등

        Polygon

        ... 기타 자식클래스

        **[정리] 복합체 패턴**

        재귀적 합성은 단순한 문서 이상의 복잡한 계층적 구조를 표현 할 수 있다.

        복합체 패턴은 특히 객체지향 관점에서 재귀적 합성을 표현한다.

    - **서식 설정**

        **Interface of Compositor**

        ```cpp
        void SetCompositioin(Composition*) // 무엇을 설정하는 지
        virtual void Compose() // 언제 설정할 것인지
        ```

        **서식 설정 알고리즘의 캡슐화**

        서식 설정은 다양한 알고리즘이 적용 될 수 있다.

        모든 요인은 컴파일 시점에 결정할 수 없다.

        적당히 품질, 시간, 성능 줄다리기로 정해주어야 한다.

        **제약사항**

        1. 문서 구조에 독립적이며 정의된 형태를 유지할 것.
        2. 알고리즘과 상관없이 Glyph의 새 서브클래스 추가가 문제 없어야 하며 반대도 마찬가지 일 것.
        3. 설계시 컴파일 시점에서는 서식 설정을 알고리즘을 쉽게 변경할 수 있도록 설계할 것
        4. 서식 설정 **알고리즘**을 **캡슐화한 객체별 클래스 계층**을 **별도로 정의**할 것
        5. **최상위**에서는 **각 서브클래스**가 특별한 **알고리즘**을 수행하도록 **인터페이스**를 구현 할 것
        6. **Glyph의 서브클래스**를 통해 특정 **알고리즘 객체**를 이용하게 하여 자식들을 **자동으로 구조화** 시킬 것

        [[research_1.png]]

        **합성자와 복합**

        **Compositor**

        서식 설정 알고리즘을 캡슐화할 수 있는 객체

        SetComposition(), Compose() 메서드에 대해 정의

        **Composition**

        Composition은 compositor를 집합 관계로 지니며(having)

        Compositor는 composition을 위임으로 가지고 있다.

        Glyph의 자식 클래스이며 Glyph를 집합 관계로 지닌다(having)

        Composition 객체는 서식 설정시 Compositor의 Compose()메서드를 호출

        이후 Composition 객체와 자식 관계에 있는 인스턴스를 라인 분리 알고리즘에 따라 새로 생성

        새로운 Row와 Column 글리프에 삽입,

        각 Compositor 서브 클래스들은 각기 다른 알고리즘을 구현

        물리적 구조와 서실 설정 알고리즘을 지원하는 코드를 확실히 구분

        **전략 패턴**

        알고리즘을 객체로 캡슐화 하는 것

        Compositor = Strategy class

        Composition = Strategy에 대한 context

        기존 구조를 건들지 않으며 알고리즘의 추가 삽입 변경이 이뤄질수 있고

        런타임에도 자연스럽게 이뤄질 수 있다

    - **사용자 인터페이스 꾸미기**

        **투명한 포함**

        장식된 객체가 장식 되었는지 사용자 입장에서 알지 못해야한다는 개념

        이를 위해선 기존에 구현되는 클래스와 이 클래스를 상속 받는 자식 클래스의 구현이 더해져야한다.

        그러면 사용자 입장에서는 눈치를 채지 못한다.

        얘를 들면

        글리프를 집합관계로 가지는 모노글리프는 보더와 스크롤러를 참조하며

        적어도 한번 모노글리프의 Draw()에 의해 기본으로 글리프가 그려진다.

        여기에 보더의 경우 보더를 한번 더 그리게 된다.

        즉, 이미 모노글리프의 Draw()연산이 한번 이뤄지기 때문에 사용자는 눈치를 채지 못한다.

        이렇게하면 복합에는 관여 없이 기존에 있는 글리프의 Draw()연산 만으로 장식만을 추가 할 수 있다.

        **중요 포인트**

        1. 글리프의 추상 클래스를 만들고 글리프와 집합관계를 가지는 객체를 추가한다.
        2. 그리고 글리프의 추상클래스를 통해 보더와 스크롤러를 구현한다.
        3. 나를 바로 상속하지 않고 나를 대신해 상속할 추상 클래스를 만드는 것이 중요하다.
        4. 이래야 기존 컴포지션에 관여하지 않는다.

        [[research_2.png]]

        **장식자 패턴**

        투명한 포함 개념에 의해 **장식을 지원하는 클래스**와 **포함되는 객체들 사이의 관계**를 잡아낸 것

        장식

        객체에 추가할 수 있는 모든 책임에 해당한다.

        즉, **디코레이터는 모노글리프**에 해당되며 **장식(들)은 보더와 스크롤러**이다.

    - **여러 룩앤필 표준의 지원**

        [[research_3.png]]

        **객체 생성 추상화**

        Glyph를 상속 받는 서브클래스 집합

        각 추상 클래스를 상속하는 서브클래스 집합

        **팩토리와 제품 클래스**

        ```cpp
        ScrollBar * sb = new MotifScrollBar;// X

        ScrollBar * sb = guiFactory -> CreatefScrollBar();// O
        ```

        guiFactory 객체는 모든 종류의 표준을 지원하는 버튼을 만들 수 있다.

        공통의 인터페이스를 추상하는 인터페이스 이기 때문

        이때 guiFactory객체를 싱글톤으로 만들어주면 어디서든 위젯(글리프)를 플랫폼 상관없이 그려낼 수 이따.

        **추상 팩토리 패턴**

        사용시기

        제품 객체의 종류(ex: 버튼, 박스 스크롤바 등)는 일정하고 각 각체의 특성이 특정 제품군 마다 차이가 존재할때

        같은 부류에서 제품을 선택하게끔 만든다.

        **추상 팩토리 패턴은 동일 계열의 제품군을 다룰 수 있다**

        **다른 생성패턴은 한 종류의 제품 객체만 상대**하기때문에 이 점이 **핵심**이다.

    - **여러 윈도우 시스템의 지원**

        추상 팩토리 패턴의 사용가능성

        구현 종속성을 캡슐화

        Object & ObjectImp

        브릿지 패턴

    - **사용자 조작**

        요청의 캡슐화

        Command 클래스& 서브클래스

        취소 가능성 (undo)

        명령 히스토리

        명령 패턴

    - **철자 검사와 붙임표 처리**

        이터레이터 패턴과 비지터 패턴

        이터레이터는 **객체구조에 접근하거나 순회하는 패턴**에 사용되며

        비지터는 이미 구체 클래스가 많고 안정된 상태에서 연산을 추가하기위해 사용된다.

        구체 클래스에 Accept()를 추가하고 비지터 객체를 받도록 만든다.

        비지터의 객체는 Accept를 호출중인 객체 자체를 받는다. this를 파라미터로 받는다.

        이러면 **비지터가 객체를 받아 객체를 이용한 연산을 추가로 할 수 있다**.

        **비지터의 연산이 많아져도 객체는 딱히 상관이 없다. 온전하기 때문**

        **하지만 역으로 객체가 하나 추가되면 비지터에도 연산을 추가해야한다.**
