# 데이터 모델링의 이해

### 데이터 모델의 이해

- 모델링

    현실 세계를 단순화 하여 표현하는 기법,

    현실 세계를 추상화, 단순화, 명확화하기 위해 일정한 표기법에 의해 표기하는 기법

    - 특징
        1. 추상화 [Abstraction]

            현실 세계를 일정한 형식으로 표현하는 것, 아이디어나 개념을 간략하게 표현하는 과정

        2. 단순화 [Simplification]

            복잡한 현실 세계를 표기법으로 단순하고 쉽게 표현한다는 의미

        3. 명확화 [Clarity]

            불분명함을 제거하고 명확하게 해석할 수 있도록 기술한다는 의미

    - 모델링의 관점
        1. 데이터 관점 [What, Data]

            데이터 위주의 모델링

            어떤 데이터들이 업무와 얽혀있는지, 그리고 그 데이터간에는 어떤 관계가 있는지에 대해서 모델링 하는 방법이다.

        2. 프로세스 관점 [How, Process]
        3. 데이터와 프로세스의 상관 관점 [Data vs Process, Interaction]
    - 데이터 모델링시 고려사항
        - 데이터 중복
        - 비유연성
        - 비일관성
    - **모델링의 세 가지 단계**
        1. **개념적 데이터 모델링 [Conceptual Data Modeling]**

            **전사적** 데이터 모델링 수행 시 행해지며 **추상화레벨이 가장 높은 모델링**

            이 단계에서는 **업무 중심적이고 포괄적인 수준**의 모델링이 진행된다.

        2. **논리적 데이터 모델링 [Logical Data Modeling]**

            **재사용성**이 가장 높은 모델링

            데이터베이스 모델에 대한 **Key, 속성 관계 등을 모두 표현**하는 단계

        3. **물리적 데이터 모델링 [Physical Data Modeling]**

            실제 데이터베이스에 구현할 수 있도록 **성능이나 가용성 등의 물리적인 성격을 고려**하여 모델을 표현하는 단계

- 데이터의 독립성

    ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-26_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.59.58.png]]

    - ANSI-SPARC 아키텍처

        1975년에 제안된 데이터베이스 관리 시스템(DBMS)의 추상적인 설계 표준

        - 특징

            스키마를 3단계 구조로 나눈다.

            → 데이터베이스에 대한 사용자들의 관점과 데이터베이스가 실제로 표현되는 물리적인 방식을 분리하기 위함

            → 독립성 보장을 위함

            → 데이터베이스가 존재하는 목적 중의 하나는 사용자에게 데이터를 보여줄 수 있는 뷰를 제공하는 것

            → 사용자 입장에서는 필요한 데이터만 보면되며 데이터베이스의 내부 구조에 대해 굳이 알 필요가 없다.

            → DBA 입장에서는 애플리케이션에 영향을 주지 않고 데이터베이스의 구조를 변경할 수 있어야 독립성이 보장된다고 할 수 있다.

    - 3단계 스키마 구조
        1. **외부 스키마 [External Schema]**

            **사용자 관점** [Multiple User`s view 단계]

             **각 사용자**가 보는 데이터베이스의 스키마를 정의

            **응용 프로그램이 접근하는 데이터베이스를 정의**

        2. **개념 스키마 [Conceptual Schema]**

            **통합된 관점** [Community View of DB 단계]

            **모든 사용자**가 보는 데이터베이스의 스키마를 **통합해 전체 데이터베이스**를 나타내는 것

            데이터베이스에 저장되는 데이터들을 표현하고 데이터들 간의 관계를 나타낸다.

        3. **내부 스키마 [Internal Schema]**

            **물리적 관점** [Physical Representation 단계]

            **물리적인 저장 구조**를 나타낸다.

            실질적인 **데이터의 저장 구조, 컬럼 정의, 인덱스** 등이 포함된다.

    - 3단계 스키마 구조가 보장하는 독립성
        1. 논리적 독립성

            개념 스키마가 변경되어도 외부 스키마는 영향을 받지 않는다.

        2. 물리적 독립성

            내부 스키마가 변경되어도 외부/개념 스키마는 영향을 받지 않는다.

- ERD [Entity Relationship Diagram]

    시스템에 어떤 엔티티들이 존재하며 그들 간에 어떤 관계가 있는지를 나타내는 다이어그램

    - ERD 표기방식
        1. Peter Chen

            주로 대학교재에서 사용하는 표기법

            실무에서 사용하는 경우는 드물다.

            ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.47.39.png]]

        2. IDEF1X [Integration Definition for Information Modeling]

            ERWin에서 사용되는 모델 표기법

            실무에서 가끔 사용한다.

            ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.47.48.png]]

        3. IE/Crow`s Foot

            ERWin, ERStudio에서 사용되는 모델 표기법

            까마귀발 표기법이라고 부르며 가장 실무에서 많이 사용한다.

            ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.47.56.png]]

        4. Min-Max/ISO

            각 엔티티의 참여도를 좀 더 상세하게 나타내는 표기법

            ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.48.04.png]]

        5. UML

            소프트웨어 공학에서 주로 사용되는 모델 표기법

            ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.48.11.png]]

        6. Case*Method/Baker

            Oracle에서 사용되는 모델 표기법

            Crow`s Foot과 비슷하다.

            ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.48.19.png]]

    - IE/Crow`s Foot 표기법

        ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.52.26.png]]

    - ERD 작성 순서
        1. 엔티티 도출후 작성
        2. 엔티티들을 적절히 배치
        3. 엔티티 간의 관계를 설정
        4. 관계명들을 기입
        5. 관계의 참여도 기입
        6. 관계의 필수/선택 여부를 기입

### 엔티티 [Entity]

DBMS에서 식별이 가능한 개체

- 시기별 정의


    | 이름 | 시기 | 정의 |
    | --- | --- | --- |
    | Peter Chen | 1976 | 식별할수 있는 시물
     |
    | C.J Date | 1986 | 데이터베이스 내에서 식별 가능한 객체
     |
    | James Martin | 1989 | 정보를 저장할 수 있는 어떤 것 |
    | Thomas Bruce | 1992 | 정보를 저장할 수 있는 사람, 장소, 물건, 사건 그리고 개념등 |
- 각 내부 명칭
    1. 엔티티

        테이블

    2. 속성

        Column

    3. 인스턴스

        Row

    - 예시

        ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.31.06.png]]

- **엔티티 특징**
    1. **업무에서 쓰이는 정보**여야 한다.
    2. 유니크함을 보장할 수 있는 **식별자가 있어야 한다.**
    3. **2개 이상의 인스턴스**를 가지고 있어야 한다.
    4. **반드시 속성**을 가지고 있어야 한다.
    5. **다른 엔티티와 1개 이상의 관계**를 가지고 있어야 한다.
- 엔티티의 분류
    1. **유, 무형에 따른 분류 [유, 개, 사]**
        - **유형** 엔티티

            물리적인 형태 존재, **안정적**, **지속적**

            → 상품, 회원등등

        - **개념** 엔티티

            **물리적인 형태 없음, 개념적**

            → 부서, 학과 등등

        - **사건** 엔티티

            **비즈니스 프로세스를 실행하면서 생성**

            행위를 함으로써 발생, 빈번함, 통계 자료로 이용 가능

            → 주문, 이벤트 응모 등등

    2. **발생시점에 따른 분류 [기, 중, 행]**
        - **기본 엔티티 [키 엔티티]**

            **독립적으로 생성**됨, **자식 엔티티를 가질 수 없음**

            → 상품, 회원

        - **중심 엔티티 [메인 엔티티]**

            **기본 엔티티로부터 파생**, **행위 엔티티 생성**

            업무에 있어서 중심적인 역할을 하며 데이터의 양이 많이 발생한다.

            → 주문

        - **행위 엔티티**

            **2개 이상의 엔티티로부터 파생**

            데이터가 자주 변경되거나 증가할 수 있다.

            → 주문 **내역**, 이벤트 응모 **이력**

- 엔티티 작명시 주의점
    1. 업무에서 실제로 쓰이는 용어 사용
    2. 한글은 약어를 사용하지 않고 영문은 대문자로 표기
    3. 단수 명사로 표현하고 띄어쓰기는 하지 않음
    4. 다른 엔티티와 의미상으로 중복될 수 없음 (단, 주문, 결제 엔티티는 중복될 수 있음)
    5. 해당 엔티티가 갖고 있는 데이터가 무엇인지 명확하게 표현

### 속성 [Attribute]

엔티티의 특징을 나타내는 최소의 데이터 단위

의미상 더 이상 쪼개지지 않는 원자성을 지녀야하며 프로세스에 꼭 필요한 항목이어야 한다.

- 속성 값

    각각의 속성은 속성 값(value)를 가지며 엔티티에 속한 하나의 인스턴스를 구체적으로 나타내주는 데이터이다.

    속성값이 여러 데이터를 넣어야하는 경우 별도의 엔티티로 분리해야한다.

- 엔티티, 인스턴스, 속성, 속성 값의 관계

    <aside>
    💡 $엔티티 \supset 인스턴스 \supset 속성$

    </aside>

    1. 하나의 엔티티는 두 개 이상의 인스턴스를 가진다.
    2. 하나의 인스턴스는 두 개 이상의 속성을 가진다.
    3. 하나의 속성은 하나의 속성 값을 가진다.
- 속성의 분류
    - 특성에 따른 분류
        - **기본 속성 [Basic Attribute]**

            업무 프로세스 분석을 통해 **바로 정의가 가능한 속성, 본래의 속성**

            → 거의 대부분의 속성은 기본속성에 해당한다.

        - **설계 속성 [Designed Attribute]**

            업무에 존재하지는 않지만 **설계하다 보니 필요하다고 판단되어 도출**해낸 속성

            → 학생 엔티티의 **유일성을 부과**하기 위해 학번 속성을 추가하기 등등이 있다.

            →상품코드, 주문 코드

        - **파생 속성 [Derived Attribute]**

            다른 속성의 속성 값을 계산하거나 특정한 규칙으로 변형하여 생성한 속성

            → 주문 이력 구매 수량 합차 계산을 위해 상품 엔티티에 상품 재고 속성을 추가

            → 이런 속성은 데이터 정합성에 영향을 주기 때문에 불가피하게 필요한 상황에만 사용해야한다.

    - 구성 방식에 따른 분류
        - PK(Primary Key) 속성

            엔티티의 인스턴스의 식별할 수 있는 속성

        - FK(Foreign Key) 속성

            다른 엔티티의 속성에서 가져온 속성

        - 일반 속성

            PK, FK를 제외한 나머지 속성

- **도메인**

    **속성 값의 범위**

    - 예시

        우편번호는 5자리 숫자라는 범위를 지니며 엔티티 정의시 데이터 타입과 크기로 나타낼 수 있다.

- 용어사전

    하나의 DB에서 같은 의미를 가진 데이터가 엔티티마다 각기 다른 이름으로 정의된다면 혼란을 초래하므로

    이 문제를 방지하기 위해 설계 시 용어사전을 두고 각 엔티티에 공통된 룰로 적용하는 것이 바람직하다.


### 관계 [Relationship]

엔티티간의 관계

어떠한 연관성이 있는지 타입을 분류하여 존재 관계와 행위 관계로 분류할 수 있다.

- **존재 관계**

    **엔티티 간 상태를 나타낸다**.

    엄마와 아기처럼 존재 자체로 연관성이 있는 관계를 의미

    → 직원과 부서, 학생과 학과 엔티티 등등 속해있는 한 엔티티가 다른 엔티티의 진부분집합인 관계를 의미

- **행위 관계**

    특정한 행위를 함으로써 연관성이 생기는 관계를 의미

    → 회원과 주문, 학생과 출석부 엔티티등등이 있다.

- 관계 표기법
    - 관계명 [Membership]

        관계의 이름

        엔티티간의 어떤 관계를 맺고 있는지를 나타내주는 문장이다.

        ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.01.59.png]]

        - 주의점

            반드시 명확한 문장이여야 하며 현재형이여야한다.

    - 관계차수 [Cardinality]

        관계에 참여하는 수

        1:1, 1:N, N:M으로 표현된다.

    - 관계선택사양 [Optionality]

        필수인지 선택인지 여부

        - Crow`s Foot 표기시 차이

            ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.16.10.png]]


### 식별자 [Identifiers]

속성중 각각의 인스턴스를 구분 가능하게 만들어주는 대표 격인 속성을 의미한다.

- **주식별자**

    **기본키**, PK(Primary Key)에 해당하는 속성

    **한 개 이상의 속성이 주 식별자가 될 수 있다.**

    - **주 식별자 특징**
        - **유일성**

            각 인스턴스에 유니크함을 부여하여 식별이 가능하도록 한다.

        - **최소성**

            유일성을 보장하는 최소 개수의 속성이어야 한다.

        - **불변성**

            속성 값이 되도록 변하지 않아야 한다.

        - **존재성**

            속성 값이 NULL일 수 없다.

    - 키의 종류
        - 기본키 [Primary Key]

            후보키중 엔티티를 대표할 수 있는 키

        - 후보키 [Candidate Key]

            후보키는 유일성과 최소성을 만족하는 키

        - 슈퍼키 [Super Key]

            유일성은 만족하지만 최소성을 만족하지 않는 키

        - 대체키 [Alternate Key]

            후보키들중 기본키를 제외한 키

        - 외래키 [Foreign Key]

            하나 이상의 다른 테이블의 기본키 필드를 가리키는 키

            참조 무결성을 확인하기 위해서 사용되는 키

            허용된 데이터 값만 데이터베이스에 저장하기 위해서 사용된다.

    - **식별자 분류**
        - 대표성 여부
            - 주식별자 [Primary Identifier]

                유일성, 최소성, 불변성, 존재성등 모든 식별자의 특징을 가진 대표 식별자

                다른 엔티티와 참조관계로 연결

            - 보조식별자 [Alternate Identifier]

                인스턴스를 식별할 수 있으나 대표 식별자는 아님

                다른 엔티티와 참조관계로 연결하지 않음

        - 스스로 생성되었는지 여부
            - 내부식별자 [Internal Identifier]

                엔티티 내부에서 스스로 생성된 식별자

            - 외부식별자 [Foreign Identifier]

                다른 엔티티에서 온 식별자(FK), 다른 엔티티와 연결고리 역할

        - 단일 속성의 여부
            - 단일식별자 [Single Identifier]

                하나의 속성으로 구성된 식별자

            - 복합식별자 [Composite Identifier]

                두 개 이상의 속성으로 구성된 식별자

        - 대체 여부
            - 원조식별자 [Original Identifier]

                업무 프로세스에 존재하는 식별자, 가공되지 않은 원래 식별자(본질 식별자)

            - 대리식별자 [Surrogate Identifier]

                주식별자의 속성이 두 개 이상인 경우, 그 속성들을 하나로 묶어서 사용하는 식별자(인조 식별자)

        - 예시

            ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.27.09.png]]

    - 식별자 관계 VS 비식별자 관계
        - 식별자 관계 [Identification Relationship]

            표기시 실선으로 표기한다

            부모 엔티티의 식별자가 자식 엔티티의 주식별자가 되는 관계

            단일 or 복합 식별자인지에 따라 1:1 또는 1:M인지 관계차수가 결정된다.

        - 비식별자 관계 [Non-Identification Relationship]

            표기시 점선으로 표기한다

            부모 엔티티의 식별자가 자식 엔티티의 일반 속성이 되는 관계

            일반 속성은 nullable하므로 부모 엔티티 없는 자식 엔티티 생성이 가능하고 자식 엔티티가 존재하는 상황에서 부모 엔티티 삭제가 가능하다.


        식별자 vs 비식별자 관계는 연관관계의 주인이 누구인지에 따라 바뀌는 관계이다.

        일반적으로 연관관계의 주인은 FK가 존재하는 쪽이 주인이며 개념상 부모와 자식중 주인이 누구인지에 따라 식별자, 비식별자 관계가 나뉜다. ****

        FK를 지닌 자식은 식별자 관계, FK를 지닌 부모는 비식별자 관계이다.
