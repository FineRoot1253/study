# SQL 최적화와 원리

### 옵티마이저

SQL의 실행 계획을 수립하고 SQL을 실행하는 DBMS의 소프트웨어

동일한 결과가 나오는 SQL도 어떻게 실행하느냐에 따라 성능이 천차만별이다.

옵티마이저의 실행계획은 SQL의 성능에 아주 중요한 역할을 한다.

- 특징

    데이터 딕셔너리에 있는 오브젝트 통계, 시스템 통계등의 정보를 사용해서 예상되는 비용[COST]를 산정한다.

    옵티마이저는 여러 개의 실행 게획 중에서 최저비용을 가지고 있는 계획을 선택해서 SQL을 수행한다.

- 필요성
    - 단순 테이블 두개의 EQUI JOIN시

        만약 테이블 EMP와 테이블 DEPT중 가장 행이 많은 테이블이 EMP인 상황,

        이때 건수가 가장 많은 EMP 테이블을 먼저 읽고 DEPT 테이블을 읽으면 불필요한 비교 횟수가 증가하게 된다.

        이때 SQL개발자는 **옵티마이저에게 실행 계획을 변경하기 위해 힌트[HINT]를 사용**한다.

- 실행 계획 확인 방법

    옵티마이저는 SQL 실행 계획을 PLAN_TABLE에 저장한다.

    SQL 개발자는 PLAN_TABLE을 조회해서 실행 계획을 확인가능하다.

    만약 TABLE ACCESS FULL이라고 하면 테이블 전체를 읽었다는 뜻이다.

    데이터가 수천만 건이라면… 그래서 파티셔닝이 중요한 전략이다.

- 옵티마이저 종류
    - 옵티마이저 실행 과정

        !![[KakaoTalk_Image_2022-09-01-20-06-45.jpeg]]

        1. 개발자가 SQL 실행시 파싱[Parsing]을 실행해 SQL의 문법 검사 및 구문 분석을 수행
        2. 구문 분석 완료후 옵티마이저가 규칙 기반 또는 비용 기반으로 실행 계획을 수립
        3. 옵티마이저는 비용 기반 옵티마이저를 기본적으로 사용하며 비용 기반 옵티마이저는 통계 정보 (Data Dictionary의 오브젝트 통계, 시스템 통계)를 활용해서 최적의 실행 계획을 수립한다.
        4. 실행 계획이 수립이 완료되면 최종적으로 SQL을 실행[Execution]하고 실행이 완료되면 데이터를 인출[Fetch]한다.
    - 옵티마이저 엔진 종류
        1. Query Transformer

            SQL문을 효율적으로 실행하기 위해서 옵티마이저가 변환한다.

            SQL이 변환되어도 그 결과는 동일하다.

        2. Estimator

            통계 정보를 활용해 SQL실행비용을 계산한다.

            총 비용은 최적의 실행 계획을 수립하기 위해서이다.

        3. Plan Generator

            SQL을 실행할 실행 계획을 수립한다.

    - 규칙 기반 옵티마이저 [RULE BASE OPTIMIZER, RBO]

        실행 계획 수립시 15개의 우선 순위를 기준으로 실행 계획을 수립한다.

        최신 오라클 버전은 비용 기반 옵티마이저를 기본적으로 사용한다.

        - 우선순위
            1. ROWID를 사용한 단일 행인 경우
            2. 클러스터 조인에 의한 단일 행인 경우
            3. 유일하거나 기본키를 가진 해시 클러스터 키에 의한 단일 행인 경우
            4. 유일하거나 기본키에 의한 단일 행인 경우
            5. 클러스터 조인인 경우
            6. 해시 클러스터 조인인 경우
            7. 인덱스 클러스터 키인 경우
            8. 복합 컬럼 인덱스인 경우
            9. 단일 컬럼 인덱스인 경우
            10. 인덱스가 구성된 컬럼에서 제한된 범위를 검색하는 경우
            11. 인덱스가 구성된 컬럼에서 무제한 범위를 검색하는 경우
            12. 정렬-병합 [Sort Merge] 조인인 경우
            13. 인덱스가 구성된 컬럼에서 MAX또는 MIN을 구하는 경우
            14. 인덱스가 구성된 컬럼에서 ORDER BY를 사용하는 경우
            15. 전체 테이블을 스캔 [FULL TABLE SCAN]하는 경우
    - 비용 기반 옵티마이저 [COST BASE OPTIMIZER, CBO]

        오브젝트 통계와 시스템 통계를 사용해 총 비용을 계산한다.

        - 총비용

            SQL 실행시 예상되는 소요시간 혹은 자원의 사용량등을 의미한다.


        항상 총비용이 적은 쪽으로 실행 계획을 수립한다.

        단, 통계정보가 부적절하다면 성능저하가 발생한다.


### 인덱스

데이터를 빠르게 검색할 수 있는 방법을 제공한다.

인덱스는 인덱스 키로 정렬되어있기 때문에 원하는 데이터를 빠르게 조회한다.

인덱스는 오름차순 또는 내림차순 탐색이 가능하다.

하나의 테이블에 여러 개의 인덱스 생성이 가능하며 하나의 인덱스는 여러 개의 컬럼으로 구성될 수 있다.

테이블 생성시 기본키는 자동으로 인덱스가 만들어지며 인덱스의 이름은 SYSxxx이다.

- B+TREE구조의 인덱스 구조

    !![[KakaoTalk_Image_2022-09-01-20-28-26.jpeg]]

    인덱스의 구조는 Root Block, Branch Block, Leaf Block으로 구성된다.

    - Root Block

        가장 상위에 있는 노드

    - Branch Block

        다음 단계의 주소를 가지고 있는 포인터

    - Leaf Block

        인덱스 키 & ROWID로 구성

        인덱스 키는 정렬되어 저장되어 있다.

        → Double Linked List 구조로 오름, 내림차순 스캔이 용이하다.

        **인덱스 키를 읽으면 ROWID로 테이블 행의 직접 접근이 가능하다.**

- 인덱스 생성

    CREATE INDEX 문을 사용해 생성

    한개 이상의 컬럼을 사용해서 생성할 수 있다.

    인덱스 키는 기본적으로 오름차순으로 정렬하고 DESC를 포함하면 내림차순으로 정렬한다.

- 인덱스 스캔
    - 인덱스 유일 스캔 [Index Unique Scan]

        인덱스 키값이 중복되지 않는 경우 해당 인덱스를 사용할 때 발생

        만약 사원번호가 중복되지 않는다면 특정 하나의 EMPNO를 조회한다.

    - 인덱스 범위 스캔 [Index Range Scan]

        Select문에서 특정 범위를 조회하는 WHERE문을 사용할 경우 발생 [Predict 구문]

        → 인덱스의 Leaf Block의 특정 범위

        LIKE, BETWEEN이 대표적이다.

        데이터 양이 적은 경우 그냥 인덱스를 거치지 않고 TABLE FULL SCAN이 될 수도 있다.

    - 인덱스 전체 스캔 [Index Full Scan]

        인덱스에서 검색되는 인덱스 키가 많은 경우 Leaf Block 처음부터 끝까지 전체를 읽어 들인다.


### High Watermark [HWM]

테이블에 데이터가 저장된 블록에서 최상위 위치

TABLE FULL SCAN시 이 이하까지만 스캔한다.

데이터가 삭제되면 HWM이 변경된다.

**만약 데이터 대량삭제시 HWM이 변경이 아직 되지 않았을 경우**

**테이블을 스캔할때 무조건 HWM까지 읽기 때문에 I/O LOSS가 발생한다.**

 → TRUNCATE가 이때 좋다는 의미이긴하다.

### 실행 계획

!![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-09-01_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.18.46.png]]

만약 두개의 테이블을 조인하고 PK를 통해 특정 ROW를 접근하려는 쿼리의 실행 계획을 보면 이런식이다.

- 읽는 순서
    1. Unique Index Scan
    2. Index Scan
    3. Full Scan
    4. Nested Loops

    읽는 순서에 따르면 인덱스 테이블에 접근해 인덱스 유일 스캔으로 ROWID를 특정한다.

    → 이후 해당 ROWID로 PRODUCT_SAMPLE_1 먼저 조회하는데 이때 먼저 조회하는 테이블을 Outer Table 이라고 칭하며 그 다음에 조회되는 테이블은 Inner Table이라고 부른다.


### 옵티마이저 조인

- Nested Loop 조인

    하나의 테이블에서 데이터를 먼저 찾고 그 다음 테이블을 조인하는 방식

    - Outer Table

        먼저 조회되는 테이블

    - Inner Table

        나중에 조회되는 테이블

    - 특징
        1. Outer Table의 행이 적어야 효율이 높아진다.

            → 이래야 스캔 범위가 적어지기 때문

        2. RANDOM ACCESS가 무조건 발생한다.

            → 많이 발생할수록 성능이 하락한다.

            → 이걸 줄이는게 최종 목표인 조인이다.

        3. RANDOM ACCESS는 Outer 테이블 조회 결과를 통해 Inner Table의 인덱스를 조회할때 발생한다.

            → 그래서 이 Outer Table의 조회결과를 줄이는 것이 RANDOM ACCESS 수행시간을 줄이는데 핵심적이다.

- Sort Merge 조인

    두 개의 테이블을 SORT_AREA라는 메모리 공간에 모두 로딩한 뒤 SORT를 수행한다.

    → SORT가 완료되면 MERGE를 진행한다.

    → 이 SORT 작업때문에 기본적으로 데이터 양이 많으면 시도를 하지 말아야하는 조인이다. 성능이 무지막지하게 떨어지기 때문이다.

    → 만약 SORT_AREA 공간이 모자르면 임시 영역에서 작업을 수행하는데 임시영역은 디스크에 있기 때문에 성능이 또 무지막지하게 떨어진다.

- Hash 조인

    두 개의 테이블중 작은 테이블을 HASH 메모리에 로딩후 두 개의 테이블의 조인 키를 사용해서 해시 테이블을 생성한다.

    → 선행 테이블이 충분히 메모리에 로딩이 가능한 크기여야 수행가능하다.

    Hash 조인은 해시 함수를 사용해 주소를 계산하고 해당 주소를 사용해 테이블을 조인하기 때문에 CPU연산을 많이 한다.

- Hash 조인
- 힌트 사용시 ORDERED 뜻

    FROM절에 나온 테이블 순서대로 조인을 하라는 힌트이다.

    use_nl, use_merge, use_hash 힌트에도 사용가능하다.
