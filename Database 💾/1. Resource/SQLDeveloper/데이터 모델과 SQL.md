# 데이터 모델과 SQL

### 정규화 [Normalization]

데이터 정합성(데이터의 정확성과 일관성을 유지하고 보장)을 위해 엔티티를 작은 단위로 분리하는 과정

데이터 조회 성능은 보장 못하지만 일반적으로 CUD의 성능은 향상된다.

- 제 1정규형 [원자성 확보, 기본키 설정]

    모든 속성은 반드시 하나의 값만 가져야 한다.

    유사한 속성이 반복되어 붙는 경우 또한 1차 정규형 대상이 된다.

    ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.08.38.png]]

- 제 2정규형 [부분 함수 종속, 기본키가 2개 이상]

    엔티티의 모든 일반속성은 반드시 모든 주 식별자에 종속되어야 한다.

    일반적으로 복합식별자 상황에 잘 발생한다.

    ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.08.21.png]]

- 제 3정규형 [이행 함수 종속]

    주식별자가 아닌 모든 속성 간에는 서로 종속될 수 없다.

    일반적으로 단일식별자인 상황에 일반 속성에 종속되는 경우가 일반적이다.

    ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.10.21.png]]

- BCNF [후보키와 기본키]

    기본키를 제외하고 후보키가 존재하는 경우 후보키가 기본 키를 종속 시킨다면 분해

- 제 4 정규형 [다중값]

    여러 컬럼들이 하나의 컬럼을 종속 시키는 경우 분해하여 다중값 종속성을 분해

- 제 5 정규형 [JOIN]

    **조인에 의해 종속성**이 발생하면 분해

- 주의사항

    **지나친 정규화는 JOIN을 통한 Looping이 증가해 오히려 성능저하를 야기한다.**


### 반정규화 [De - Normalization]

데이터의 조회 성능 향상을 위해 데이터 중복을 허용하거나 데이터를 그룹핑하는 과정

정규화와 반대로 조회 성능 향상이 있을지언정 CUD 성능이 저하될 수 있으며 데이터 정합성 이슈 발생 가능성이 존재한다.

**반정규화는 반드시 정규화 과정을 거친 다음 시도되어야 한다.**

- 반정규화 절차
    1. 대상 조사 및 검토

        데이터 처리범위, 통계성등을 확인

        반정규화 대상 조사

    2. 다른 방법 검토

        클러스터링, 뷰, 인덱스 튜닝, 응용 프로그램, 파티셔닝 등등

    3. 반정규화 수행

        테이블, 속성, 관계등등 반정규화 진행

- 테이블 반정규화
    - 테이블 병합

        업무 프로세스상 JOIN이 필요한 경우가 많은 상황에 테이블 통합이 성능 향상에 도움이 되는 경우 고려되는 반정규화이다.

        1. 1:1 테이블 병합

            비교적 판단하기 수월하며 부작용도 적은 병합이다.

            ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.14.10.png]]

        2. 1:M 테이블 병합

            1의 테이블의 엔티티 속성 개수가 많으면 추천되지 않는다.

            ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.14.17.png]]

        3. 슈퍼 서브 타입 테이블 병합

            부모, 자식 간의 관계가 나타나는 테이블을 병합하는 것

            - 슈퍼 타입 및 서브 타입 변환 방법
                - OneToOne Type

                    슈퍼타입과 서브타입을 각각 개별 테이블로 도출

                    테이블 수가 많아져 조인 발생이 많고 관리가 힘들다

                - Plus Type

                    슈퍼 타입과 서브타입 테이블로 도출

                    조인이 발생하며 관리가 힘듬

                - Single Type

                    슈퍼 타입과 서브 타입을 한 테이블로 도출

                    조인 성능이 좋고 관리가 편리하지만 입출력 성능이 않좋음


    - 테이블 분할
        1. 테이블 수직 분할 (속성 분할)

            엔티티의 일부 속성을 별도의 엔티티로 분할 **[1:1]**

            자주 사용되는 속성이 아니거나 대부분의 인스턴스가 NULL로써 해당 속성을 지니고 있는 경우에 고려한다.

            ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.22.07.png]]

        2. 테이블 수평 분할 (인스턴스 분할, 파티셔닝)

            엔티티의 인스턴스를 특정 기준으로 별도의 엔티티로 분할 [파티셔닝]

            ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.22.19.png]]

    - 테이블 추가
        1. 중복 테이블 추가

            데이터 중복을 감안하더라도 성능상 반드시 필요하다고 생각되는 경우 별도의 엔티티를 추가

        2. 통계 테이블 추가

            ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.34.28.png]]

        3. 이력 테이블 추가

            ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.34.37.png]]

        4. 부분 테이블 추가

            ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.34.48.png]]

    - 컬럼 반정규화
        - 중복 컬럼 추가

            업무 프로세스상 JOIN이 필요한 경우가 많아 컬럼을 추가하는 것이 성능에 더 좋을 경우 고려한다.

        - 파생 컬럼 추가

            프로세스 수행시 부하가 염려되는 계산값을 미리 컬럼으로 추가하여 보관하는 방식

            → 상품의 재고, 프로모션 적용 할인가 등등

        - 이력 테이블 컬럼 추가

            대량의 이력 테이블을 조회할 때 속도가 느려질 것을 대비하여 조회 기준이 될 것으로 판단되는 컬럼을 미리 추가해 놓는 방식

            → 최신 데이터 여부 등등

    - 관계 반정규화(중복관계 추가)

        업무 프로세스상 JOIN이 필요한 경우가 많아 중복관계를 추가하는 것이 성능에 더 좋을 경우 고려한다.

- **클러스터링**

    클러스터링 인덱스란 인덱스 정보를 저장할 때 물리적으로 정렬해서 저장하는 방법

    **→ 조회 시에 인접블록을 연속적으로 읽기 때문에 조회 성능이 향상된다.**

- 파티션 기법

    데이터베이스에서 파티션을 사용하여 테이블을 분할

    **논리적으로는 하나의 테이블**이지만 **물리적으로는 여러 개의 데이터 파일**에 분산되어서 저장된다.

    - Range Partition

        데이터 값의 범위를 기준으로 파티셔닝

    - List Partition

        특정한 값을 기준으로 파티셔닝

    - Hash Partition

        해시 함수를 적용하여 파티셔닝

    - Composite Partition

        범위와 해시를 복합적으로 사용해 파티셔닝

    - 장점
        - 조회시 엑세스 범위가 줄어들어 조회 성능 향상
        - 데이터가 분할 되어있어 I/O 성능 향상
        - 각 파티션 파일이 물리적으로 분리되어 있어 각각 독립적으로 백업 및 복구 가능
    - 파티션 인덱스

        파티션 인덱스는 파티션 키를 이용해 인덱스를 만드는 Prefixed Index와 해당 파티션만 이용하는 Local Index등으로 나누어진다.

        - Global Index

            여러 개의 파티션에서 하나의 인덱스를 사용한다.

        - Local Index

            해당 파티션 별로 각자의 인덱스를 사용한다.

        - Prefixed Index

            파티션 키와 인덱스 키가 동일하다.

        - Non Prefixed Index

            파티션 키와 인덱스 키가 다르다.

- 분산 데이터베이스

    물리적으로 떨어진 데이터베이스를 네트워크로 연결하여 단일 데이터베이스 이미지를 보여 주고 분산된 작업 처리를 수행하는 데이터베이스

    반대로 물리적 시스템에 데이터베이스 관리 시스템을 설치해 여러 사용자가 데이터베이스 관리시스템에 접속해 사용하는 구조는 중앙 집중형 데이터베이스라고 부른다.

    - 분산 데이터베이스의 투명성

        이를 사용하는 고객은 시스템이 분산되어 있는지 알지 못하며 자신만의 데이터베이스를 이용하는 것으로 인식되어야한다.

        → 데이터베이스의 투명성

        - 투명성의 종류
            - 분할 투명성

                고객은 하나의 논리적 릴레이션이 여러 단편으로 분할되어 각 단편에 사본이 여러 시스템에 저장되어있는 사실을 알지 못해야한다.

            - 위치 투명성

                고객이 사용하려는 데이터의 저장 장소를 명시할 필요가 없다.

                어느 위치에 있더라도 동일한 명령으로 데이터에 접근 가능해야한다.

            - 지역사상 투명성

                지역 DBMS와 물적 데이터베이스 사이의 사상이 보장됨에 따라 각 지역 시스템 이름과 무관한 이름 사용이 가능하다.

            - 중복 투명성

                데이터베이스 객체가 여러 시스템에 중복되어 존재해도 사용자와 무관하게 데이터의 일관성이 유지된다.

            - 장애 투명성

                데이터베이스가 분산되어 있는 각 지역의 시스템이나 통신망에 이상이 발생해도 데이터 무결성은 보장된다.

            - 병행 투명성

                여러 고객의 응용 프로그램이 동시에 분산 데이터베이스에 대한 트랜잭션을 수행하는 경우에도 결과에 이상이 없다.

    - 분산 데이터베이스 설계 방식
        - 상향식 설계

            지역 스키마 작성후 향후 전역 스키마를 작성해 분산 데이터베이스를 구축한다.

        - 하향식 설계

            전역 스키마 작성후 향후 지역 사상 스키마를 작성해 분산데이터베이스를 구축한다.

            ![[KakaoTalk_Image_2022-09-01-14-15-14.jpeg]]

            기업 전체의 전사 데이터 모델을 수렴하여 전역 스키마를 생성, 이후 각 지역 별로 지역 스키마를 생성 하여 분산 데이터베이스를 구축한다.

            여러 종류의 벤더를 이용할시엔 ODBC, JDBC같은 데이터베이스 미들웨어가 필요하다.

    - 장단점
        - 장점
            1. **신뢰성과 가용성이 높다.**
            2. 분산 데이터베이스가 병렬 처리를 수행하기 때문에 **빠른 응답**이 가능하다.
            3. 분산 데이터베이스를 추가하여 **시스템 용량 확장**이 쉽다.
        - 단점
            - 데이터베이스가 여러 네트워크를 통해서 분리되어 있기 때문에 **관리와 통제가 힘들다.**
            - **보안관리가 힘들다.**
            - **데이터 무결성 관리가 힘들다.**
            - 데이터베이스 **설계가 힘들다**.
- 좋은 데이터베이스 모델링의 요건
    - 중복 배제
    - 비즈니스 룰
    - 완전성

### 트랜잭션 [Transaction]

데이터를 조작하기 위한 하나의 논리적인 작업 단위

여러 개의 쿼리들을 하나의 작업으로 묶어서 수행하는 단위를 의미하며 애플리케이션 백엔드 개발자에겐 필수적으로 알아야하는 원칙이 있다.

- ACID 원칙
    - 원자성 [Atomicity]

        여러 개의 쿼리들은 한번에 성공하거나 하나라도 실패하면 모두 복구해야한다.

        ALL or NOTHING 원칙이라고도 한다.

    - 일관성 [Consistency]

        모든 트랜잭션은 일관성있게 데이터베이스 상태를 유지해야한다.

    - 격리성 [Isolation]

        모든 트랜잭션은 트랜잭션끼리 영향을 미쳐서는 안된다.

        특히 동시에 같은 데이터를 수정하도록 만들면 데이터 정합성에 문제가 생긴다. 이때 격리 레벨을 조정해 격리성을 높혀 락킹등을 이용해 순차적으로 수정하게끔 만들어주면 되지만 동시처리 성능에 문제가 발생한다.

    - 지속성 [Durability]

        한번 성공한 트랜잭션은 데이터베이스에 로깅이 되어야한다. 운영 도중 문제가 발생해 데이터가 날라가더라도 트랜잭션 로그를 통해 복구가 가능해야한다.


### NULL

NULL은 존재하지 않음, 값이 없음을 뜻한다.

**NULL이 포함된 컬럼(수직) 계산은 NULL을 무시하고 계산한다! Predict(Where문)시에도 마찬가지다!**
