# File Organization

DBMS가 페이지의 위치를 쉽게 찾기 위한 방법으로 일종의 파일을 구성하는 방법이다.

### Heap File Organization

가장 베이직한 구성방법

어떤 페이지가 존재하고 어떤 페이지가 여유공간이 있는지 추적하기 위해 메타데이터가 필요함

- Heap File

    튜플이 임의의 순서로 저장되는 오더링 없는 페이지 컬렉션

- Linked List
    - 특징
    1. 헤더 페이지에는 사용가능한 페이지 리스트, 데이터 페이지 리스트가 있으며 각 페이지는 2개씩 포인터를 지니고 있다.

        ⇒ [앞 페이지 포인터, 뒷 페이지 포인터 = 앞뒤로 연결된 링크드 리스트]

    2. 각 페이지는 사용가능한 슬롯(free slot)의 개수를 추적한다.
    3. DBMS에서 특정 페이지를 찾을땐 데이터페이지를 처음부터 찾아야 한다.

        ⇒ 대용량 데이터 저장에는 용이하나 탐색에는 잼병인 주요 원인

- Page Directory

    데이터 페이지의 위치를 추적하는 특수 페이지를 관리하는 기법

    - 특징
        1. 페이지 별 사용가능한 슬롯(free slot)의 개수를 기록한다.
        2. DBMS는 각 데이터 페이지와 디렉토리 페이지가 동기화 되는지 확인해야한다.
- 장단점
    - 장점
        - 대용량 삽입에 유리하다.
    - 단점
        - 탐색, 수정이 불리하다.
        - 대규모 데이터베이스에는 불리하다.

### Sequential / Sorted File Organization

순차적으로 파일을 저장하는 자료구조를 구성하는 방법

- Pile File Method

    순차적으로 레코드를 저장하며 추가할 때는 맨 뒤에 넣고 삭제할 때는 처음부터 탐색후 지울 레코드를 표시하는 방식

- Sorted File Method

    항상 맨 끝에 삽입후 재정렬하는 방식, 정렬 기준은 기본키같은 컬럼을 기준으로 잡는다.

- 장단점
    - 장점
        - 대용량 데이터를 삽입할때 용이하다.
    - 단점
        - 탐색을 순차적으로 풀스캔을 해야하므로 불리하다.
        - 순차 파일 방식은 애초에 매번 재정렬을 하므로 삽입 할때마다 불리하다.

### Hashing File Organization

해싱 알고리즘을 레코드의 일부를 인풋값으로 넣고 나온 아웃풋 값을 기준으로 데이터를 저장하는 방식

- 구성
    - 데이터 버킷

        레코드가 저장되는 메모리 위치, 일종의 단위로도 사용된다

    - 해시 함수

        모든 검색 키 집합을 실제 레코드 주소에 매핑한다.

        보통 기본키를 사용해 데이터 블록 주소인 해시 인덱스를 생성한다.

    - 해시 인덱스

        길쭉한 전체 해시 값중 일부 prefix가 해시 인덱스이다.

        모든 해시 값은 해시를 계산하는데 사용되는 비트 수의 depth값을 가지고 있다.

        이 비트는 $2n$개의 버킷을 처리할 수 있다.

        이 모든 비트가 소모되면 depth값이 선형으로 증가하며 버킷이 2번 할당된다.

- 해싱 알고리즘 - Division Method

    나눗셈의 나머지 부분의 의존하는 방식이다.

    이것 말고도 쉬운방식부터 정말 복잡한 방식까지 종류가 방대하다.

    - 예시

        테이블의 사이즈가 10, 레코드가 52, 68, 99, 84 일때,

        각각 52%10, 68%10, 99%10, 84%10의 결과인

        2, 8, 9, 4를 인덱스로 가지는 방식


- 정적 해싱

    검색 키 값이 제공되면 항상 동일한 주소 값을 반환한다.

    - 예시

        $mod(5)$, `student_id = 104` 일때

        항상 동일한 주소 4를 반환한다.

        이 버킷 주소는 바뀌지 않으므로 항상 동일한 버킷 분포를 유지한다.

        - 동작
            - 삽입

                `student_id = 104` 와 같은 키를 넣고 해시 인덱스를 얻은 뒤 이 인덱스 위치에 레코드를 넣는다.

            - 탐색

                `student_id = 104` 를 동일한 해시 함수로 넣어 해시 인덱스를 얻은 뒤 해당 위치로 이동해 값을 찾는다.

            - 업데이트

                탐색 과정을 거쳐 해당 위치의 레코드를 업데이트한다.

            - 제거

                탐색 과정을 거쳐 해당 위치의 레코드를 삭제한다.

    - 충돌시 해결기술

        해시 함수결과 인덱스가 중복되어 생성될 시 이를 충돌이라고 한다.

        - Open Hashing
            - Linear Proving

                충돌 상황시 그 다음 사용가능한 버킷에 레코드를 저장하는 방식

                - 예시

                    레코드 키를 해시 함수를 통해 계산하여 나온 해시 인덱스가 중복으로 나왔을때(충돌 상황)

                    해당 레코드를 기존의 인덱스 데이터 블록(버킷)의 다음 데이터 블록에 저장한다.

        - Closed Hashing
            - Open Addressing
                - Chain

                    데이터가 있는 추가 필드인 체인을 도입한 방식

                    - 예시

                        레코드 키를 해시 함수를 통해 계산하여 나온 해시 인덱스가 중복으로 나왔을때(충돌 상황)

                        해당 레코드를 기존의 인덱스 데이터 블록 뒤에 이어붙인다.

                        이 상황은 링크된 리스트에 의해 유지되는 두 개의 레코드가 있다고 보는 것

                - Quadratic Probing

                    충돌 상황시 그 다음 사용 가능한 다른 버킷에 레코드를 저장하는 방식, 선형 프로빙과 비슷하지만 이차 함수를 사용해 지수값을 조금씩 변화시켜 사용가능한 레코드를 찾는 방식이다.

                    - 예시

                        `H(key) = (H(key) + x*x) % table_size` , `x = 0` ,

                        레코드 키를 해시 함수를 통해 계산하여 나온 해시 인덱스가 중복으로 나왔을때(충돌 상황)

                        이때 x의 값을 +1하여 다시 해시 인덱스를 계산후 이때 사용가능하면 이 데이터블록에 저장한다.

                - Double Hashing

                    충돌 상황시 두 개의 해시 함수를 사용하는 기술이다.

                    - 예시

                        `H1(key) = key % table_size`

                        `H2(key) = P - (key mod P)`

                        여기서 P는 해시 테이블 보다 작은 소수이다.

                        만약 충돌 발생시 해시 테이블보다 작은 소수를 사용해 H2를 계산하고 H1결과에서 카운팅을 하여 더한다. 이때 나온 결과를 해시 인덱스로 사용하는 방식이다

- 동적 해싱

    정적 해싱의 단점은 데이터베이스의 크기가 늘어남에 따라 버킷의 크기가 동적으로 늘거나 줄거나 하지 않는 점이 있다.

    동적해싱은 레코드의 길이에 따라 데이터 버킷을 동적으로 늘리고 줄이는 해싱 방법이다.

    - 예시

        레코드 1,2,3 데이터 블럭 인덱스 0,1

        해시 함수 결과는 비트로 나오며 결과의 첫 Prefix 비트만 가지고 각 인덱스를 넣는다고 했을때,

        레코드 1,2는 채워지지만 레코드 3은 들어갈수 없다. 이때 prefix의 범위를 2개로 늘리고 데이터 블럭은 총 00, 01,10, 11 이렇게 사용 할수 있도록 동적으로 범위를 늘려 레코드 3을 넣는 방식이다.


### B+ tree File Organization

자식을 3명 까지 가질 수 있는 트리를 이용하여 각 인덱스를 저장하는 방식이다.

모든 데이터는 리프 노드에 저장되며 각 중간 노드는 리프 노드의 포인터 역할을 한다.

이 B+ 트리는 BST, 즉 이진 트리와 비슷하지만 자식이 단 2명인것과 달리 2명 이상의 자식을 가질 수 있어서 다르다.

- 장단점
    - 장점
        - 모든 레코드가 리프노드에만 저장되며 순차 링크드 리스트로 정리되기 때문에 탐색이 아주 빠르며 쉽다.
        - 크기에 제한이 없어 동적으로 크기가 줄거나 늘어날 수도 있다.
    - 단점
        - 정적 테이블에는 비효율적이다.

### DBMS ISAM

각 레코드의 기본 키를 파일에 저장하는 방식이다.

각 인덱스는 기본키를 사용해 생성이 되며 각 레코드와 매핑이 되는 방식이다.

인덱스에는 파일 안의 레코드의 주소를 가지고 있다.

- 장단점
    - 장점
        - 기본키에 대한 범위 검색이 가능하다. 만약 기본키를 시간순으로 잡고 어제부터 오늘까지의 레코드를 들고 온다면 간단하게 들고 올수 있다.
        - 각 레코드에는 데이터 블록 주소가 있으므로 빠르게 탐색이 가능하다.
    - 단점
        - 데이터 베이스에는 인덱스 테이블을 따로 마련해야하니 더 큰 추가 공간을 필요로 한다.
        - 이 인덱스 테이블은 메모리에 존재 하므로 일부 컬럼을 삭제한다면 이 공간을 해제해주어야한다. 안하면 리소스 릭으로 이어진다.
        - 새 레코드 삽입시 파일을 재구성해야한다.

### DB Cluster

두 개이상의 레코드가 동일한 파일에 저장하는 경우를 클러스터라고 한다.

이런 파일에는 동일한 데이터 블럭에 두개 이상의 테이블이 존재하며 이러한 테이블을 매핑하는 키 속성은 한번만 저장된다.

![[2. Area 🔥/Database 💾/1. Resource/File Organization/Untitled.png]]

이때 이 조인의 기준이 되는 키를 클러스터 키라고 부른다.

- 클러스터 구성 종류
    - Indexed Cluster

        클러스터 키로 그룹화하여 저장한다. 위의 사진이 그 예이다.

    - Hash Cluster
    Indexed Cluster와 비슷하지만 저장을 할때 인덱스를 해시 함수를 거쳐 해시 키 값을 클러스터 키 대신 저장한다.
- 장점
    - 조인하여 조회하는 경우가 잦은 경우 탐색비용이 많이 줄어든다.
    - 1:M 매핑이 많았던 경우 유리하다.
- 단점
    - 매우큰 대용량 데이터베이스에서 효율이 적다.
    - 조인 조건이 변경되면 더 오래 걸릴 수도 있다.
    - 1:1 매핑이 잦은 경우 별 효과가 없다.
