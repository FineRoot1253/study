> 이 글은 누군가 봐도 좋겠다는 생각에 적게 된 내 공개용 일기 겸 메뉴얼이다.

## 히스토리> [[🥊 Notion vs Obsidan]]

## 필요 환경
+ git
+ obsidian

## 내 요구사항 
1. 기존의 볼트인 현재 부모 레포지터리는 `private`으로 숨길 것
	내 기존 볼트에는 개인적인 자료가 많아 이것을 통째로 공개하는 것이 불가능했다.
2. 공개하고 싶은 하위 디렉토리만 `public` 레포지터리로써 공개가 가능할 것
	+ 특징
		+ 보안적인 문제를 감안하면 **작업 로그(커밋 로그)가 없는 bare 레포지터리로 올려야**한다. 
		+ `subtree`를 작업 레포지터리인 부모 레포지터리에 추가하게 되고 나서 ** `add`, `pull`, `push`등을  할때 커밋 로그를 추적하지 못하도록 `squash `플래그로 커밋 로그를 합쳐야한다.** 
		  그래야 작업 레포지터리에 하위 레포지터리 작업내역이 섞여 혼란이 오는 일이 없고 실수로 비밀번호나 전화번호와 같은 개인정보를 실수로 푸시했을 때 삭제 후 다시 푸시하여 덮어씌워도 추적이 불가능해 보안유지가 가능하다.
	  + bare 레포지터리는 `.gitignore`도 사용이 불가능하다. 따라서 공개용 디렉토리를 따로 구성하는 것이 편하게 작업이 가능하다. 
		다만 이렇게 되면 개인 볼트에는 같은 내용의 파일과 디렉토리 구성이 늘어 총 다뤄야하는 파일 양은 **작업용 볼트에서 작업하는 파일들**과 **공개용 디렉터리에 올려 공개용 레포지터리에 push할 파일들**까지 같은 파일과 구성이 총 2배가 되며 용량적으로 좀 불편해질 수 있다.
		+ 하위 디렉토리를 배포한 뒤 그 하위의 디렉토리를 다시 공개용 디렉토리로 배포를 한다면 이 구성은 상당히 더 복잡해지고 형상관리가 복잡해진다. 따라서 이 작업은 쉘 스크립트로 자동화를 해두는 것을 매우 추천한다.
3. 기존의 작업은 부모 레포지터리의 .git 폴더의 작업 내역을 통해 진행할 것(부모의 깃 레포지터리에 의존)
4. 공개된 하위 public 레포지터리는 오로지 공개용 md 보관소로만 적용될 것

## 볼트 구성 방법
1. `submodule`
	서브모듈 방식은 각 하위 볼트를 각각 프로젝트처럼 관리 할 수 있다.
	허나 각 하위 볼트가 각각 수정되면 알아서 부모 레포지터리에서 pull을 해야한다. 즉, 각각 버전관리를 해줘야한다.
	나는 다른 하위 레포지터리와 상위 레포지터리를 각각 버전관리를 하는 것이 싫어서 이 방식을 택하지 않고 아래의 `subtree` 방식으로 진행하였다. 물론 `subtree`도 변경사항은 각각 배포해야하지만 말이다.

2. `subtree`
	상위 레포지터리는 하위 레포지터리의 버전관리에 신경을 쓰지 않아도 된다. 그저 내부에 포함된 파일정도이다. 따라서 상위 원격 레포지터리는 `private`으로 구성하고 로컬에서 원하는 경로의 특정 디렉토리만 하위 레포지터리로 만들고 `subtree`로 `split`하여 `public`으로 다른 레포지터리로 구성할 수 있다.
	보통 팀원 공유용 코드만 따로 레포지터리에 배포할때 이런 방식을 사용한다.
	실제로도 깃의 흐름을 보면 새 브랜치를 만들어서 나누는 것처럼 보인다. 이러한 방식이 `subtree`이다.

### 공통점
1. 둘 다 한 레포지터리에 서브 레퍼지토리를 포함시키려는 기능이다.
2. 둘 다 bare 레포지터리를 사용하지 않으면 커밋 이력을 활용할 수 있다.
3. 둘 다 하위 레포지터리를 add, push, pull등 적용방식은 똑같이 추가적인 커맨드를 요구한다.

### 차이점
1. submodule은 외부 레포지터리의 ref의 head 값을 포인터처럼 지녀 포함 시키는구조이다.
	   submodule은 프로젝트를 clone하면 별개로 한번 더 외부에서 clone을 진행한다.
2. subtree는 외부의 레포지터리를 통째로 복사해서 한 레포지터리안에 포함 시키는 구조이다.
	subtree는 한번 clone하면 외부의 레포지터리를 이미 통째로 가지고 있어서 한번 더 외부에서 clone을 진행하진 않는다.
3. subtree는 한번 부모 레포지터리인 작업 레포지터리에 add 되면 add된 하위 레포지터리의 Push, Pull을 제외하고 나머지 동작에 특별한 커맨드가 없다.
4. submodule은 3의 사항을 추가로 더 많은 커맨드로 제어를 해야한다. 
	하위 레포지터리를 ref 포인터로 가지고 있다가 clone으로 땡겨온 형태의 구조이기 때문이다.

## subtree 구성 방법

<br>

###  처음 옵시디언을  사용하는 경우
> https://yeonyeon.tistory.com/169

위의 링크대로 진행을 한 뒤 부모 레포지터리를 작업용 볼트로 잡으면 된다.

이미 레포지터리에 볼트를 올린 상태여도 앞으로 나눌 볼트가 많지 않고 더이상 나눌 가능성이 적은 경우 이 방식으로 레포지터리를 구성한 뒤 기존 자료나 텍스트를 옮기는 것도 추천한다. (일종의 볼트 to 볼트 이사개념)

### 이미 한 레포지터리에 볼트를 올린 상태이고 이 상태에서 구성하는 경우
이 방식은 이미 깃허브에 올라간 작업 레포지터리에서 작업을 진행하는 것이다. (이미 볼트가 있고 깃허브에 `push`한 경우)

본인이 후자 방식을 택하는 이유를 꼽는다면 앞으로 만들어나갈 레포지터리를 전부 `public`하게 별개의 서브 레포지터리로 공유하고 싶다는 목적이 있었고 이 방법 저 방법 둘러본 결과, 내 목적을 달성하는데 최적인 방법이라고 생각한다.


## 적용 방법

cli 기준으로 설명을 이어가겠다.
1. 볼트 경로를 이동한다.
2. 공개용 디렉토리들을 보관할 디렉토리를 만든다.
	+ 예시
		![[스크린샷 2023-03-31 오전 10.26.43.png]]
	이 디렉토리는 공개용 디렉토리(레포지터리들)을 보관하며 초기 push 이후 다시 작업 레포지터리 안에 add할때 이 디렉토리에 add를 하게 된다.
3. 공개용 디렉토리 내부에 공개용 볼트를 만든다. 나는 여기서 내 공부정리용 볼트인 Study를 bare 레포지터리로 초기화했다. 
	https://www.geeksforgeeks.org/bare-repositories-in-git/
	+ 예시
		![[스크린샷 2023-03-31 오후 1.19.39.png]]
4. 이 디렉토리에 기존 작업 레포지터리인 상위 볼트에 있는 공부 정리용 디렉토리에서 과목별 디렉토리를 공개할 디렉토리만 하나씩 분리한다.
	+ 예시
		+ 현재 디렉토리 상태
			+ Obsidian Vault
				- Study
					작업 중인 공부 정리 디렉토리
				- Shared
					- Study
						공개용 공부 정리 디렉토리
						+ 방송통신대학교
							비공개
						+ Computer Science
						+ Database
						+ Design Pattern
						+ Flutter
							비공개
						+ Infrastucture
						+ Languages
						+ Mathematics
						+ My Coding Standard
						+ Nodejs
							비공개
						+ OS
						+ Software Architecture
						+ Spring
						+ Study Plan
							비공개
						+ Web
						+ Readme.md
		
5. 비공개로 정한 디렉토리들을 제외하고 모든 디렉토리를 기존 브랜치에서 분리해서 추가한다.
	+ 플래그 설명
		+ -P
				prefix로써 디렉토리 경로를 적으면 된다. 이때 잘못 적으면 브랜치에 엉뚱한 경로의 파일과 디렉토리를 저장해버리니 조심하자.
			+ -b
				브랜치의 이름을 지정하는 플래그
	+ 예시
		``` Shell
		git subtree split -P Study/'Computer Science' -b computer-science
		git subtree split -P Study/'Database' -b database
		...
		```
6. 각 디렉토리들을 3번에서 초기화한 디렉토리에 추가한다.
	+ 예시
		``` shell
		git push ./shared/Study computer-science:main
		git push ./shared/Study database:main
		...
		```
7. 6의 일련의 과정을 쉘 스크립트로 만든다. (이건 선택사항이다.)
8. 공개 디렉토리에 각 디렉토리를 생성해준다.
9. 깃허브 원격 레포지터리를 텅 빈상태로 생성한다.
10. 3의 목표 디렉토리로 다시 이동한 뒤 원격 레포지터리인 깃허브 링크를 추가하자.  `git remote add -m main study "https://~"` 
	+ 예시
				![[스크린샷 2023-03-26 오후 11.11.59.png]]
10. 목표 디렉토리를 원격 레포지터리에 푸시한다. `git push study main`
11. 최상위 볼트로 이동한 뒤 `rm -rf shared/Study`로 목표 디렉토리를 삭제한다.
12. 이곳 최상위 볼트에서 원격 레포지터리를 추가한다. `git remote add study "https://~"` 
13. 10에서 푸시한 공개용 레포지터리를 현재 작업 레포지터리의 하위 레포지터리(`subtree`)로써 등록하기 위해 12에서 등록한 해당 원격 레포지터리를 이용해 add 한다. `git subtree add -P Study study main`

+ 정리
	핵심은 공유 목표 디렉토리를 새로 만들어서 하던지 기존 디렉토리로 사용하던지 어찌됬던 공유 목표 디렉토리는 우선 공유용 원격 레포지터리에 푸시된 다음 삭제되어 없어진다.
	그래야 `git subtree add ~` 명령어로 하위 레포지터리를 등록할 수 있기 때문이다.