# 함수

## 함수란?

<aside>
💡 일부 작업을 수행하는 코드블럭

</aside>

### 사용법

```jsx
void functionA(){
	...
}

int functionB(){
	return something;
}

int* functionC(){
	return &something;
}

void functionD(int temp){
	...
}

void functionF(int* temp){
	...
}

void functionG(int& tempRef){
	...
}
```

### 특징

1. 함수는 특정 로직을 담는 그릇 역할을 한다.
2. 함수는 특정 값을 리턴을 할때는 값을 복사해서 전달한다.

    이때, 함수가 종료되면 지역변수들은 스택영역에서 사라지니 임시 메모리 공간에 값을 저장하고 이 값을 복사하는 방식이다.

3. 포인터를 리턴할 때는 함수 내부 지역변수의 주소 값을 전달하면 런타임 에러가 발생한다!

    포인터 리턴시 주의해야한다.

4. 함수 내부의 지역변수들은 스택영역 메모리에 올라간다.

    (참고로 for문 `{…}` 등도 특정 스택영역으로써 동작한다.)

    따라서 함수가 종료되면 지역변수들은 잠시 스택영역 메모리를 차지했다가 사라진다.

    그러므로 **함수에서 객체를 스택으로 생성하고 외부 스택프레임의 객체의 멤버로 저장하려하면 안된다.**

    실행흐름이 스택 프레임을 벗어나면 스택 프레임 내부에 만든 스택 객체는 소멸자를 호출한 뒤 사라지기 때문이다.

    이거 때문에 고생한 경험이 있으니 기본적으로 객체는 힙에 올리도록 코딩 스탠다드를 잡는 것이 맞다.


### 주의사항

1. call by value 코스트 계산
    - 예시

        ```cpp
        int execute(int a, int b){
        	return a + b;
        }

        int main(){
        	int a = 10;
        	int b = 20;
        	int result = execute(a, b);
        	return 0;
        }
        ```

    - 적당히 메모리 관점으로 봤을 때 (분명 생략되거나 틀린점이 있긴함)

        ```cpp
        int main(){
        	int a = 10;
        	int b = 20;
        	// 호출! 이때 호출 + 복사 코스트 추가된다.
        	{
        		int a = 10;
        		int b = 20;
        		return a + b;
        	}
        	// 결과 반환!
        	// 이때 결과로 스택에 있는 메모리가 날아가지만
        	// 임시 리턴 데이터가 메모리로 올라가고 이 메모리안에 들어있는 값이 복사된다.
        	int result = tempMemory;
        }
        ```

    - 설명
        1. 함수의 파라미터는 사실 해당 지역변수로 동작하며 메모리를 추가로 먹는다.

            즉, 파라미터가 여러개일수록,  큰 구조체 일수록 메모리를 더 먹게된다.

        2. 함수의 호출 코스트에는 파라미터가 존재한다면 복사 코스트가 항상 추가로 들어간다.

            즉, 파라미터가 여러개일수록, 큰 구조체 일수록 메모리를 더 먹게된다.

        3. 함수의 반환시 함수는 종료가 되며 함수의 스택 프레임에 있던 지역 변수는 전부 날아가게된다.

            그럼에도 불구하고 값을 반환할 수 있는 이유는

            이 반환 데이터를 임시 데이터 공간에 저장하고 이를 호출부에 복사하여 전달한다.

            이것을 **temporary object**라고 부른다.

    - 정리
        1. call by value 호출 비용 산정 정리

            size: 파라미터의 크기

            n: 파라미터의 개수

            return_type_size: 리턴타입 만큼의 크기

            - 함수 호출시 과정
                1. 파라미터를 현재 스택에서 각각 선언및 초기화를 한다. 이때, 복사 비용도 비례해서 들어간다.

                    즉, 생성비용 * (size * n) + 복사비용 * (size * n)

                2. 리턴을 하게 되면 리턴 타입 만큼의 임시 객체 메모리 비용과 복사비용이 들어간다.

                    즉, 생성비용 * (size * n) + 복사비용 * (size * n) + return_type_size * 생성비용 + return_type_size * 복사비용


                간단히 대강 정리하면

                ∴ 호출및 복사 코스트: ((size * n) + return_type_size)(생성비용 + 복사비용)


            매번 함수 호출시 ((size * n) + return_type_size)(생성비용 + 복사비용) 만큼 코스트가 소모된다.

        2. 이 비용을 줄이기 위해서 C 의 경우 포인터, C++의 경우 레퍼런스를 사용한다. [call by reference]
            - 예시

                파라미터 개수는 1로 고정되니

                총비용: ((size * 1) + return_type_size)(생성비용 + 복사비용)

                =(size + return_type_size)(생성비용 + 복사비용)

                = (size + return_type_size)(생성비용 + 복사비용)

                따라서, (size + return_type_size)(생성비용 + 복사비용) 이렇게 줄일 수 있다.

                간단하게 보면 O(n)과 O(1)의 차이이다.

2. 포인터나 레퍼런스를 함수 파라미터로 사용시 **단순 값 전달을 위해서 쓴다면 `const`**를 붙여주는게 좋다.

    `const`를 붙여주게 되면 이 **참조값 내부의 변경은 허용하지 않는다**는 의미가 된다.
