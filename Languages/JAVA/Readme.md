# JAVA

[[코드]]

[[PPT,회의록,참고자료]]

[[자바의 정석/Readme]]

## Articles

- ZGC

    [ZGC에 대해서](https://www.blog-dreamus.com/post/zgc%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C)

- 숫자처리

    [OKKY | [자바의 숫자표현] 어디까지 가능할까 !!!](https://okky.kr/article/16099)

    + DecimalFormat도 주의할 것, 유럽은 소수점을 , 으로 표현한다!!

    → DecimalSeparator를 고정시켜서 대응 할 것!


## JVM

[[JVM]]

## Java Beans

데이터 표현 목적으로 사용하는 클래스, 일종의 DTO, VO와 같은 모델 클래스를 의미한다.

주로 JSP에서 사용되며 톰캣과 더불어 사용되는데 Spring 사용시 그닥 쓸일은 없다.

### Java Bean vs Spring Bean

자바 빈은 위의 서술한대로 데이터 표현 목적으로 사용되는 클래스이며

Spring의 빈은 Ioc 컨테이너에서 관리하는 객체를 의미한다.

이 둘 차이점을 명확히 이해해야 톰켓 공부하다 넘어올 때 안 헷갈린다.

## JDBC

자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API

1997년 출시된 굉장히 오래된 기술, 직접 사용하기엔 복잡해 이를 편리하게 사용하기 위해 SQL Mapper, ORM 등이 등장했다.

각 디비 벤더마다 디비 접근 스펙이 다르기 때문에 디비 접근 로직을 간단히 사용하기 위해 이 부분만 추상화를 하여 각 구현코드를 따로 붙이는 필요성이 있었기 때문에 등장하였다.

- 사용법

    JDBC 인터페이스와 사용하는 DB 드라이버(구현체 라이브러리)를 각각 다운받아 사용한다.

- 공통 표준 인터페이스
    - `java.sql.Connection`

        커넥션 (연결)

    - `java.sql.Statement`

        SQL을 담은 내용 (구문)

    - `java.sql.ResultSet`

        SQL 요청 응답 (반환)

- 구현체 라이브러리 접근 방식
    1. 등록된 라이브러리의 드라이버 들에게 getConnection의 파라미터로 받은 URL을 넘긴다.
    2. 각각 라이브러리의 등록된 드라이버들은 이 URL의 prefix에 적힌 벤더명을 보고 내가 돌릴 수 있는 URL인지 판단한다.
    3. 해당되는 드라이버는 커넥션을 획득해서 클라이언트에 던져준다.
- JDBC CRUD 구현 방법
    1. try - catch - finally를 먼저 만들어준다.
    2. insert into sql 구문 문자열을 만들어준다.
    - try 구문
        1. Connection을 생성한다(가져온다).
        2. insert into sql 구문 문자열을 활용해 PrepareStatement를  생성한다.
        3. PrepareStatement 객체에 파라미터 바인딩을 해준다.
        4. PrepareStatement 객체를 실행한다.
            - executeUpdate()

                Insert, Update, Delete시 사용

                리턴값은 영향을 받은 Row Count int값이다.

            - executeQuery()

                select시 사용

                리턴값은  ResultSet이다.

                - ResultSet

                    rs.next()를 한번씩 호출하여 cursor를 이동시켜 레코드의 각 로우를 접근하는 데이터 구조이다.

                    기본적으로 while문에 넣어서

        5. 결과를 리턴한다.
    - catch 구문
        1. 에러로그를 찍는다.
        2. 예외를 던진다.
    - finally 구문

        **이 구문에서 반드시 리소스를 회수 해야한다.** 그러기 위해 **각 객체의 close 메서드 수행중 예외가 터져도 나머지 객체들의 리소스를 회수 하기 해야한다.**

        1. private한 close 처리 메서드를 만들어 준다.
        2. close 처리 메서드를 호출한다.

        참고로 **SpringFramework에 JdbcUtils내부에 close관련 메서드를 사용하면 훨씬 깔끔하고 안전하게 해제가 가능하다.**

- 구현시 주의사항
    - PreparedStatement를 통해 파라미터 파인딩을 써야하는 이유는 SQL Injection 공격을 예방하기 위함이다.
    - 리소스를 회수하지 않으면 커넥션 풀이 메마르는 커넥션 누수 현상이 발생한다. 반드시 회수해야한다.

## DataSource

커넥션 획득 방법을 추상화한 인터페이스

CP 라이브러리 또한 DB 벤더들처럼 종류가 여러가지이고 커넥션을 매번 생성하는 방식에서 CP를 사용하는 방식 두 가지를 섞어서 쓰는등, 구현코드를 단일화하기 위한 방법이다.

### DriverManagerDataSource

매번 새 커녁션을 들고 오는 DataSource

동작 방식 DriverManager와 동일하지만 구현은 다르다.

**설정과 사용을 분리한 형태를 가지고 있다.**

### HikariDataSource

HikariCP를 사용해 커넥션 풀을 들고 오는 DataSource이다.

다른 CP 라이브러리를 넣으면 해당 CP DataSource 구현체도 있다.

그거 쓰고 싶으면 그거 쓰면된다.

- 특징
    1. CP를 로딩하는데 걸리는 작업은 비동기로, 다른 멀티스레드에서 동작하게끔 구현되어있다. ⇒ 기존 애플리케이션 실행속도에 영향을 주지 않게 된다.
    2. 커넥션 풀이 채워지지 않은 상태에서 커넥션을 획득하려는 경우 커넥션 풀이 채워질때까지 약간 기다린다.
    3. 풀사이즈보다 더 많은 요청이 들어오면 커넥션 풀이 비워질때까지 기다린다. 디폴트는 30초인데 이것을 10초정도로 줄이는게 UX 적으로 좋다.

        기본적으로 TPS<커넥션 waitTime 이며 이것이 넘어가는 순간 장애가 발생했다는 것이다.

    4. 내부 Connection 객체는 동일하지만 레핑된 프록시는 매번 생성되서 반환된다.
- 사용법
    1. 기존 DriverManager 방식에서 dataSource를 주입받아 여기서 커넥션을 획득하도록 수정


## Exception

[[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-02_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.36.42.png]]

- Object

    최상위 부모 객체

- Throwable

    최상위 예외

- Error

    언체크 예외

    메모리 부족 (OutOfMemory, OOM), 심각한 시스템 오류와 같이 애플리케이션에서 복구 불가능한 시스템 예외, 애플리케이션 개발자가 잡으려고 해서는 안되는 예외

    - 특징

        상위 예외를 catch로 잡으면 하위 예외까지 instanceof로 잡히게 된다.

        ⇒ **즉, Throwable로 예외를 잡지 않는 이유는 Error까지 예외로 잡아버리기 때문이다.**

- Exception

    체크 예외

    애플리케이션 로직에서 사용할 수 있는 실질적인 최상위 예외

    **RuntimeException을 제외한 예외한 모든 예외는 체크 예외이다.**

- RuntimeException

    언체크 예외

    컴파일러가 체크 하지 않는 언체크 예외이다.

    RuntimeException 포함 하위 예외 전부 언체크 예외이다.

    - 특징

        **주로 언체크 예외를 두고 런타임 예외라고 부르는 경우가 많다.**


### 예외 기본 규칙

예외는 폭탄 돌리기와 같다. **처리가 불가능하면 밖으로 던져야(Throw)한다.**

예외를 처리하지 못하면 호출한 곳으로 예외를 계속 던지게 된다.

- 예외를 처리하지 못하고 main까지 계속 던지게 되는 경우

    예외로그를 출력하고 시스템이 종료된다.

    ⇒ 웹 애플리케이션의 경우 서버가 죽으면 안되기 때문에 was가 해당 예외를 받아서 처리한다.

    ⇒ 주로 사용자에게 개발자가 지정한 오류 페이지를 보여준다.


### 체크 예외

Exception과 그 하위 예외는 모두 컴파일러가 체크하는 체크 예외이다.

RuntimeException이 예외 중에서 예외이다.

- 특징

    체크 예외는 잡아서(catch) 처리하거나 밖으로 던지도록 선언해야한다.

    ⇒ 이러지 않을 경우 컴파일오류를 뱉는다.

- 장단점

    잡아서 처리가 불가능하다면 `throws 예외` 가 필수적으로 요구된다.

    불가능 하다면 컴파일 오류를 뱉으며 이에 장단점이 존재한다.

    - 장점

        개발자가 실수로 예외를누락하지 않도록 컴파일러를 통해 문제를 잡아주는 훌륭한 안전 장치이다.

    - 단점
        1. 개발자가 모든 체크 예외를 반드시 잡거나 던지도록 처리해야 하기 때문에, 너무 번거로운 일이 된다. 크게 신경 쓰고 싶지 않은 예외까지 모두 챙겨야하며 추가로 의존 관계에 따른 단점도 존재한다.
        2. WAS - Controller(Handler) - Service - Repository 그림에서 Repository에서 나온 예외는 WAS에서 처리할 수 밖에 없어 **각 예외를 모든 레어어에 걸쳐서 던져야한다. ⇒ 의존성 문제**

            ⇒ SQLException, ConnectException과 같은 체크예외는 애플리케이션 단에서 처리가능한 수준이 아니기 때문이다.

            ⇒ 따라서 이런 예외는 WAS에서 처리를 해야한다.

            ⇒ 거기다 이런 예외에 대한 오류 페이지는 그냥 500으로 처리해 보여주어야한다. 데이터베이스에 문제가 있다는 상세 내용을 띄워봐야 고객은 알지 못하는게 당연하며 보안에 문제가 될 가능성이 크다.

            ⇒ 이런 경우는 별도의 오류 로그를 남기고 모니터링 인프라쪽에 미리 메일, 알림등을 남겨 개발자가 전달 받을 수 있도록 해야한다. 만약 이런 SQLException, ConnectException과 같은 오류가 발생했다는 것은 다른 유저도 수정본 배포전까지 계속 이런 오류를 겪을 것이기 때문이다.

        3. 대부분의 예외는 복구가 불가능하다. 일부 복구가 가능한 예외도 있지만 거의 없다.

            SQLException, ConnectException 이 두 체크 예외를 보면 둘다 애플리케이션 밖에서 일어난 문제 이므로 해결이 가능하지 않다.

            ⇒ 결론은 결국 공통으로 일관되게 처리해야하며 ControllerAdvice, RestControllerAdvice등이 스프링 MVC에서 사용되는 공통예외처리 방법이다.

    - 주의점

        throws Exception은 안티 패턴이다.

        잡을려는 주요 체크 예외를 걸러주질 못해서 던지는게 의미도 없어지는 아주 안좋은 습관이다. 이런 패턴은 사용하면 절대 안된다.

- 활용규칙
    1. 기본적으로 언체크(런타임) 예외를 사용하자
    2. 체크 예외는 비즈니스 로직상 의도적으로 던져야하는 예외에만 사용하자

        이 경우는 해당 예외를 잡아서 반드시 처리해야하는 문제일 때만 체크 예외를 사용해야 한다.

        - 예시
            1. 계좌 이체 실패 예외
            2. 결제시 포인트 부족 예외
            3. 로그인 ID, PW 불일치 예외

        이런 경우에 100% 체크 예외를 만들어야하는 건 아니지만 계좌 이체 실패와 같은 매우 심각한 문제는 개발자가 실수로 놓치면 안된다고 판단해줄 수 있다.

        ⇒ 이런 경우에 체크예외를 걸면 컴파일러를 통해 예외를 충분히 인지 가능하기 때문이다.



### 언체크 예외

RuntimeException과 그 하위 예외는 언체크 예외로 분류된다.

컴파일러가 예외를 체크하지 않는다는 의미이다.

- **체크 예외와 차이점**

    **throws를 선언하지 않고 생략 가능하다.**

    **⇒ 자동으로 예외를 던진다.**

- **예외전환**

    체크 예외를 캐치한 후 새로 런타임 예외를 생성해 던지는 방식

    - 주의점

        **전환시 기존 체크 예외를 cause로 넣어서 던져야 스택 트레이스가 가능하다. 무조건 넣어줘야한다!!**

- 활용
    1. 복구 불가능한 대부분의 체크 예외를 예외 전환을 사용해 언체크 예외로 바꿔 던져 일관성이 있게 공통 처리하도록 만들수 있다.
    2. 체크 예외의 고질적인 문제인 레이어별로 체크 예외의 패키지에 의존하게 되는 문제를 해결 할 수 있다.
    3. **문서화를 무조건 잘해야한다. 다른 라이브러리나 패키지에 주석으로 @throws를 넣고 각종 런타임 예외를 명확하게 명시한 이유는 throws를 선언하지 않아도 런타임 예외는 생략이 가능하다. 예외를 어떻게 어느 위치에서 처리를 해줘야할지 알아야 하기 때문에 명시를 명확하게 잘 해놓는 것이다.**

### 예외 포함과 스택 트레이스

예외 전환시 cause로 넣어서 던져야한다. 이를 예외 포함이라고 부른다.

이때 가장 하위에서 먼저 발생했던 예외를 **Root Cause**라고 부른다.

- 주의점
    1. System.out에 스택 트레이스를 출력하려면 e.printStackTrace()를 호출하면 되지만 실무에서는 log를 사용해야한다.

        ⇒ log.info(”ex”,e); 이런식으로 쓰면 스택 트레이스가 출력된다.

        ⇒ log.info(”ex {}”,e.getMessage()); 이런식으로 메시지를 출력할 수도 있다.

    2. 예외 전환시 예외 포함을 까먹는다면 운영에서 Cause By 로 붙은 체크 예외 스택 트레이스를 정확하게 알수가 없어서 큰 문제가 발생한다.

        **⇒ 반드시 예외 전환시 예외를 포함 시켜주자!!!**


### 예외 추상화

체크예외를 포함한 체로 인터페이스를 만들면 해당 체크 예외를 인터페이스에 throws로 넣어줘야한다.

종속성을 해결하기 위해 인터페이스를 도입했지만 다시 특정 체크 예외에 종속적이게 되는 이 문제를 해결하기 위해 이전에 설명한 예외 전환을 사용해 런타임 예외를 활용해야한다.

### 데이터 접근 예외

SQLException은 체크 예외이나 오류코드로 각 오류의 종류를 나타낸다.

이를 이용해 같은 SQLException이여도 각각 다른 종류의 런타임 예외로 전환해줄 수 있다.

이를 활용해 복구 로직을 짜는 것이 일반적이다.

참고로 오류코드는 디비 마다 다 다르니 각각 확인해서 짜야한다.

- PostgreSQL 오류 코드

    [https://www.postgresql.org/docs/current/errcodes-appendix.html](https://www.postgresql.org/docs/current/errcodes-appendix.html)


## 스프링이 제공하는 데이터 접근 예외 클래스

[[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-03_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.02.52.png]]

스프링은 자주 발생되는 데이터 접근 예외들에 한해 일관된 예외 계층을 추상화하여 이미 제공중에 있다.

DataAccessException은 Trasient 여부에 따라 둘로 나뉜다.

### Trasient

SQL을 다시 시도했을 때 성공 가능성이 있는지의 여부

- NotTransient

    일시적이지 않다는 뜻으로 반복 실행해봐야 실패한다는 의미이다.

    - 예시
        1. SQL문법오류
        2. 데이터베이스 제약 조건 위배
- Transient

    일시적이라는 뜻으로 이 예외의 하위 예외는 동일한 SQL을 다시 시도했을 때 성공 가능성이 존재한다.

    - 예시
        1. 쿼리 타임아웃
        2. 락

### JDBC 반복 문제

- 문제의 기존 구조
    1. 커넥션 조회, 커넥션 동기화
    2. ‘PrepareStatement’ 생성 및 파라미터 바인딩
    3. 쿼리 실행
    4. 결과 바인딩
    5. 예외 발생시 스프링 예외 변환기 실행
    6. 리소스 종료

이 반복되는 구조를 탬플릿 콜백 패턴으로 단순화 한 것 = JDBCTemplate이다.

### JDBCTemplate
