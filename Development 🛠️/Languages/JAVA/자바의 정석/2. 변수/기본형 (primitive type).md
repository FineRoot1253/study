# 기본형 (primitive type)

## 논리형 - boolean

논리형 기본 타입은 boolean 하나 밖에 없다.

true와 false로 구성되며 default는 false이다.

주로 스위치, 대답등의 논리 구현에 사용되며

- **크기가 1 byte인 이유**

    1 bit만 있어도 될 것 같은 타입이지만 **자바에서 데이터를 다루는 최소 단위는 byte이기 때문**에
    1 byte가 boolean의 크기이다.


## 문자형 - char

문자형 기본 타입은 char 하나 밖에 없다.

단 하나의 문자만 저장가능하며 유니코드(정수)가 저장된다.

→ char 타입을 int 타입 변수에 명시적 형변환(int)을 거치면 저장이 가능한 이유이다.

- 크기가 2 byte인 이유

    유니코드를 사용하기 때문에 2byte를 필요로 한다.

    ### 예시

    ```java
    package ch2;

    public class CharToCode {
        public static void main(String[] args) {
            char ch = 'A';
            int code = (int) ch;

            System.out.printf("%c=%d(%#X)%n",ch, code, code);

            char hangulCh = '가';
            System.out.printf("%c=%d(%#X)%n",hangulCh, (int)hangulCh, (int)hangulCh);

        }
    }
    ```

    - 실행결과

        [[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-09-30_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.01.42.png]])

    - 특징

        A는 65, 가는 44032인것을 볼 수 있다 특히 저 유니코드를 그대로 리터럴로 char에 할당하면 할당이 가능하다

        ```java
        char ch = 0xAC00; // OK

        char ch = ‘\uAC00’; // OK
        ```


### 특수문자 다루기

일부 특수문자들은 표현 방법이 다르다.

- 특수문자 종류


    | 특수 문자 | 문자 리터럴 |
    | --- | --- |
    | tab | \t |
    | backspace | \b |
    | form feed | \f |
    | new line (line feed, LF) | \n |
    | carriage return, CR | \r |
    | 역슬래쉬(\) | \\ |
    | 작은 따옴표 | \’ |
    | 큰 따옴표 | \” |
    | 유니코드(16진수) 문자 | \u유니코드 (ex: char a = ‘\u0041’) |

    ### 예시

    ```java
    package ch2;

    public class SpecialCharEx {
        public static void main(String[] args) {
            System.out.println('\'');
            System.out.println("abc\t123\b456");
            System.out.println('\n');
            System.out.println("\"Hello\"");
            System.out.println("c:\\");
        }
    }
    ```

    - 실행 결과

        [[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-09-30_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.11.26.png]])


### char타입의 표현형식

- char 타입의 크기

    2 byte = 16 bit

- 표현 가능한 범위

    0 ~ 2^15-1 = 0 ~ 65535

- 같은 정수를 대입해도 출력하면 다른 이유

    ```java
    char ch = ‘A’;
    short s = 65;

    System.out.println(ch); // A
    System.out.println(s); // 65
    ```

    이것을 출력하면 결과는 값 그대로 출력되게 된다.

    **자바는 값의 타입을 통해 값을 표현하기 때문이다.**


### 인코딩과 디코딩 (encoding & decoding)

컴퓨터는 숫자밖에 모르기 때문에 숫자로 저장이 되고 이 숫자는 특정 규칙에 의해서 문자로 표현된다.
자바에서 이 규칙을 **유니코드**를 사용해 표현한다.

- 인코딩

    컴퓨터가 문자를 저장할 때 거치는 과정

    A → 65

- 디코딩

    컴퓨터가 저장한 문자(저장할 땐 숫자로 저장)를 꺼내서 문자로 표현하기 위해 거치는 과정

    65 → A

- 정리

    **인코딩을 어떻게 했는지 알아야 디코딩이 가능하다.**

    ⇒ **종종 인코딩 문제가 나오는 이유**

    ⇒ 만약 문자를 저장하는 과정( 인코딩 )중 사용한 코드 표를 몰라 디코딩시 엉뚱한 코드 표로 디코딩을 하게 되면 엉뚱한 문자로 변환되어 표시 되는 것이다.

    - 대표적인 한글 깨짐 케이스
        1. 이클립스(ISO-8859-1)에서 저장한 소스파일을 vscode(utf-8)에서 열었을 때 한글 주석이 깨져있는 경우
        2. html을 받았는데 인코딩을 중국어로 한채 저장하면 한글이 전부 깨진채로 나오는 경우

### 아스키(ASCII)

American Standard Code for Information Interchange, ASCII, 정보 교환을 위한 미국 표준 코드

128개(=2^7)의 문자 집합 (character set)을 제공하는 7비트 부호,

처음 32개의 문자는 인쇄와 전송 제어 전용으로 사용되는 제어 문자로 출력 불가능하며 마지막 제어 문자 DEL을 제외한 33번째 이후의 문자들을 출력할 수 있는 문자들로, 기호와 숫자, 영대소문자로 이루어져 있다.

0~9, 영어 대문자 A~Z, 영어 소문자 a~z순으로 저장되어 있어 프로그래밍시에 유용하게 사용된다.

### 확장 아스키(Extended ASCII)와 한글

- **확장 아스키**

    아스키는 7bit이기 때문에 1 bit공간이 남는다.
    이 1 bit 공간을 활용해서 문자를 추가로 정의한 것이 확장 아스키 코드이다.

    확장 아스키에 추가된 128개의 문자는 여러 국가와 기업에서 서로 필요에 따라 다르게 정의해서 사용한다.

    ISO(국제표준화기구)에서 확장 아스키의 표준을 몇 가지 발표했는데, 그 중 대표적인 것이 ISO-8859-1이다. 이 확장 아스키 버전은 ISO Latin 1 이라고도 부르는데 서유럽에서 일반적으로 사용하는 문자들을 포함하고 있다.

- **한글**

    확장 아스키로 표현 가능한 문자의 개수는 255개 뿐이라 한글을 표현하기에 턱없이 모자르다.
    그래서 생각한 것이 두 개의 문자코드를 한글로 표현하는 방법이다

    - **조합형**

        **초성, 중성, 종성을 조합하는 방식**, 거의 사용하지 않는 방식이다.

    - **완성형**

        확장 아스키의 일부 영역(162~254)에 해당하는 두 문자코드를 조합하여 한글을 표현

        현재 **‘완성형(KSC 5601)’에 없는 잘 안쓰이는 8822글자를 추가한 ‘확장 완성형(CP 949)’**이 사용

        이것이 **한글 윈도우에서 사용하는 문자 인코딩이다. (확장 완성형 한글 CP 949)**

        **한글 윈도우에서 작성된 문서는 기본적으로 CP949로 인코딩되어 저장**된다.


### 코드 페이지(code page, cp)

IBM이 자사의 PC에 확장 아스키를 도입하여 사용하기 시작할 때,
PC를 사용하는 지역이나 국가에 따라 여러 버전의 확장 아스키의 필요성이 대두되었다.

IBM은 이들을 **코드 페이지, CP**라 칭하고 각 코드 페이지에 **CP xxx**와 같은 형식으로 이름을 붙였다.
IBM은 MS와 같은 여러 업체들과 협력하여 코드 페이지를 만들어내고 공유했다.

한글 윈도우는 CP 949, 영문 윈도우는 CP 437을 사용한다.

### 유니코드(Unicode)

예전에는 같은 지역 내에서만 문서 교환이 이루워졌지만 현재는 인터넷이 발전함에 따라
서로 다른 지역의 다른 언어를 사용하는 컴퓨터간의 문서 교환이 활발해졌다.

이에 서로 다른 문자 인코딩으로 저장된 문서를 주고 받기 시작하니 위에 언급했던 문제들이 대두되기 시작했다.

이러한 어려움을 해소하기 위해 전 세계의 모든 문자를 하나의 통일된 문자집합으로 표현하고자 노력하였고
그 결과가 바로 **유니코드, Unicode**이다.

- 구성

    유니코드는 처음엔 모든 문자를 2 byte로 표현하려 했으나 2 byte로는 부족하여 21bit로 확장하였다.

    새로 추가된 문자들을 (supplementary character)**보충 문자**라고 부르며
    이 문자들을 표현하기 위해서는 **char가 아닌 int를 사용**해야한다.
    근데 이 문자들을 쓸일은 거의 없어서 참고로만 알아두면 된다.

    - **Unicode Character Set, 유니코드 문자 셋**

        유니코드에 포함된 문자들의 집합

    - 유니코드 인코딩

        유니코드 문자 셋에 번호를 부여 한 것

        - 종류

            UTF-8, UTF-16, UTF-32등이 있으며 숫자가 커질수록 메모리 효율이 떨어진다.
            처음 인코딩 128문자는 아스키코드 영역으로 통일되어있다.

            [https://stackoverflow.com/a/496335](https://stackoverflow.com/a/496335)

            | code point | 유니코드 문자 셋 | ASCII | UTF-8 | UTF-16 |
            | --- | --- | --- | --- | --- |
            | … | … | … | … | … |
            | U+0061 | a | 0x61 | 0x61 | 0x0061 |
            | U+0062 | b | 0x62 | 0x61 | 0x0061 |
            | … | … | … | … | … |
            | U+AC00 | 가 | - | 0xEAB080 | U+AC00 |
            | U+AC01 | 각 | - | 0xEAB081 | U+AC01 |
            | … | … | … | … | … |
            - UTF-8

                하나의 문자를 1~4~6(6까진 보통 안감)byte 가변크기로 표현,
                1byte인 경우는 아스키코드영역만 사용하는 경우이며 대부분의 경우 2byte를 사용한다.
                **영어만 사용한 경우 용량이 상대적으로 적기 때문에 웹 문서 대부분이 UTF-8 방식을 사용한다.**

                영어와 숫자는 1byte, 한글은 3byte

            - UTF-16

                모든 문자를 2 ~ 4byte 가변크기로 표현, 아시아국가에 특화되어있다.
                보통 아시아 국가권 글자는 2byte를 넘기는 경우가 대다수다

            - UTF-32

                모든 문자를 4 Byte 고정크기로 표현, 보통 잘 안쓴다.


## 정수형 - byte, short, int, long

| byte | short | int [default] | long |
| --- | --- | --- | --- |
| 1 byte | 2 byte | 4 byte | 8 byte |

### 정수형의 표현 형식과 범위

| S | n-1 bit |
| --- | --- |
| 부호 비트 (양수는 0, 음수는 1) | n 타입의 크기 (단위: bit) |

| 정수형의 표현 방식 (n bit) | 종류 | 값의 개수 |
| --- | --- | --- |
| 0 | n-1 bit | 0, 양수 | 2^(n-1) |
| 1 | n-1 bit | 음수 | 2^(n-1) |

| 타입 | 저장 가능한 값의 범위 | bit | byte |
| --- | --- | --- | --- |
| byte | -128 ~ 127
( -2^7 ~ 2^7 - 1 ) | 8 | 1 |
| short | -32,768 ~ 32,767
( -2^15 ~ 2^15 - 1 ) | 16 | 2 |
| int | -2,147,483,648 ~ 2,147,483,647
( -2^31 ~ 2^31 - 1 ) | 32 | 3 |
| long | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807
( -2^63 ~ 2^63 - 1 ) | 64 | 4 |
- 특징
    1. 모든 정수형은 부호 있는 정수이며 왼쪽 첫 비트를 sign bit으로 사용
    2. **n 비트로 표현 할 수 있는 값의 개수**인 2^n가 아닌 **0과 양수는 2^(n-1), 양수는 2^(n-1)**씩 이다.



- byte의 경우


    | byte의 표현 방식 (n bit) | 종류 | 값의 개수 |
    | --- | --- | --- |
    | 00000000 ~ 01111111 | 0, 양수 | 2^7, (0 ~ 127) |
    | 10000000 ~ 11111111 | 음수 | 2^7, (-128 ~ -1) |

### 정수형의 선택기준

- 결론

    **int를 사용할 것**

    - 이유
        1.  byte나 short은 메모리 효율의 장점은 있지만 범위가 작아 잘못된 값을 얻을 확률이 크다.
        2. JVM의 피연산자 스택, operand stack은  피연산자를 4 byte단위로 저장한다.
        즉, byte나 short을 쓰게 되면 4 byte로 변환하는 과정이 추가되어 오히려 성능 저하를 야기한다.
    - 사용 규칙

        무조건 정수형은 int를 사용하고 int를 벗어나는 값은 long,
        long을 벗어나는 경우에는 BigInteger를 사용하자

        <aside>
        💡 double을 써도 되지만 혹시 모를 연산 오류를 배제한다면 BigInteger가 낫다

        </aside>


### 정수형의 오버플로우

- 오버플로우

    연산과정중 해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것

    - 예시
        - 4 bit 2진연산중 1111에 1을 더하게 될 경우 [덧셈]

            자리올림 비트는 저장할 공간이 없어 버려지게 되고 4 bit만 가지게 되므로 0000(2)이 된다.

            1111(2) + 0001(2)

            ⇒ 1**0000**(2)

            ⇒ **0000**(2)

        - 4 bit 2진연산중 0000에 1을 빼게 될 경우 [뺄셈]

            자리올림 비트가 있다고 가정하게 되어 1111(2)이 된다.

            0000(2) - 0001(2)

            ⇒ 10000(2) - 0001(2)

            ⇒ 1111(2)

    - 정리

        비트연산의 원리는 옛날 자동차 주행거리 표시기나 가스 카운터 (계수기)를 생각해보면 된다.

        ⇒ 9999…이상을 위를 넘어가면 0000, 0000에서 아래로 넘어가면 9999

        이를 토대로 정수형의 최대값, 최소값의 원리는 다음과 같다.

        <aside>
        💡 최대값 + 1 ⇒ 최소값
        최소값 + 1 ⇒ 최대값

        </aside>


### 부호 있는 정수의 오버플로우

<aside>
💡 부호 비트, sign bit가 0 → 1이 될 때 발생한다.

</aside>

| 부호없는 10진수 | 2진수 | 부호있는 10진수 |
| --- | --- | --- |
| 0 | 0000 | 0 |
| 1 | 0001 | 1 |
| 2 | 0010 | 2 |
| 3 | 0011 | 3 |
| 4 | 0100 | 4 |
| 5 | 0101 | 5 |
| 6 | 0110 | 6 |
| 7 | 0111 | 7 (최대값) |
| 8 | 1000 | -8 (최소값) |
| 9 | 1001 | -7 |
| 10 | 1010 | -6 |
| 11 | 1011 | -5 |
| 12 | 1100 | -4 |
| 13 | 1101 | -3 |
| 14 | 1110 | -2 |
| 15 (최대값) | 1111 | -1 |
| 0 (최소값) | 0000 | 0 |
| 1 | 0001 | 1 |
| 2 | 0010 | 2 |

### 예시

```java
package ch2;

public class OverflowEx {
    public static void main(String[] args) {
        short sMin = -32768;
        short sMax = 32767;
        char cMin = 0;
        char cMax = 65535;

        System.out.println("sMin = " + sMin);
        System.out.println("sMin-1 = " + (short)(sMin-1));
        System.out.println("sMax = " + sMax);
        System.out.println("sMax+1 = " + (short)(sMax+1));
        System.out.println("cMin = " + (int)cMin);
        System.out.println("cMin = " + (int) --cMin);
        System.out.println("cMax = " + (int)cMax);
        System.out.println("cMax = " + (int)++cMax);
    }
}
```

- 실행결과

    [[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-10-01_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.44.08.png]]

- 특징

    short는 부호 있는 -2^15 ~ 2^15-1 범위

    char는 부호 없는 0 ~ 2^16 -1 범위

    이 차이를 명백히 알수 있는 예제이다.


## 실수형 - float, double

### 실수형의 범위와 정밀도

| 타입 | 저장 가능한 값의 범위 | 정밀도 | bit | byte |
| --- | --- | --- | --- | --- |
| float | -3.4 * (10^38) ~ -1.4 * (10^-45) ~
0
~ 1.4 * (10^-45) ~ 3.4 * (10^38)  | 7자리 | 32 | 4 |
| double | -1.8 * (10^308) ~ -4.9 * (10^-324) ~
0
~ 4.9 * (10^-324) ~ 1.8 * (10^308) | 15자리 | 64 | 8 |
- 정수형 저장방식과 실수형 저장방식의 차이
    - 정수형

        int: 1 + 31 = 32 (4 byte)

        | S(1) | 31 bit |
        | --- | --- |
        - 구성

            부호부(S), 값 비트

    - 실수형

        float: 1 + 8 + 23 = 32 (4 byte)

        | S(1) | E(8) | M(23) |
        | --- | --- | --- |
        - 구성

            부호부(S), 지수부(E), 가수부(M)

    - 정리

        float는 7자리 정밀도를 가지며 7자리 10진수를 오차없이 저장할 수 있다는 뜻,

        double은 이 2배인 15자리 정밀도를 가진다.

        <aside>
        💡 1234.567 = 1.234567 * (10^3)
        0.00001234567 = 1.234567 * (10^-5)
        1234567000 = 1.234567 * (10^9)

        이 값들은 float에 오차없이 저장가능

        </aside>

        - 실수형 선택기준

            <aside>
            💡 연산속도의 향상이나 메모리를 절약한다: float
            더 큰 범위나 더 높은 정밀도를 요구한다: double

            </aside>

            double이 default인 이유는 애플리케이션의 성능보다 데이터의 정밀도가 더 우선순위이기 때문


### 예제

```java
package ch2;

public class FloatEx1 {
    public static void main(String[] args) {
        float f = 9.12345678901234567890f;
        float f2 = 1.2345678901234567890f;
        double d = 9.12345678901234567890d;

        System.out.printf("     123456789012345678901234%n");
        System.out.printf("f : %f%n",f);
        System.out.printf("f : %24.20f%n",f);
        System.out.printf("f2 : %24.20f%n",f2);
        System.out.printf("d : %24.20f%n",d);
    }
}
```

- 실행결과

    [[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-10-01_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.31.04.png]])

- 특징
    1. 실수형 포멧 출력하기 위해선 %f를 사용해야한다.
    2. %f 지시자는 소수점 6자리까지만 표현하고 7자리 숫자는 반올림한다.
    3. float의 정밀도는 7까지인데 그 이상을 벗어나는 숫자를 저장하면 오차가 발생한다.
        - 초기에 할당한 원래 값

            ⇒ **9.123456**78901234567890

        - 저장된 값

            ⇒ **9.123456**95495605500000

            7자리까지는 이렇게 오차가 없이 저장이 된다.

            이런 예외의 경우도 있지만 이건 기대해선 안된다.

            ⇒ **1.2345678**8063049320000


### 실수형의 오버플로우, 언더플로우

<aside>
💡 실수형의 오버플로우는 무한대(∞, infinity)로 간다.
특이하게 언더플로우도 존재하는데 이는 무한히 0에 가까운 작은 값을 의미한다.
즉, 실수형의 언더플로우 결과는 0이 된다.

실수형의 오버플로우 결과: 무한대(∞, infinity)
실수형의 언더플로우 결과: 0

</aside>

### 실수형의 저장방식

실수형은 부동소수점 형태로
부호부(Sign), 지수부(Exponent), 가수부(Mantissa)로 구성된다.

- 구성
    - float

        1 + 8 + 23 = 32 (4 byte)

        | S(1) | E(8) | M(23) |
        | --- | --- | --- |
    - double

        1 + 15 + 52 = 64 (8 byte)

        | S(1) | E(11) | M(52) |
        | --- | --- | --- |
- 특징

    전기 전자 기술자 협회(IEEE, Institute of Electrical and Electronics Engineers)에서 제정한
    부동소수점 표준인 IEEE754 표준을 따른다.

- 부호 (Sign bit)

    부호비트 1 bit를 저장하는 공간

    실수형은 2의 보수법을 쓰지 않기 때문에 실수형은 1 bit 하나로 부호를 변경한다

- 지수 (Exponent)

    지수를 저장하는 공간

    float의 경우 8 bit이므로 2^8(=256개)개를 저장할 수 있다.

    ⇒ -127 ~ 128

    이중 맨끝은 특별한 값으로 예약되어 있어 실제 이용가능한 개수는 254개이다.

    ⇒ -126 ~ 127
    (-127= Negative Infinitiy, 음의 무한대, 128= Positive Infinitiy, 양의 무한대로 예약되어 이용불가)

    - 정리
        1. float의 최대값은

            2^127 ⇒ 10^38

        2. float의 최소값은 가수의 마지막자리가 2^-23이므로 이것까지 따져보면

            2^-126 * 2^-23 ⇒ 2^-149 ⇒ 10^-45

- 가수 (Mantissa)

    실제 값을 저장하는 공간

    - float의 경우

        2^23 ⇒ 약 10^7 저장가능

        ⇒약 7자리 정밀도

    - double의 경우

        2^52 ⇒ 약 10^15 저장가능

        ⇒ 약 15자리 정밀도


### 부동소수점의 오차

실수중에는 무한 소수가 존재해 늘 오차가 존재한다.

특히 컴퓨터에 뭐든 저장하는 경우엔 2진수로 저장되므로 오차는 무조건 발생한다.

- 예시
    1. 𝛑(=3.141592…)
    2. 진법변환후 무한소수로 변환되는 경우

        9.1234567(10) ⇒ 1001.00011111…(2)

- 부동소수점 저장과정
    1. 2진법으로 진법 변환
        - 예시

            9.1234567(10) ⇒ 1001.000111111001101011011011…(2)

    2. 정규화

        1.xxx * 2^n 형태로 만든다.

        - 예시

            1001.000111111001101011011011…(2) ⇒ 1.001000111111001101011011011… * 2^3(2)

    3. 메모리에 저장
        1. 지수 저장

            지수는 기저법으로 저장된다.

            기저법: 저장할 때 특정 값 (기저)를 더한 후 저장하고 읽을 때는 특정 값을 뺀다

            - 예시

                1.001000111111001101011011011… * **2^3**(2)

                ⇒ 2^3

                ⇒ 3 + 127 = 130(10) (기저인 127을 더한다)

                ⇒ 130(10)

                ⇒ **10000010(2)**

        2. 가수 저장

        저장시엔 딱 가수 비트만큼만 저장하고 나머지는 버린다.

        - 예시

            1.**00100011111100110101101**~~1011…~~(2) ⇒ 1.00100011111100110101101(2)

    - 최대 오차

        저장시 잘려나간 가수의 의해 발생가능한 최대 오차

        **가수의 마지막 bit 단위와 같다**

        - float의 경우

            2^-23

            ⇒ **0.000000**1192

            ⇒ 약 10^-7

        - double의 경우

            2^-52

            ⇒ **0.00000000000000**…

            ⇒ 약 10^-15


### 예제

```java
package ch2;

public class FloatToBinEx {
    public static void main(String[] args) {
        float f = 9.1234567f;
        int i = Float.floatToIntBits(f);

        System.out.printf("%f%n",f);
        System.out.printf("%X%n",i);
    }
}
```

- 실행 결과

    [[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-10-01_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.33.38.png]])

- 동작 과정
    1. 변환


        | 0 | 100 0001 0 | 001 0001 1111 1001 1010 1101 1011 버림 |
        | --- | --- | --- |
        |  |   4      1 |   1       1       F       9      A     D      B |
    2. 오차는 반올림하면서 버린다.


        | 0 | 100 0001 0 | 001 0001 1111 1001 1010 1110 (반올림) |
        | --- | --- | --- |
        |  |   4      1 |   1       1       F       9      A     E |
