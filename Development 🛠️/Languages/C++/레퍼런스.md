# 레퍼런스

## 레퍼런스란?

<aside>
💡 변수 또는 상수를 가리키는 포인터와 다른 또 다른 방법

</aside>

### 사용법

```jsx
int a = 12;

int& anotherA = a;
```

- 설명
    - `anotherA`는 `a`의 레퍼런스이다.
    - 레퍼런스는 컴파일러 상에서 `a`의 별칭으로써 대체된다.

### 특징

1. 레퍼런스는 컴파일러상에서 특정 변수를 의미하도록 별명으로써 치환이 된다.
2. 메모리상에 특별한 일이 없으면 공간을 차지하지 않는다.
3. 반드시 선언와 동시에 초기화를 진행해야한다.

    그렇지 않으면 컴파일 오류를 야기한다.

4. 한번 레퍼런스로 지정된 레퍼런스는 다른 변수의 레퍼런스가 되지 않는다. 따라서 immutable 하다.

    다른 변수를 지정시키면 컴파일 오류를 야기한다.

5. 함수 파라미터로 레퍼런스를 사용하게 되면 해당 변수를 직접적으로 대체하게 된다.

    따라서 포인터 없이 다른 함수에서 외부 변수에 접근할 수 있게 된다.

    외부 함수에서 메모리를 사용하지 않고 (포인터 없이) 외부 변수에 접근하게 만드는 c++ 레퍼런스의 특징!


### 포인터와의 차이점

1. 포인터는 메모리 공간을 무조건 차지하지만 레퍼런스는 같은 스택 프레임일 경우 차지하지 않는다.
2. 포인터는 변수의 주소값을 가리키지만 레퍼런스는 변수 그 자체를 별칭으로써 의미한다.
3. `cin`으로 입력을 받을때 `&`을 변수앞에 붙이지 않는 이유는 레퍼런스로써 동작하기 때문이다.

### 장점

1. 같은 스택에서 사용하면 일반적으로 메모리를 먹지 않는다.
2. 메모리를 먹지 않으면서 큰 구조체를 데이터 전달용 자료구조로써

    큰 구조체를 파라미터로 넘기게 되면 복사 코스트가 많이 들지만

    이를 방지하는 방법은 C에서는 포인터, C++에서는 일반적으로 레퍼런스가 사용된다.

    그러나 사실 코스트는 비슷하게 들어간다.

    어차피 레퍼런스는 외부에서 생성한 구조체 변수의 레퍼런스를 넘겨야하며

    이 매개변수를 받기 위해선 해당 이 레퍼런스 변수는 메모리에 올라가게 된다.

    이러나 저러나 메모리는 먹는건 매한가지라는 것,

    그럼에도 불구하고 C++에서는 다음과 같은 이유로 레퍼런스 사용을 권장한다.

    - C++에서 권장하는 이유
        1. NULL 안정성

            레퍼런스의 기본적인 특징은 반드시 생성과 동시에 초기화를 해야한다.

            이때 포인터와 달리 null 할당이 당연히 불가능하므로 NULL에서 안전한 코드작성이 가능하다.

        2. 메모리 로딩 실수 방지

            포인터는 기본적으로 주소값 변수이다.

            거기에 충분히 엉뚱한 변수의 주소를 지정할 수도 있다.

            레퍼런스는 다른 변수 지정시 컴파일타임에 에러를 내기 때문에 안전한 코드작성이 가능하다.


### 레퍼런스가 메모리 공간을 잡아먹는 경우

실행흐름상 스택 밖 변수의 레퍼런스를 다른 스택에서 호출하는 경우(실행흐름이 한 스택프레임에서 다른 스택 프레임으로 옮겨지는 경우)

특히 이 레퍼런스를 유지해야 할 필요가 있을 때 메모리를 요구한다.

- 예시
    1. 레퍼런스를 매개변수로 넘겨야하는 경우
    2. 레퍼런스로 매개변수를 넘기고 다시 반환하는 경우 (어찌되었든 1번과 같은 경우)

### 주의점

1. 레퍼런스를 반환하는 함수를 만들때, 해당 레퍼런스는 외부 변수의 레퍼런스를 받아야한다. [**Dangling**]
    - 예시

        ```cpp
        #include <iostream>

        int& functionA(int& ref) {
          // ... 기타 각종 처리
          return ref;
        }

        int& functionB() {
        	int functionBInteger = 10;
        	int& functionBIntegerRef = functionBInteger;
          // ... 기타 각종 처리
          return functionBIntegerRef;
        }

        int main() {
        	int integerA = 10;
        	int& integerARef = integerA;
          int& functionARef = functionA(integerARef); // OK!
        	int& functionBRef = functionB(); // **Dangling**! 일반적으로 런타임에러가 발생,
        																	// 경우에 따라 그냥 동작되는 경우도 있다고함
        																	// 허나 무조건 이렇게 지역변수의 레퍼런스를 넘기는 일은 절대! 안된다.
          std::cout << "c : " << c << std::endl;

          return 0;
        }
        ```

    - 이유

        함수에서 레퍼런스를 바로 반환하게 되면 함수의 리턴되는 레퍼런스 대상인 지역 변수는 소멸되므로

        어디에 있는 변수인지 컴파일러가 예측하지 못한다.

2. 외부 변수 레퍼런스가 아닌 지역변수를 레퍼런스의 변수로써 전달 받더라도 `const`를 붙이면

    컴파일러가 해당 지역변수를 호출부 스택에 메모리로 올려준다.

    - 예시

        ```cpp
        #include <iostream>

        int function() {
          int a = 5;
          return a;
        }

        int main() {
          const int& c = function(); // OK!
          std::cout << "c : " << c << std::endl;
          return 0;
        }
        ```

    - 이유

        `const`는 기본적으로 컴파일 단계에서 상수로써 선언된 스택에 고정시켜야할 변수를 무조건 스택영역 메모리에 올리도록 만드는 단계이다.

        이때, 외부 함수의 리턴으로 레퍼런스를 받는다고 해도 이경우 메모리에 올려버린다.

3. 2의 이유로 레퍼런스를 상수화 하는 것이 가능하다.
    - 예시

        ```cpp
        #include <iostream>

        int main() {
          const int& aInteger = 10; // OK!
          return 0;
        }
        ```

    - 이유

        const는 컴파일 단계에서 상수로써 선언된 스택에 고정시켜야할 변수를 무조건 스택영역에 올린다고 했다.

        **그리고 예시의 리터럴 상수도 해당 row에만 살아 있는 상수로 사실 이 상수값도 메모리를 먹는다.**

        그래서 다음 예시와 같은 문장이 가능하다.

        ```cpp
        #include <iostream>

        int add(const int &num1, const int &num2){
        	return num1 + num2;
        }

        int main() {
          std::cout << "add result: " << add(10, 20) << std::endl;;
          return 0;
        }
        ```

        함수 페이지에서 설명했지만 단순 값 전달을 위한 포인터, 레퍼런스 파라미터는 const를 붙여주는게 좋으며

        함수의 파라미터는 디컴파일을 해보면 한줄씩 선언및 초기화가 진행된 형태라고 하였다.

        즉, 처음부터 이게 가능해야 파라미터에 const를 붙여 상수화 하는 것이 가능하며

        예시처럼 리터럴 상수를 바로 넘겨 사용이 가능하다.

    - 정리

        2는 **함수의 리턴값이 임시 객체로 살아있는 것**을 이용했고

        3은 **리터럴값이 임시로 살아 있는 것**을 이용한 원리이다.


3. `swap()` 함수를 사용하면 temp 변수 없이 편하게 변수끼리 값 이동이 가능하다.

이것을 **copy/swap idiom** 이라고 부르며 c++ idiom 중에 하나이다.
