# 이동생성자
> 단순히 포인터 주소를 이동시켜주는 생성자

C++은 value(값)을 범주를 총 5가지로 나누긴 하지만(서로 포함 비포함되는 복잡한 관계이다.[관련 링크](https://medium.com/@barryrevzin/value-categories-in-c-17-f56ae54bccbe)) 우선 ==주소 값 소유가능 여부==를 두고 일반적으로 **2개의 값**으로 구분짓는다. 


<br>

## 우측값과 좌측값 (rvalue와 lvalue)
<br>

### 우측값, rvalue
> 잠시 임시객체로 메모리에 존재했다가 구문이 끝나면 사라지는 값, 리터럴이 대표적이며 **주소 값을 취할 수 없는 값**이다.

<br>


### 좌측값, lvalue
> **주소 값을 취할 수 있는 값**, `&`연산자로 주소값을 알아낼 수 있는 값

<br>


### 예시
``` cpp
int a; // 좌측값
int &l_a = a; // l_a는 좌측값 레퍼런스

int &r_b = 3; // 3은 우측값, 따라서 컴파일 에러 발생!
```
+ 설명
	여태 지금까지 다루던 레퍼런스는 대표적인 좌측값에만 레퍼런스를 가질 수 있다는 특징을 가지고 있었다.
	그러므로, 잠시 메모리에 있다가 사라지는 존재인 `3` 같은 리터럴 값은 우측값이기 때문에 레퍼런스를 가질 수 없어 컴파일 에러가 발생하는 것이다.
	*(다만 const를 붙이면 컴파일러에게 스택에 살려둘 변수를 알려줘 살릴 수는 있던 것이다.)*
	여튼 이렇게 되어 `&`하나를 이용해 정의하는 레퍼런스를 **좌측값 레퍼런스**라고 하며 ==좌측값 레퍼런스 자체도 좌측값==이다.

## 포인터 이동을 알아야 하는 이유

단순 포인터 이동을 하지 않고 지금까지는 **깊은 복사**를 시도했었다.

그래서 복사 생성자를 만들어 `char*` 같은 녀석들을 복사를 한뒤 `delete`까지 해서 해제까지 해주었었다.

그러나 이로인해 생기는 loss가 너무 크다. 단순히 주소 값만 옮겨주면 되는 것인데 
오히려 깊은 복사는 `char` 를 한땀 한땀 복사를 하는 것이다.

그래서 이를 좀 더 쉽게 지원해주기 위해 stl에는 `std::move()`라는 이동 연산이 따로 존재할 정도이다.

여튼 직접 이동생성자를 만들어야하는 상황이라면 예제는 다음과 같다.
<br>

### 예제

``` cpp
class Person{
private:
	char * name;
public:
	Person(Person&& ref){
		name = ref.name;
		ref.name = nullptr;
	}
};
```
+ 설명
	1. 기존의 복사 생성자는 `const Person& ref` 이런식으로 객체를 넘겨받았기 때문에 인자의 값을 수정할 수 없었다. 그러나 이렇게 `const`가 아닌 `&&`을 두번 넣은 **우측값 레퍼런스**를 사용하면 된다.
	2. 문자열 전체를 복사할 필요 없이 임시객체가 가지고 있는 ref의 문자열 주소를 넣어준다.
	3. 넘어온 임시객체의 주소에는 `nullptr`를 넣어주고 소멸자에서 `nullptr`일땐 `delete` 시도를 하지 못하게 막으면 그만이다.
	보다 시피 상당히 간단하지만 몰라서 못써먹었던 기술중에 하나이다.
	**생성자**, **소멸자**, **복사생성자**, **대입연산자 오버로딩**, 그리고 대막의 이 **==이동생성자==**까지 포함해야 온전한 클래스[Rule Of 5]라고 부를 수 있다.

	 모던 C++ 에서는 굉장히 지양하는 프로그래밍중에 하나이긴하다. 
	 모던 C++ stl을 빠르게 습득하는 것을 권장하며 stl을 활용해 Rule Of 0를 사용하도록 권장하는 추세이다.
	 
	 그러므로 STL을 빠르게 습득하도록 하자...
<br>
## 주의 사항
1. vector 사용시 이동 생성자를 반드시 `noexcept`로 명시해야한다.
   (`noexcept`는 명시한 스택에서 예외가 터지지 않는 것을 명시하는 예약어이다. 이걸 적어야 `vector` 타입으로 넘긴 클래스로 `push_back(...)`을 하면 복사 생성자가 아닌 이동 생성자를 사용한다.)
   + 복사 생성자 사용시
	    한 메모리 한 메모리씩 복사하다 예외가 발생해도 새로 할당해놓은 메모리를 소멸시킨뒤 사용자에게 예외를 던지면 된다.
	   새로 할당한 메모리를 소멸시키는 과정에서 복사된 원소들도 소멸되므로 자원이 낭비되는 일또한 없다.
   + 이동 생성자 사용시
	   그러나 이동생성자를 사용하면 이동하는 과정에서 예외발생시 소멸을 시키더라도 기존의 원소들은 죄다 이동되서 원래 메모리 위치에 원소가 없으니 해제를 섵불리 할 수가 없다.
	   따라서 `vector`의 경우 이동생성자에서 예외가 발생하면 이를 제대로 처리할 방법이 존재하지 않는다.