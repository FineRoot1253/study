# Spring Data JPA

### 공식 레퍼런스 Doc

[Spring Data JPA - Reference Documentation](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/)

## 버저닝

효과적으로 락을 걸기 위한 기능

기본적으로 *두번 갱신 분실 문제*를 해결 하기 위해 존재한다.

<aside>
⚠️ “*두번 갱신 분실 문제”*란 레코드 A에 대해 1번 유저가 새로 업데이트를 하고 조회를 하는 도중 2번 유저가 업데이트를 하여 1번 유저가 업데이트한 내용이 사라져 버리는 문제이다.

</aside>

- 정리

    A 레코드의 특정 로우에 매번 버전을 체크하고 2번 유저가 업데이트 도중 버전이 다를 경우 업데이트를 롤백하는 방법이다.

- 변경 감지 방식일 경우
    1. 1번유저와 2번 유저 영속성 컨텍스트에 레코드 A 에 대해 영속화
    2. 1번 유저가 먼저 업데이트후 레코드 A에 대하여 Version +1 증가
    3. 2번 유저또한 변경시 더티체크후 flush
    4. 그러나 이미 디비에 영속화된 레코드의 Version과 2번 유저 세션에 영속화된 레코드 A의 Version이 일치하지 않아 실패
    5. 2번 유저 변경사항 롤백후 에러 반환
- 주의 사항

    **Version 어노테이션을 엔티티에 적용하면 해당 엔티티를 조회할 때에는 무조건 낙관적 락을 걸게 된다.**


## 쿼리메소드

## 확장기능

## 기타기능

### 명세, Specifications

Eric Evans의 *“Domain Driven Design”*에서 개념을 가져온 Where문을 정의하기 위해 사용되는 인터페이스를 말한다. Spring Data JPA는 Criteria를 활용한다.

- 목적

    도메인 규칙 (비즈니스 도메인의 규칙, 요구사항 명세)을 서비스레벨이나 레포지터리 레벨에 들어가는 것을 방지 하기 위해서 도메인 규칙, 즉 요구 사항 명세 객체를 따로 만들어 끄집어 내고 이것을 각 서비스 레벨에서 사용하기 위함이다.

- 결론

    실무에서 사용하기 애매하다. 결국 JPA + QueryDSL을 추천하는 이유는 명백한 쿼리문이기 때문이다.


### Query By Example

도메인 객체를 검색 조건으로 사용해 조회하는 방식

- 목적

    검색을 하게 된다면 결국 where문에 들어가는 것들은 도메인 객체에 대한 것이기 때문에 굉장히 편하게 검색이 가능하다. 동적 쿼리를 쉽게 해결하는 방법이다.

- 결론

    실무에서 사용하기 애매하다. left outer join이 제대로 지원 되지않아 left join을 써야하는 상황이 온다면 기존 코드를 싹 엎어야된다. 이것 때문에 결국 다시 JPA + QueryDSL을 추천하는 것이다.


### Projections

편하게 DTO로 조회하기 위한 방법

- 목적

    기존 DTO로 조회하기 위해선 new 연산을 jpql에 넣어야하거나 엔티티 객체로 조회후 온메모리에서 직접 map과 stream을 사용해 새로 생성해야 해서 복잡하고 힙 메모리 또한 많이 잡아먹어 곤란했지만 이것을 해소 하기 위해 사용된다.

- 결론

    Root 엔티티라면 사용이 가능하지만 그게 아닌 이상 최적화가 되질 않는다. 보통 DTO은 연관된 테이블 정보도 이쁘게 정리해서 들고와 엔티티를 반환 대상을 쓰지 않고 api 스펙 통일 목적이 큰데 그게 지원이 제대로 되지 않는다면 결국 다시 JPA + QueryDSL을 사용해야한다.


### NativeQuery

DBMS에 맞는 네이티브한 쿼리를 직접 사용하는 방식

- 목적

     JPA가 지원하는 기능 외에 DBMS 자체 기능을 사용해야만 하는 상황인 경우에 사용하는 방식

- 결론

    정말 방법이 없는 경우 아니면 사용하지 말자. sort 자체가 제대로 동작하지 않으며 그냥 JDBC Temaplate이나 MyBatis mapper를 쓰는게 낫다. 그 이유는 페이징까지는 프로젝션을 사용하면 해결이 되지만 동적쿼리의 경우에는 해결 방법이 저 마이바티스를 사용하는것이 낫기 때문이다.


### 부연설명

- 각 JPA의 특징
    - 모든 Repository 구현체에 트랜잭션이 기본적으로 readOnly로 걸려있다.

        만약 상위 Service 계층에 걸어두었다면 그 트랜잭션부터 이어받아서 동작하지만

        만약 다른 상위 계층에도 없는 경우 그냥 이 레포지터리들에 기본적으로 걸려서 동작한다.

        저장, 삭제, 업데이트의 경우는 내부 메서드에 따로 걸린 전형적인 구조이다.
