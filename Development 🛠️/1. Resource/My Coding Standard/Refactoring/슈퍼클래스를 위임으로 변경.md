# 슈퍼클래스를 위임으로 변경

```jsx
class List{...}
class Stack extends List{...}
```

↓

```jsx
class Stack{
	constructor() {
		this._storage = new List();
	}
}
```

<aside>
⚠️ *"상속을 잘못 적용한 예로는 **자바의 스택 클래스**가 유명...**리스트의 연산 중 스택에는 적용되지 않는 것이 많음**에도 그 **모든 연산이 스택 인터페이스에 그대로 노출**되는게 아닌가! 이보다는 스택에서 **리스트 객체를 필드에 저장**해두고 **필요한 기능만 위임** 했다면..."*

</aside>

<aside>
💬 참고로 Dart에서는 Mixin이라는 것으로 쉽게 해결이 가능하다. 필요한 인터페이스만 추상 클래스에서 뽑아다 구현해두면 된다. 오버라이드도 필요 없는 자바 인터페이스라고 보면된다. 대신 사용 클래스에서 implements를 사용하지 않고 with이라는 키워드로 상속 받아야 한다.([[사용법]])

</aside>

제대로 된 상속이란

- 서브클래스가 슈퍼클래스의 모든 기능을 사용
- 서브클래스의 인스턴스를 슈퍼클래스의 인스턴스로도 취급 가능

    <aside>
    ⚠️ *"...만약 이름과 엔진 크기등을 속성으로 갖는 자동차 모델 클래스(타입)가 있다고 하자. 여기에 차량 식별 번호와 제조일자 메서드를 더하면 물리적인 자동차(인스턴스)를 표현하는 데 재활용할 수 있을 것이라고 착각하는 것이다. ..." [[타입 인스턴스 동형이의어]]*

    </aside>

    <aside>
    ⚠️ *"위임을 이용하면 기능 일부만 빌려올 뿐인, 서로 별개인 개념이 명확해진다."*

    </aside>

- 슈퍼/서브 클래스의 강한 결합때문에 슈퍼클래스 수정시 서브클래스가 망가지지 쉽다고 판단 될 때

단점

- 위임의 기능을 이용할 호스트 함수를 전부 전달 함수로 만들어야 한다.

<aside>
⚠️ 상속은 일단 적용하고 나중에 문제가 생기면 위임으로 바꾸자

</aside>

<aside>
💬 위임화는 상당히 간단해서 절차만 적어 놓겠다. 다만 **언제** 적용해야할지는 공부해야한다. ([[예시]])

</aside>

### 절차

1. 슈퍼클래스 객체를 참조하는 필드를 서브클래스에 만든다.(이번 리펙터링이 끝나면 슈퍼클래스는 위임 객체가 되므로 이 필드는 위임참조라고 부르자) 위임 참조를 새로운 슈퍼클래스 인스턴스로 초기화한다.
2. 슈퍼클래스의 동작 각각에 대응하는 전달 함수를 서브클래스에 만든다.(위임 참조로 전달한다.)
    - 관련 함수까리 그룹으로 묶어 진행하며 1수정 1테스트
    - 게터와 세터는 둘다 동시에 옮겨 테스트
3. 슈퍼클래스의 동작 모두가 전달 함수로 오버라이드 되었다면 상속관계를 끊는다.

    책의 예제에서는 스크롤과 카탈로그아이템의 상속 관계를 끊고 실제 인스턴스의 모델이 될 스크롤이 각각 카탈로그의 아이템을 가지도록(위임) 했다.

    더 나은 방법은 스크롤 자체를 유니크하게 자신 만의 필드를 가지게 하고 카탈로그 자체를 넘겨 그 카탈로그 아이템을 참조하게끔 만드는것이다.
